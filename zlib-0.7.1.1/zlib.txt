-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Compression and decompression in the gzip and zlib formats
--   
--   This package provides a pure interface for compressing and
--   decompressing streams of data represented as lazy <a>ByteString</a>s.
--   It uses the <a>zlib C library</a> so it has high performance. It
--   supports the "zlib", "gzip" and "raw" compression formats.
--   
--   It provides a convenient high level API suitable for most tasks and
--   for the few cases where more control is needed it provides access to
--   the full zlib feature set.
@package zlib
@version 0.7.1.1


-- | Pure and IO stream based interfaces to lower level zlib wrapper
module Codec.Compression.Zlib.Internal

-- | Compress a data stream provided as a lazy <a>ByteString</a>.
--   
--   There are no expected error conditions. All input data streams are
--   valid. It is possible for unexpected errors to occur, such as running
--   out of memory, or finding the wrong version of the zlib C library,
--   these are thrown as exceptions.
compress :: Format -> CompressParams -> ByteString -> ByteString

-- | Decompress a data stream provided as a lazy <a>ByteString</a>.
--   
--   It will throw an exception if any error is encountered in the input
--   data. If you need more control over error handling then use one the
--   incremental versions, <a>decompressST</a> or <a>decompressIO</a>.
decompress :: Format -> DecompressParams -> ByteString -> ByteString

-- | The unfolding of the compression process, where you provide a sequence
--   of uncompressed data chunks as input and receive a sequence of
--   compressed data chunks as output. The process is incremental, in that
--   the demand for input and provision of output are interleaved.
data CompressStream (m :: Type -> Type)
CompressInputRequired :: (ByteString -> m (CompressStream m)) -> CompressStream (m :: Type -> Type)
[compressSupplyInput] :: CompressStream (m :: Type -> Type) -> ByteString -> m (CompressStream m)
CompressOutputAvailable :: !ByteString -> m (CompressStream m) -> CompressStream (m :: Type -> Type)
[compressOutput] :: CompressStream (m :: Type -> Type) -> !ByteString
[compressNext] :: CompressStream (m :: Type -> Type) -> m (CompressStream m)
CompressStreamEnd :: CompressStream (m :: Type -> Type)

-- | Incremental compression in the <a>ST</a> monad. Using <a>ST</a> makes
--   it possible to write pure <i>lazy</i> functions while making use of
--   incremental compression.
--   
--   Chunk size must fit into <a>CUInt</a>.
compressST :: Format -> CompressParams -> CompressStream (ST s)

-- | Incremental compression in the <a>IO</a> monad.
--   
--   Chunk size must fit into <a>CUInt</a>.
compressIO :: Format -> CompressParams -> CompressStream IO

-- | A fold over the <a>CompressStream</a> in the given monad.
--   
--   One way to look at this is that it runs the stream, using callback
--   functions for the three stream events.
foldCompressStream :: Monad m => ((ByteString -> m a) -> m a) -> (ByteString -> m a -> m a) -> m a -> CompressStream m -> m a

-- | A variant on <a>foldCompressStream</a> that is pure rather than
--   operating in a monad and where the input is provided by a lazy
--   <a>ByteString</a>. So we only have to deal with the output and end
--   parts, making it just like a foldr on a list of output chunks.
--   
--   For example:
--   
--   <pre>
--   toChunks = foldCompressStreamWithInput (:) []
--   </pre>
foldCompressStreamWithInput :: (ByteString -> a -> a) -> a -> (forall s. () => CompressStream (ST s)) -> ByteString -> a

-- | The unfolding of the decompression process, where you provide a
--   sequence of compressed data chunks as input and receive a sequence of
--   uncompressed data chunks as output. The process is incremental, in
--   that the demand for input and provision of output are interleaved.
--   
--   To indicate the end of the input supply an empty input chunk. Note
--   that for <a>gzipFormat</a> with the default
--   <a>decompressAllMembers</a> <tt>True</tt> you will have to do this, as
--   the decompressor will look for any following members. With
--   <a>decompressAllMembers</a> <tt>False</tt> the decompressor knows when
--   the data ends and will produce <a>DecompressStreamEnd</a> without you
--   having to supply an empty chunk to indicate the end of the input.
data DecompressStream (m :: Type -> Type)
DecompressInputRequired :: (ByteString -> m (DecompressStream m)) -> DecompressStream (m :: Type -> Type)
[decompressSupplyInput] :: DecompressStream (m :: Type -> Type) -> ByteString -> m (DecompressStream m)
DecompressOutputAvailable :: !ByteString -> m (DecompressStream m) -> DecompressStream (m :: Type -> Type)
[decompressOutput] :: DecompressStream (m :: Type -> Type) -> !ByteString
[decompressNext] :: DecompressStream (m :: Type -> Type) -> m (DecompressStream m)

-- | Includes any trailing unconsumed <i>input</i> data.
DecompressStreamEnd :: ByteString -> DecompressStream (m :: Type -> Type)
[decompressUnconsumedInput] :: DecompressStream (m :: Type -> Type) -> ByteString

-- | An error code
DecompressStreamError :: DecompressError -> DecompressStream (m :: Type -> Type)
[decompressStreamError] :: DecompressStream (m :: Type -> Type) -> DecompressError

-- | The possible error cases when decompressing a stream.
--   
--   This can be <a>show</a>n to give a human readable error message.
data DecompressError

-- | The compressed data stream ended prematurely. This may happen if the
--   input data stream was truncated.
TruncatedInput :: DecompressError

-- | It is possible to do zlib compression with a custom dictionary. This
--   allows slightly higher compression ratios for short files. However
--   such compressed streams require the same dictionary when
--   decompressing. This error is for when we encounter a compressed stream
--   that needs a dictionary, and it's not provided.
DictionaryRequired :: DecompressError

-- | If the stream requires a dictionary and you provide one with the wrong
--   <a>DictionaryHash</a> then you will get this error.
DictionaryMismatch :: DecompressError

-- | If the compressed data stream is corrupted in any way then you will
--   get this error, for example if the input data just isn't a compressed
--   zlib data stream. In particular if the data checksum turns out to be
--   wrong then you will get all the decompressed data but this error at
--   the end, instead of the normal successful <a>StreamEnd</a>.
DataFormatError :: String -> DecompressError

-- | Incremental decompression in the <a>ST</a> monad. Using <a>ST</a>
--   makes it possible to write pure <i>lazy</i> functions while making use
--   of incremental decompression.
--   
--   Chunk size must fit into <a>CUInt</a>.
decompressST :: Format -> DecompressParams -> DecompressStream (ST s)

-- | Incremental decompression in the <a>IO</a> monad.
--   
--   Chunk size must fit into <a>CUInt</a>.
decompressIO :: Format -> DecompressParams -> DecompressStream IO

-- | A fold over the <a>DecompressStream</a> in the given monad.
--   
--   One way to look at this is that it runs the stream, using callback
--   functions for the four stream events.
foldDecompressStream :: Monad m => ((ByteString -> m a) -> m a) -> (ByteString -> m a -> m a) -> (ByteString -> m a) -> (DecompressError -> m a) -> DecompressStream m -> m a

-- | A variant on <a>foldCompressStream</a> that is pure rather than
--   operating in a monad and where the input is provided by a lazy
--   <a>ByteString</a>. So we only have to deal with the output, end and
--   error parts, making it like a foldr on a list of output chunks.
--   
--   For example:
--   
--   <pre>
--   toChunks = foldDecompressStreamWithInput (:) [] throw
--   </pre>
foldDecompressStreamWithInput :: (ByteString -> a -> a) -> (ByteString -> a) -> (DecompressError -> a) -> (forall s. () => DecompressStream (ST s)) -> ByteString -> a

-- | The full set of parameters for compression. The defaults are
--   <a>defaultCompressParams</a>.
--   
--   The <a>compressBufferSize</a> is the size of the first output buffer
--   containing the compressed data. If you know an approximate upper bound
--   on the size of the compressed data then setting this parameter can
--   save memory. The default compression output buffer size is
--   <tt>16k</tt>. If your estimate is wrong it does not matter too much,
--   the default buffer size will be used for the remaining chunks.
data CompressParams
CompressParams :: !CompressionLevel -> !Method -> !WindowBits -> !MemoryLevel -> !CompressionStrategy -> !Int -> Maybe ByteString -> CompressParams
[compressLevel] :: CompressParams -> !CompressionLevel
[compressMethod] :: CompressParams -> !Method
[compressWindowBits] :: CompressParams -> !WindowBits
[compressMemoryLevel] :: CompressParams -> !MemoryLevel
[compressStrategy] :: CompressParams -> !CompressionStrategy
[compressBufferSize] :: CompressParams -> !Int
[compressDictionary] :: CompressParams -> Maybe ByteString

-- | The default set of parameters for compression. This is typically used
--   with <a>compressWith</a> or <a>compressWith</a> with specific
--   parameters overridden.
defaultCompressParams :: CompressParams

-- | The full set of parameters for decompression. The defaults are
--   <a>defaultDecompressParams</a>.
--   
--   The <a>decompressBufferSize</a> is the size of the first output
--   buffer, containing the uncompressed data. If you know an exact or
--   approximate upper bound on the size of the decompressed data then
--   setting this parameter can save memory. The default decompression
--   output buffer size is <tt>32k</tt>. If your estimate is wrong it does
--   not matter too much, the default buffer size will be used for the
--   remaining chunks.
--   
--   One particular use case for setting the <a>decompressBufferSize</a> is
--   if you know the exact size of the decompressed data and want to
--   produce a strict <a>ByteString</a>. The compression and decompression
--   functions use lazy <a>ByteString</a>s but if you set the
--   <a>decompressBufferSize</a> correctly then you can generate a lazy
--   <a>ByteString</a> with exactly one chunk, which can be converted to a
--   strict <a>ByteString</a> in <tt>O(1)</tt> time using <tt><a>concat</a>
--   . <a>toChunks</a></tt>.
data DecompressParams
DecompressParams :: !WindowBits -> !Int -> Maybe ByteString -> Bool -> DecompressParams
[decompressWindowBits] :: DecompressParams -> !WindowBits
[decompressBufferSize] :: DecompressParams -> !Int
[decompressDictionary] :: DecompressParams -> Maybe ByteString
[decompressAllMembers] :: DecompressParams -> Bool

-- | The default set of parameters for decompression. This is typically
--   used with <a>decompressWith</a> or <a>decompressWith</a> with specific
--   parameters overridden.
defaultDecompressParams :: DecompressParams

-- | The format used for compression or decompression. There are three
--   variations.
data Format

-- | The gzip format uses a header with a checksum and some optional
--   meta-data about the compressed file. It is intended primarily for
--   compressing individual files but is also sometimes used for network
--   protocols such as HTTP. The format is described in detail in RFC #1952
--   <a>http://www.ietf.org/rfc/rfc1952.txt</a>
gzipFormat :: Format

-- | The zlib format uses a minimal header with a checksum but no other
--   meta-data. It is especially designed for use in network protocols. The
--   format is described in detail in RFC #1950
--   <a>http://www.ietf.org/rfc/rfc1950.txt</a>
zlibFormat :: Format

-- | The 'raw' format is just the compressed data stream without any
--   additional header, meta-data or data-integrity checksum. The format is
--   described in detail in RFC #1951
--   <a>http://www.ietf.org/rfc/rfc1951.txt</a>
rawFormat :: Format

-- | This is not a format as such. It enabled zlib or gzip decoding with
--   automatic header detection. This only makes sense for decompression.
gzipOrZlibFormat :: Format

-- | The compression level parameter controls the amount of compression.
--   This is a trade-off between the amount of compression and the time
--   required to do the compression.
newtype CompressionLevel
CompressionLevel :: Int -> CompressionLevel

-- | The default <a>CompressionLevel</a>.
defaultCompression :: CompressionLevel

-- | No compression, just a block copy.
noCompression :: CompressionLevel

-- | The fastest compression method (less compression).
bestSpeed :: CompressionLevel

-- | The slowest compression method (best compression).
bestCompression :: CompressionLevel

-- | A specific compression level in the range <tt>0..9</tt>. Throws an
--   error for arguments outside of this range.
--   
--   <ul>
--   <li>0 stands for <a>noCompression</a>,</li>
--   <li>1 stands for <a>bestSpeed</a>,</li>
--   <li>6 stands for <a>defaultCompression</a>,</li>
--   <li>9 stands for <a>bestCompression</a>.</li>
--   </ul>
compressionLevel :: Int -> CompressionLevel

-- | The compression method
data Method

-- | The only method supported in this version of zlib. Indeed it is likely
--   to be the only method that ever will be supported.
deflateMethod :: Method

-- | This specifies the size of the compression window. Larger values of
--   this parameter result in better compression at the expense of higher
--   memory usage.
--   
--   The compression window size is the value of the the window bits raised
--   to the power 2. The window bits must be in the range <tt>9..15</tt>
--   which corresponds to compression window sizes of 512b to 32Kb. The
--   default is 15 which is also the maximum size.
--   
--   The total amount of memory used depends on the window bits and the
--   <a>MemoryLevel</a>. See the <a>MemoryLevel</a> for the details.
newtype WindowBits
WindowBits :: Int -> WindowBits

-- | The default <a>WindowBits</a>. Equivalent to <tt><a>windowBits</a>
--   15</tt>. which is also the maximum size.
defaultWindowBits :: WindowBits

-- | A specific compression window size, specified in bits in the range
--   <tt>9..15</tt>. Throws an error for arguments outside of this range.
windowBits :: Int -> WindowBits

-- | The <a>MemoryLevel</a> parameter specifies how much memory should be
--   allocated for the internal compression state. It is a trade-off
--   between memory usage, compression ratio and compression speed. Using
--   more memory allows faster compression and a better compression ratio.
--   
--   The total amount of memory used for compression depends on the
--   <a>WindowBits</a> and the <a>MemoryLevel</a>. For decompression it
--   depends only on the <a>WindowBits</a>. The totals are given by the
--   functions:
--   
--   <pre>
--   compressTotal windowBits memLevel = 4 * 2^windowBits + 512 * 2^memLevel
--   decompressTotal windowBits = 2^windowBits
--   </pre>
--   
--   For example, for compression with the default <tt>windowBits = 15</tt>
--   and <tt>memLevel = 8</tt> uses <tt>256Kb</tt>. So for example a
--   network server with 100 concurrent compressed streams would use
--   <tt>25Mb</tt>. The memory per stream can be halved (at the cost of
--   somewhat degraded and slower compression) by reducing the
--   <tt>windowBits</tt> and <tt>memLevel</tt> by one.
--   
--   Decompression takes less memory, the default <tt>windowBits = 15</tt>
--   corresponds to just <tt>32Kb</tt>.
newtype MemoryLevel
MemoryLevel :: Int -> MemoryLevel

-- | The default <a>MemoryLevel</a>. Equivalent to <tt><a>memoryLevel</a>
--   8</tt>.
defaultMemoryLevel :: MemoryLevel

-- | Use minimum memory. This is slow and reduces the compression ratio.
--   Equivalent to <tt><a>memoryLevel</a> 1</tt>.
minMemoryLevel :: MemoryLevel

-- | Use maximum memory for optimal compression speed. Equivalent to
--   <tt><a>memoryLevel</a> 9</tt>.
maxMemoryLevel :: MemoryLevel

-- | A specific memory level in the range <tt>1..9</tt>. Throws an error
--   for arguments outside of this range.
memoryLevel :: Int -> MemoryLevel

-- | The strategy parameter is used to tune the compression algorithm.
--   
--   The strategy parameter only affects the compression ratio but not the
--   correctness of the compressed output even if it is not set
--   appropriately.
data CompressionStrategy

-- | Use this default compression strategy for normal data.
defaultStrategy :: CompressionStrategy

-- | Use the filtered compression strategy for data produced by a filter
--   (or predictor). Filtered data consists mostly of small values with a
--   somewhat random distribution. In this case, the compression algorithm
--   is tuned to compress them better. The effect of this strategy is to
--   force more Huffman coding and less string matching; it is somewhat
--   intermediate between <a>defaultStrategy</a> and
--   <a>huffmanOnlyStrategy</a>.
filteredStrategy :: CompressionStrategy

-- | Use the Huffman-only compression strategy to force Huffman encoding
--   only (no string match).
huffmanOnlyStrategy :: CompressionStrategy

-- | Use <a>rleStrategy</a> to limit match distances to one (run-length
--   encoding). <a>rleStrategy</a> is designed to be almost as fast as
--   <a>huffmanOnlyStrategy</a>, but give better compression for PNG image
--   data.
rleStrategy :: CompressionStrategy

-- | <a>fixedStrategy</a> prevents the use of dynamic Huffman codes,
--   allowing for a simpler decoder for special applications.
fixedStrategy :: CompressionStrategy
instance GHC.Classes.Eq Codec.Compression.Zlib.Internal.CompressParams
instance GHC.Classes.Eq Codec.Compression.Zlib.Internal.DecompressError
instance GHC.Classes.Eq Codec.Compression.Zlib.Internal.DecompressParams
instance GHC.Internal.Exception.Type.Exception Codec.Compression.Zlib.Internal.DecompressError
instance GHC.Internal.Generics.Generic Codec.Compression.Zlib.Internal.CompressParams
instance GHC.Internal.Generics.Generic Codec.Compression.Zlib.Internal.DecompressError
instance GHC.Internal.Generics.Generic Codec.Compression.Zlib.Internal.DecompressParams
instance GHC.Classes.Ord Codec.Compression.Zlib.Internal.CompressParams
instance GHC.Classes.Ord Codec.Compression.Zlib.Internal.DecompressError
instance GHC.Classes.Ord Codec.Compression.Zlib.Internal.DecompressParams
instance GHC.Internal.Show.Show Codec.Compression.Zlib.Internal.CompressParams
instance GHC.Internal.Show.Show Codec.Compression.Zlib.Internal.DecompressError
instance GHC.Internal.Show.Show Codec.Compression.Zlib.Internal.DecompressParams


-- | Compression and decompression of data streams in the raw deflate
--   format.
--   
--   The format is described in detail in RFC #1951:
--   <a>http://www.ietf.org/rfc/rfc1951.txt</a>
--   
--   See also the zlib home page: <a>http://zlib.net/</a>
module Codec.Compression.Zlib.Raw

-- | Compress a stream of data into the raw deflate format.
compress :: ByteString -> ByteString

-- | Decompress a stream of data in the raw deflate format.
decompress :: ByteString -> ByteString

-- | The possible error cases when decompressing a stream.
--   
--   This can be <a>show</a>n to give a human readable error message.
data DecompressError

-- | The compressed data stream ended prematurely. This may happen if the
--   input data stream was truncated.
TruncatedInput :: DecompressError

-- | It is possible to do zlib compression with a custom dictionary. This
--   allows slightly higher compression ratios for short files. However
--   such compressed streams require the same dictionary when
--   decompressing. This error is for when we encounter a compressed stream
--   that needs a dictionary, and it's not provided.
DictionaryRequired :: DecompressError

-- | If the stream requires a dictionary and you provide one with the wrong
--   <a>DictionaryHash</a> then you will get this error.
DictionaryMismatch :: DecompressError

-- | If the compressed data stream is corrupted in any way then you will
--   get this error, for example if the input data just isn't a compressed
--   zlib data stream. In particular if the data checksum turns out to be
--   wrong then you will get all the decompressed data but this error at
--   the end, instead of the normal successful <a>StreamEnd</a>.
DataFormatError :: String -> DecompressError

-- | Like <a>compress</a> but with the ability to specify various
--   decompression parameters.
compressWith :: CompressParams -> ByteString -> ByteString

-- | Like <a>decompress</a> but with the ability to specify various
--   decompression parameters.
decompressWith :: DecompressParams -> ByteString -> ByteString

-- | The full set of parameters for compression. The defaults are
--   <a>defaultCompressParams</a>.
--   
--   The <a>compressBufferSize</a> is the size of the first output buffer
--   containing the compressed data. If you know an approximate upper bound
--   on the size of the compressed data then setting this parameter can
--   save memory. The default compression output buffer size is
--   <tt>16k</tt>. If your estimate is wrong it does not matter too much,
--   the default buffer size will be used for the remaining chunks.
data CompressParams
CompressParams :: !CompressionLevel -> !Method -> !WindowBits -> !MemoryLevel -> !CompressionStrategy -> !Int -> Maybe ByteString -> CompressParams
[compressLevel] :: CompressParams -> !CompressionLevel
[compressMethod] :: CompressParams -> !Method
[compressWindowBits] :: CompressParams -> !WindowBits
[compressMemoryLevel] :: CompressParams -> !MemoryLevel
[compressStrategy] :: CompressParams -> !CompressionStrategy
[compressBufferSize] :: CompressParams -> !Int
[compressDictionary] :: CompressParams -> Maybe ByteString

-- | The default set of parameters for compression. This is typically used
--   with <a>compressWith</a> or <a>compressWith</a> with specific
--   parameters overridden.
defaultCompressParams :: CompressParams

-- | The full set of parameters for decompression. The defaults are
--   <a>defaultDecompressParams</a>.
--   
--   The <a>decompressBufferSize</a> is the size of the first output
--   buffer, containing the uncompressed data. If you know an exact or
--   approximate upper bound on the size of the decompressed data then
--   setting this parameter can save memory. The default decompression
--   output buffer size is <tt>32k</tt>. If your estimate is wrong it does
--   not matter too much, the default buffer size will be used for the
--   remaining chunks.
--   
--   One particular use case for setting the <a>decompressBufferSize</a> is
--   if you know the exact size of the decompressed data and want to
--   produce a strict <a>ByteString</a>. The compression and decompression
--   functions use lazy <a>ByteString</a>s but if you set the
--   <a>decompressBufferSize</a> correctly then you can generate a lazy
--   <a>ByteString</a> with exactly one chunk, which can be converted to a
--   strict <a>ByteString</a> in <tt>O(1)</tt> time using <tt><a>concat</a>
--   . <a>toChunks</a></tt>.
data DecompressParams
DecompressParams :: !WindowBits -> !Int -> Maybe ByteString -> Bool -> DecompressParams
[decompressWindowBits] :: DecompressParams -> !WindowBits
[decompressBufferSize] :: DecompressParams -> !Int
[decompressDictionary] :: DecompressParams -> Maybe ByteString
[decompressAllMembers] :: DecompressParams -> Bool

-- | The default set of parameters for decompression. This is typically
--   used with <a>decompressWith</a> or <a>decompressWith</a> with specific
--   parameters overridden.
defaultDecompressParams :: DecompressParams

-- | The compression level parameter controls the amount of compression.
--   This is a trade-off between the amount of compression and the time
--   required to do the compression.
newtype CompressionLevel
CompressionLevel :: Int -> CompressionLevel

-- | The default <a>CompressionLevel</a>.
defaultCompression :: CompressionLevel

-- | No compression, just a block copy.
noCompression :: CompressionLevel

-- | The fastest compression method (less compression).
bestSpeed :: CompressionLevel

-- | The slowest compression method (best compression).
bestCompression :: CompressionLevel

-- | A specific compression level in the range <tt>0..9</tt>. Throws an
--   error for arguments outside of this range.
--   
--   <ul>
--   <li>0 stands for <a>noCompression</a>,</li>
--   <li>1 stands for <a>bestSpeed</a>,</li>
--   <li>6 stands for <a>defaultCompression</a>,</li>
--   <li>9 stands for <a>bestCompression</a>.</li>
--   </ul>
compressionLevel :: Int -> CompressionLevel

-- | The compression method
data Method

-- | The only method supported in this version of zlib. Indeed it is likely
--   to be the only method that ever will be supported.
deflateMethod :: Method

-- | This specifies the size of the compression window. Larger values of
--   this parameter result in better compression at the expense of higher
--   memory usage.
--   
--   The compression window size is the value of the the window bits raised
--   to the power 2. The window bits must be in the range <tt>9..15</tt>
--   which corresponds to compression window sizes of 512b to 32Kb. The
--   default is 15 which is also the maximum size.
--   
--   The total amount of memory used depends on the window bits and the
--   <a>MemoryLevel</a>. See the <a>MemoryLevel</a> for the details.
newtype WindowBits
WindowBits :: Int -> WindowBits

-- | The default <a>WindowBits</a>. Equivalent to <tt><a>windowBits</a>
--   15</tt>. which is also the maximum size.
defaultWindowBits :: WindowBits

-- | A specific compression window size, specified in bits in the range
--   <tt>9..15</tt>. Throws an error for arguments outside of this range.
windowBits :: Int -> WindowBits

-- | The <a>MemoryLevel</a> parameter specifies how much memory should be
--   allocated for the internal compression state. It is a trade-off
--   between memory usage, compression ratio and compression speed. Using
--   more memory allows faster compression and a better compression ratio.
--   
--   The total amount of memory used for compression depends on the
--   <a>WindowBits</a> and the <a>MemoryLevel</a>. For decompression it
--   depends only on the <a>WindowBits</a>. The totals are given by the
--   functions:
--   
--   <pre>
--   compressTotal windowBits memLevel = 4 * 2^windowBits + 512 * 2^memLevel
--   decompressTotal windowBits = 2^windowBits
--   </pre>
--   
--   For example, for compression with the default <tt>windowBits = 15</tt>
--   and <tt>memLevel = 8</tt> uses <tt>256Kb</tt>. So for example a
--   network server with 100 concurrent compressed streams would use
--   <tt>25Mb</tt>. The memory per stream can be halved (at the cost of
--   somewhat degraded and slower compression) by reducing the
--   <tt>windowBits</tt> and <tt>memLevel</tt> by one.
--   
--   Decompression takes less memory, the default <tt>windowBits = 15</tt>
--   corresponds to just <tt>32Kb</tt>.
newtype MemoryLevel
MemoryLevel :: Int -> MemoryLevel

-- | The default <a>MemoryLevel</a>. Equivalent to <tt><a>memoryLevel</a>
--   8</tt>.
defaultMemoryLevel :: MemoryLevel

-- | Use minimum memory. This is slow and reduces the compression ratio.
--   Equivalent to <tt><a>memoryLevel</a> 1</tt>.
minMemoryLevel :: MemoryLevel

-- | Use maximum memory for optimal compression speed. Equivalent to
--   <tt><a>memoryLevel</a> 9</tt>.
maxMemoryLevel :: MemoryLevel

-- | A specific memory level in the range <tt>1..9</tt>. Throws an error
--   for arguments outside of this range.
memoryLevel :: Int -> MemoryLevel

-- | The strategy parameter is used to tune the compression algorithm.
--   
--   The strategy parameter only affects the compression ratio but not the
--   correctness of the compressed output even if it is not set
--   appropriately.
data CompressionStrategy

-- | Use this default compression strategy for normal data.
defaultStrategy :: CompressionStrategy

-- | Use the filtered compression strategy for data produced by a filter
--   (or predictor). Filtered data consists mostly of small values with a
--   somewhat random distribution. In this case, the compression algorithm
--   is tuned to compress them better. The effect of this strategy is to
--   force more Huffman coding and less string matching; it is somewhat
--   intermediate between <a>defaultStrategy</a> and
--   <a>huffmanOnlyStrategy</a>.
filteredStrategy :: CompressionStrategy

-- | Use the Huffman-only compression strategy to force Huffman encoding
--   only (no string match).
huffmanOnlyStrategy :: CompressionStrategy

-- | Use <a>rleStrategy</a> to limit match distances to one (run-length
--   encoding). <a>rleStrategy</a> is designed to be almost as fast as
--   <a>huffmanOnlyStrategy</a>, but give better compression for PNG image
--   data.
rleStrategy :: CompressionStrategy

-- | <a>fixedStrategy</a> prevents the use of dynamic Huffman codes,
--   allowing for a simpler decoder for special applications.
fixedStrategy :: CompressionStrategy


-- | Compression and decompression of data streams in the zlib format.
--   
--   The format is described in detail in RFC #1950:
--   <a>http://www.ietf.org/rfc/rfc1950.txt</a>
--   
--   See also the zlib home page: <a>http://zlib.net/</a>
module Codec.Compression.Zlib

-- | Compress a stream of data into the zlib format.
--   
--   This uses the default compression parameters. In particular it uses
--   the default compression level which favours a higher compression ratio
--   over compression speed, though it does not use the maximum compression
--   level.
--   
--   Use <a>compressWith</a> to adjust the compression level or other
--   compression parameters.
compress :: ByteString -> ByteString

-- | Decompress a stream of data in the zlib format, throw
--   <a>DecompressError</a> on failure.
--   
--   Note that the decompression is performed <i>lazily</i>. Errors in the
--   data stream may not be detected until the end of the stream is
--   demanded (since it is only at the end that the final checksum can be
--   checked). If this is important to you, you must make sure to consume
--   the whole decompressed stream before doing any IO action that depends
--   on it.
decompress :: ByteString -> ByteString

-- | The possible error cases when decompressing a stream.
--   
--   This can be <a>show</a>n to give a human readable error message.
data DecompressError

-- | The compressed data stream ended prematurely. This may happen if the
--   input data stream was truncated.
TruncatedInput :: DecompressError

-- | It is possible to do zlib compression with a custom dictionary. This
--   allows slightly higher compression ratios for short files. However
--   such compressed streams require the same dictionary when
--   decompressing. This error is for when we encounter a compressed stream
--   that needs a dictionary, and it's not provided.
DictionaryRequired :: DecompressError

-- | If the stream requires a dictionary and you provide one with the wrong
--   <a>DictionaryHash</a> then you will get this error.
DictionaryMismatch :: DecompressError

-- | If the compressed data stream is corrupted in any way then you will
--   get this error, for example if the input data just isn't a compressed
--   zlib data stream. In particular if the data checksum turns out to be
--   wrong then you will get all the decompressed data but this error at
--   the end, instead of the normal successful <a>StreamEnd</a>.
DataFormatError :: String -> DecompressError

-- | Like <a>compress</a> but with the ability to specify various
--   compression parameters. Typical usage:
--   
--   <pre>
--   compressWith defaultCompressParams { ... }
--   </pre>
--   
--   In particular you can set the compression level:
--   
--   <pre>
--   compressWith defaultCompressParams { compressLevel = BestCompression }
--   </pre>
compressWith :: CompressParams -> ByteString -> ByteString

-- | Like <a>decompress</a> but with the ability to specify various
--   decompression parameters. Typical usage:
--   
--   <pre>
--   decompressWith defaultCompressParams { ... }
--   </pre>
decompressWith :: DecompressParams -> ByteString -> ByteString

-- | The full set of parameters for compression. The defaults are
--   <a>defaultCompressParams</a>.
--   
--   The <a>compressBufferSize</a> is the size of the first output buffer
--   containing the compressed data. If you know an approximate upper bound
--   on the size of the compressed data then setting this parameter can
--   save memory. The default compression output buffer size is
--   <tt>16k</tt>. If your estimate is wrong it does not matter too much,
--   the default buffer size will be used for the remaining chunks.
data CompressParams
CompressParams :: !CompressionLevel -> !Method -> !WindowBits -> !MemoryLevel -> !CompressionStrategy -> !Int -> Maybe ByteString -> CompressParams
[compressLevel] :: CompressParams -> !CompressionLevel
[compressMethod] :: CompressParams -> !Method
[compressWindowBits] :: CompressParams -> !WindowBits
[compressMemoryLevel] :: CompressParams -> !MemoryLevel
[compressStrategy] :: CompressParams -> !CompressionStrategy
[compressBufferSize] :: CompressParams -> !Int
[compressDictionary] :: CompressParams -> Maybe ByteString

-- | The default set of parameters for compression. This is typically used
--   with <a>compressWith</a> or <a>compressWith</a> with specific
--   parameters overridden.
defaultCompressParams :: CompressParams

-- | The full set of parameters for decompression. The defaults are
--   <a>defaultDecompressParams</a>.
--   
--   The <a>decompressBufferSize</a> is the size of the first output
--   buffer, containing the uncompressed data. If you know an exact or
--   approximate upper bound on the size of the decompressed data then
--   setting this parameter can save memory. The default decompression
--   output buffer size is <tt>32k</tt>. If your estimate is wrong it does
--   not matter too much, the default buffer size will be used for the
--   remaining chunks.
--   
--   One particular use case for setting the <a>decompressBufferSize</a> is
--   if you know the exact size of the decompressed data and want to
--   produce a strict <a>ByteString</a>. The compression and decompression
--   functions use lazy <a>ByteString</a>s but if you set the
--   <a>decompressBufferSize</a> correctly then you can generate a lazy
--   <a>ByteString</a> with exactly one chunk, which can be converted to a
--   strict <a>ByteString</a> in <tt>O(1)</tt> time using <tt><a>concat</a>
--   . <a>toChunks</a></tt>.
data DecompressParams
DecompressParams :: !WindowBits -> !Int -> Maybe ByteString -> Bool -> DecompressParams
[decompressWindowBits] :: DecompressParams -> !WindowBits
[decompressBufferSize] :: DecompressParams -> !Int
[decompressDictionary] :: DecompressParams -> Maybe ByteString
[decompressAllMembers] :: DecompressParams -> Bool

-- | The default set of parameters for decompression. This is typically
--   used with <a>decompressWith</a> or <a>decompressWith</a> with specific
--   parameters overridden.
defaultDecompressParams :: DecompressParams

-- | The compression level parameter controls the amount of compression.
--   This is a trade-off between the amount of compression and the time
--   required to do the compression.
newtype CompressionLevel
CompressionLevel :: Int -> CompressionLevel

-- | The default <a>CompressionLevel</a>.
defaultCompression :: CompressionLevel

-- | No compression, just a block copy.
noCompression :: CompressionLevel

-- | The fastest compression method (less compression).
bestSpeed :: CompressionLevel

-- | The slowest compression method (best compression).
bestCompression :: CompressionLevel

-- | A specific compression level in the range <tt>0..9</tt>. Throws an
--   error for arguments outside of this range.
--   
--   <ul>
--   <li>0 stands for <a>noCompression</a>,</li>
--   <li>1 stands for <a>bestSpeed</a>,</li>
--   <li>6 stands for <a>defaultCompression</a>,</li>
--   <li>9 stands for <a>bestCompression</a>.</li>
--   </ul>
compressionLevel :: Int -> CompressionLevel

-- | The compression method
data Method

-- | The only method supported in this version of zlib. Indeed it is likely
--   to be the only method that ever will be supported.
deflateMethod :: Method

-- | This specifies the size of the compression window. Larger values of
--   this parameter result in better compression at the expense of higher
--   memory usage.
--   
--   The compression window size is the value of the the window bits raised
--   to the power 2. The window bits must be in the range <tt>9..15</tt>
--   which corresponds to compression window sizes of 512b to 32Kb. The
--   default is 15 which is also the maximum size.
--   
--   The total amount of memory used depends on the window bits and the
--   <a>MemoryLevel</a>. See the <a>MemoryLevel</a> for the details.
newtype WindowBits
WindowBits :: Int -> WindowBits

-- | The default <a>WindowBits</a>. Equivalent to <tt><a>windowBits</a>
--   15</tt>. which is also the maximum size.
defaultWindowBits :: WindowBits

-- | A specific compression window size, specified in bits in the range
--   <tt>9..15</tt>. Throws an error for arguments outside of this range.
windowBits :: Int -> WindowBits

-- | The <a>MemoryLevel</a> parameter specifies how much memory should be
--   allocated for the internal compression state. It is a trade-off
--   between memory usage, compression ratio and compression speed. Using
--   more memory allows faster compression and a better compression ratio.
--   
--   The total amount of memory used for compression depends on the
--   <a>WindowBits</a> and the <a>MemoryLevel</a>. For decompression it
--   depends only on the <a>WindowBits</a>. The totals are given by the
--   functions:
--   
--   <pre>
--   compressTotal windowBits memLevel = 4 * 2^windowBits + 512 * 2^memLevel
--   decompressTotal windowBits = 2^windowBits
--   </pre>
--   
--   For example, for compression with the default <tt>windowBits = 15</tt>
--   and <tt>memLevel = 8</tt> uses <tt>256Kb</tt>. So for example a
--   network server with 100 concurrent compressed streams would use
--   <tt>25Mb</tt>. The memory per stream can be halved (at the cost of
--   somewhat degraded and slower compression) by reducing the
--   <tt>windowBits</tt> and <tt>memLevel</tt> by one.
--   
--   Decompression takes less memory, the default <tt>windowBits = 15</tt>
--   corresponds to just <tt>32Kb</tt>.
newtype MemoryLevel
MemoryLevel :: Int -> MemoryLevel

-- | The default <a>MemoryLevel</a>. Equivalent to <tt><a>memoryLevel</a>
--   8</tt>.
defaultMemoryLevel :: MemoryLevel

-- | Use minimum memory. This is slow and reduces the compression ratio.
--   Equivalent to <tt><a>memoryLevel</a> 1</tt>.
minMemoryLevel :: MemoryLevel

-- | Use maximum memory for optimal compression speed. Equivalent to
--   <tt><a>memoryLevel</a> 9</tt>.
maxMemoryLevel :: MemoryLevel

-- | A specific memory level in the range <tt>1..9</tt>. Throws an error
--   for arguments outside of this range.
memoryLevel :: Int -> MemoryLevel

-- | The strategy parameter is used to tune the compression algorithm.
--   
--   The strategy parameter only affects the compression ratio but not the
--   correctness of the compressed output even if it is not set
--   appropriately.
data CompressionStrategy

-- | Use this default compression strategy for normal data.
defaultStrategy :: CompressionStrategy

-- | Use the filtered compression strategy for data produced by a filter
--   (or predictor). Filtered data consists mostly of small values with a
--   somewhat random distribution. In this case, the compression algorithm
--   is tuned to compress them better. The effect of this strategy is to
--   force more Huffman coding and less string matching; it is somewhat
--   intermediate between <a>defaultStrategy</a> and
--   <a>huffmanOnlyStrategy</a>.
filteredStrategy :: CompressionStrategy

-- | Use the Huffman-only compression strategy to force Huffman encoding
--   only (no string match).
huffmanOnlyStrategy :: CompressionStrategy

-- | Use <a>rleStrategy</a> to limit match distances to one (run-length
--   encoding). <a>rleStrategy</a> is designed to be almost as fast as
--   <a>huffmanOnlyStrategy</a>, but give better compression for PNG image
--   data.
rleStrategy :: CompressionStrategy

-- | <a>fixedStrategy</a> prevents the use of dynamic Huffman codes,
--   allowing for a simpler decoder for special applications.
fixedStrategy :: CompressionStrategy


-- | Compression and decompression of data streams in the gzip format.
--   
--   The format is described in detail in RFC #1952:
--   <a>http://www.ietf.org/rfc/rfc1952.txt</a>
--   
--   See also the zlib home page: <a>http://zlib.net/</a>
module Codec.Compression.GZip

-- | Compress a stream of data into the gzip format.
--   
--   This uses the default compression parameters. In particular it uses
--   the default compression level which favours a higher compression ratio
--   over compression speed, though it does not use the maximum compression
--   level.
--   
--   Use <a>compressWith</a> to adjust the compression level or other
--   compression parameters.
compress :: ByteString -> ByteString

-- | Decompress a stream of data in the gzip format, throw
--   <a>DecompressError</a> on failure.
--   
--   Note that the decompression is performed <i>lazily</i>. Errors in the
--   data stream may not be detected until the end of the stream is
--   demanded (since it is only at the end that the final checksum can be
--   checked). If this is important to you, you must make sure to consume
--   the whole decompressed stream before doing any IO action that depends
--   on it.
decompress :: ByteString -> ByteString

-- | The possible error cases when decompressing a stream.
--   
--   This can be <a>show</a>n to give a human readable error message.
data DecompressError

-- | The compressed data stream ended prematurely. This may happen if the
--   input data stream was truncated.
TruncatedInput :: DecompressError

-- | It is possible to do zlib compression with a custom dictionary. This
--   allows slightly higher compression ratios for short files. However
--   such compressed streams require the same dictionary when
--   decompressing. This error is for when we encounter a compressed stream
--   that needs a dictionary, and it's not provided.
DictionaryRequired :: DecompressError

-- | If the stream requires a dictionary and you provide one with the wrong
--   <a>DictionaryHash</a> then you will get this error.
DictionaryMismatch :: DecompressError

-- | If the compressed data stream is corrupted in any way then you will
--   get this error, for example if the input data just isn't a compressed
--   zlib data stream. In particular if the data checksum turns out to be
--   wrong then you will get all the decompressed data but this error at
--   the end, instead of the normal successful <a>StreamEnd</a>.
DataFormatError :: String -> DecompressError

-- | Like <a>compress</a> but with the ability to specify various
--   compression parameters. Typical usage:
--   
--   <pre>
--   compressWith defaultCompressParams { ... }
--   </pre>
--   
--   In particular you can set the compression level:
--   
--   <pre>
--   compressWith defaultCompressParams { compressLevel = BestCompression }
--   </pre>
compressWith :: CompressParams -> ByteString -> ByteString

-- | Like <a>decompress</a> but with the ability to specify various
--   decompression parameters. Typical usage:
--   
--   <pre>
--   decompressWith defaultCompressParams { ... }
--   </pre>
decompressWith :: DecompressParams -> ByteString -> ByteString

-- | The full set of parameters for compression. The defaults are
--   <a>defaultCompressParams</a>.
--   
--   The <a>compressBufferSize</a> is the size of the first output buffer
--   containing the compressed data. If you know an approximate upper bound
--   on the size of the compressed data then setting this parameter can
--   save memory. The default compression output buffer size is
--   <tt>16k</tt>. If your estimate is wrong it does not matter too much,
--   the default buffer size will be used for the remaining chunks.
data CompressParams
CompressParams :: !CompressionLevel -> !Method -> !WindowBits -> !MemoryLevel -> !CompressionStrategy -> !Int -> Maybe ByteString -> CompressParams
[compressLevel] :: CompressParams -> !CompressionLevel
[compressMethod] :: CompressParams -> !Method
[compressWindowBits] :: CompressParams -> !WindowBits
[compressMemoryLevel] :: CompressParams -> !MemoryLevel
[compressStrategy] :: CompressParams -> !CompressionStrategy
[compressBufferSize] :: CompressParams -> !Int
[compressDictionary] :: CompressParams -> Maybe ByteString

-- | The default set of parameters for compression. This is typically used
--   with <a>compressWith</a> or <a>compressWith</a> with specific
--   parameters overridden.
defaultCompressParams :: CompressParams

-- | The full set of parameters for decompression. The defaults are
--   <a>defaultDecompressParams</a>.
--   
--   The <a>decompressBufferSize</a> is the size of the first output
--   buffer, containing the uncompressed data. If you know an exact or
--   approximate upper bound on the size of the decompressed data then
--   setting this parameter can save memory. The default decompression
--   output buffer size is <tt>32k</tt>. If your estimate is wrong it does
--   not matter too much, the default buffer size will be used for the
--   remaining chunks.
--   
--   One particular use case for setting the <a>decompressBufferSize</a> is
--   if you know the exact size of the decompressed data and want to
--   produce a strict <a>ByteString</a>. The compression and decompression
--   functions use lazy <a>ByteString</a>s but if you set the
--   <a>decompressBufferSize</a> correctly then you can generate a lazy
--   <a>ByteString</a> with exactly one chunk, which can be converted to a
--   strict <a>ByteString</a> in <tt>O(1)</tt> time using <tt><a>concat</a>
--   . <a>toChunks</a></tt>.
data DecompressParams
DecompressParams :: !WindowBits -> !Int -> Maybe ByteString -> Bool -> DecompressParams
[decompressWindowBits] :: DecompressParams -> !WindowBits
[decompressBufferSize] :: DecompressParams -> !Int
[decompressDictionary] :: DecompressParams -> Maybe ByteString
[decompressAllMembers] :: DecompressParams -> Bool

-- | The default set of parameters for decompression. This is typically
--   used with <a>decompressWith</a> or <a>decompressWith</a> with specific
--   parameters overridden.
defaultDecompressParams :: DecompressParams

-- | The compression level parameter controls the amount of compression.
--   This is a trade-off between the amount of compression and the time
--   required to do the compression.
newtype CompressionLevel
CompressionLevel :: Int -> CompressionLevel

-- | The default <a>CompressionLevel</a>.
defaultCompression :: CompressionLevel

-- | No compression, just a block copy.
noCompression :: CompressionLevel

-- | The fastest compression method (less compression).
bestSpeed :: CompressionLevel

-- | The slowest compression method (best compression).
bestCompression :: CompressionLevel

-- | A specific compression level in the range <tt>0..9</tt>. Throws an
--   error for arguments outside of this range.
--   
--   <ul>
--   <li>0 stands for <a>noCompression</a>,</li>
--   <li>1 stands for <a>bestSpeed</a>,</li>
--   <li>6 stands for <a>defaultCompression</a>,</li>
--   <li>9 stands for <a>bestCompression</a>.</li>
--   </ul>
compressionLevel :: Int -> CompressionLevel

-- | The compression method
data Method

-- | The only method supported in this version of zlib. Indeed it is likely
--   to be the only method that ever will be supported.
deflateMethod :: Method

-- | This specifies the size of the compression window. Larger values of
--   this parameter result in better compression at the expense of higher
--   memory usage.
--   
--   The compression window size is the value of the the window bits raised
--   to the power 2. The window bits must be in the range <tt>9..15</tt>
--   which corresponds to compression window sizes of 512b to 32Kb. The
--   default is 15 which is also the maximum size.
--   
--   The total amount of memory used depends on the window bits and the
--   <a>MemoryLevel</a>. See the <a>MemoryLevel</a> for the details.
newtype WindowBits
WindowBits :: Int -> WindowBits

-- | The default <a>WindowBits</a>. Equivalent to <tt><a>windowBits</a>
--   15</tt>. which is also the maximum size.
defaultWindowBits :: WindowBits

-- | A specific compression window size, specified in bits in the range
--   <tt>9..15</tt>. Throws an error for arguments outside of this range.
windowBits :: Int -> WindowBits

-- | The <a>MemoryLevel</a> parameter specifies how much memory should be
--   allocated for the internal compression state. It is a trade-off
--   between memory usage, compression ratio and compression speed. Using
--   more memory allows faster compression and a better compression ratio.
--   
--   The total amount of memory used for compression depends on the
--   <a>WindowBits</a> and the <a>MemoryLevel</a>. For decompression it
--   depends only on the <a>WindowBits</a>. The totals are given by the
--   functions:
--   
--   <pre>
--   compressTotal windowBits memLevel = 4 * 2^windowBits + 512 * 2^memLevel
--   decompressTotal windowBits = 2^windowBits
--   </pre>
--   
--   For example, for compression with the default <tt>windowBits = 15</tt>
--   and <tt>memLevel = 8</tt> uses <tt>256Kb</tt>. So for example a
--   network server with 100 concurrent compressed streams would use
--   <tt>25Mb</tt>. The memory per stream can be halved (at the cost of
--   somewhat degraded and slower compression) by reducing the
--   <tt>windowBits</tt> and <tt>memLevel</tt> by one.
--   
--   Decompression takes less memory, the default <tt>windowBits = 15</tt>
--   corresponds to just <tt>32Kb</tt>.
newtype MemoryLevel
MemoryLevel :: Int -> MemoryLevel

-- | The default <a>MemoryLevel</a>. Equivalent to <tt><a>memoryLevel</a>
--   8</tt>.
defaultMemoryLevel :: MemoryLevel

-- | Use minimum memory. This is slow and reduces the compression ratio.
--   Equivalent to <tt><a>memoryLevel</a> 1</tt>.
minMemoryLevel :: MemoryLevel

-- | Use maximum memory for optimal compression speed. Equivalent to
--   <tt><a>memoryLevel</a> 9</tt>.
maxMemoryLevel :: MemoryLevel

-- | A specific memory level in the range <tt>1..9</tt>. Throws an error
--   for arguments outside of this range.
memoryLevel :: Int -> MemoryLevel

-- | The strategy parameter is used to tune the compression algorithm.
--   
--   The strategy parameter only affects the compression ratio but not the
--   correctness of the compressed output even if it is not set
--   appropriately.
data CompressionStrategy

-- | Use this default compression strategy for normal data.
defaultStrategy :: CompressionStrategy

-- | Use the filtered compression strategy for data produced by a filter
--   (or predictor). Filtered data consists mostly of small values with a
--   somewhat random distribution. In this case, the compression algorithm
--   is tuned to compress them better. The effect of this strategy is to
--   force more Huffman coding and less string matching; it is somewhat
--   intermediate between <a>defaultStrategy</a> and
--   <a>huffmanOnlyStrategy</a>.
filteredStrategy :: CompressionStrategy

-- | Use the Huffman-only compression strategy to force Huffman encoding
--   only (no string match).
huffmanOnlyStrategy :: CompressionStrategy

-- | Use <a>rleStrategy</a> to limit match distances to one (run-length
--   encoding). <a>rleStrategy</a> is designed to be almost as fast as
--   <a>huffmanOnlyStrategy</a>, but give better compression for PNG image
--   data.
rleStrategy :: CompressionStrategy

-- | <a>fixedStrategy</a> prevents the use of dynamic Huffman codes,
--   allowing for a simpler decoder for special applications.
fixedStrategy :: CompressionStrategy
