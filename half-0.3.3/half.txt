-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Half-precision floating-point
--   
--   Half-precision floating-point.
@package half
@version 0.3.3


-- | Half-precision floating-point values. These arise commonly in GPU work
--   and it is useful to be able to compute them and compute with them on
--   the CPU as well.
module Numeric.Half.Internal

-- | A half-precision floating point value
newtype Half
Half :: CUShort -> Half
[getHalf] :: Half -> CUShort

-- | Is this <a>Half</a> equal to 0?
isZero :: Half -> Bool

-- | Convert a <a>Half</a> to a <a>Float</a> while preserving NaN
fromHalf :: Half -> Float

-- | Convert a <a>Float</a> to a <a>Half</a> with proper rounding, while
--   preserving NaN and dealing appropriately with infinity
toHalf :: Float -> Half

-- | Positive infinity
pattern POS_INF :: Half

-- | Negative infinity
pattern NEG_INF :: Half

-- | Quiet NaN
pattern QNaN :: Half

-- | Signalling NaN
pattern SNaN :: Half

-- | Smallest positive half
pattern HALF_MIN :: Half

-- | Smallest positive normalized half
pattern HALF_NRM_MIN :: Half

-- | Largest positive half
pattern HALF_MAX :: Half

-- | Smallest positive e for which half (1.0 + e) != half (1.0)
pattern HALF_EPSILON :: Half

-- | Number of base 10 digits that can be represented without change
pattern HALF_DIG :: (Eq a, Num a) => a

-- | Minimum positive integer such that 10 raised to that power is a
--   normalized half
pattern HALF_MIN_10_EXP :: (Eq a, Num a) => a

-- | Maximum positive integer such that 10 raised to that power is a
--   normalized half
pattern HALF_MAX_10_EXP :: (Eq a, Num a) => a

-- | Naive pure-Haskell implementation of <a>toHalf</a>.
pure_floatToHalf :: Float -> Half

-- | Naive pure-Haskell implementation of <a>fromHalf</a>.
pure_halfToFloat :: Half -> Float
instance Data.Binary.Class.Binary Numeric.Half.Internal.Half
instance GHC.Classes.Eq Numeric.Half.Internal.Half
instance GHC.Internal.Float.Floating Numeric.Half.Internal.Half
instance GHC.Internal.Real.Fractional Numeric.Half.Internal.Half
instance GHC.Internal.Generics.Generic Numeric.Half.Internal.Half
instance Language.Haskell.TH.Syntax.Lift Numeric.Half.Internal.Half
instance Control.DeepSeq.NFData Numeric.Half.Internal.Half
instance GHC.Internal.Num.Num Numeric.Half.Internal.Half
instance GHC.Classes.Ord Numeric.Half.Internal.Half
instance GHC.Internal.Read.Read Numeric.Half.Internal.Half
instance GHC.Internal.Float.RealFloat Numeric.Half.Internal.Half
instance GHC.Internal.Real.RealFrac Numeric.Half.Internal.Half
instance GHC.Internal.Real.Real Numeric.Half.Internal.Half
instance GHC.Internal.Show.Show Numeric.Half.Internal.Half
instance GHC.Internal.Foreign.Storable.Storable Numeric.Half.Internal.Half


-- | Half-precision floating-point values. These arise commonly in GPU work
--   and it is useful to be able to compute them and compute with them on
--   the CPU as well.
module Numeric.Half

-- | A half-precision floating point value
newtype Half
Half :: CUShort -> Half
[getHalf] :: Half -> CUShort

-- | Is this <a>Half</a> equal to 0?
isZero :: Half -> Bool

-- | Convert a <a>Half</a> to a <a>Float</a> while preserving NaN
fromHalf :: Half -> Float

-- | Convert a <a>Float</a> to a <a>Half</a> with proper rounding, while
--   preserving NaN and dealing appropriately with infinity
toHalf :: Float -> Half

-- | Positive infinity
pattern POS_INF :: Half

-- | Negative infinity
pattern NEG_INF :: Half

-- | Quiet NaN
pattern QNaN :: Half

-- | Signalling NaN
pattern SNaN :: Half

-- | Smallest positive half
pattern HALF_MIN :: Half

-- | Smallest positive normalized half
pattern HALF_NRM_MIN :: Half

-- | Largest positive half
pattern HALF_MAX :: Half

-- | Smallest positive e for which half (1.0 + e) != half (1.0)
pattern HALF_EPSILON :: Half

-- | Number of base 10 digits that can be represented without change
pattern HALF_DIG :: (Eq a, Num a) => a

-- | Minimum positive integer such that 10 raised to that power is a
--   normalized half
pattern HALF_MIN_10_EXP :: (Eq a, Num a) => a

-- | Maximum positive integer such that 10 raised to that power is a
--   normalized half
pattern HALF_MAX_10_EXP :: (Eq a, Num a) => a
