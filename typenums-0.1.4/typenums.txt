-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Type level numbers using existing Nat functionality
--   
--   Type level numbers using existing Nat functionality. Uses
--   kind-polymorphic typeclasses and type families to facilitate more
--   general code compatible with existing code using type-level Naturals.
@package typenums
@version 0.1.4


-- | Type level integers can be used in the same way as type level naturals
--   from <a>GHC.TypeLits</a>, for example <tt>3</tt>. However, a minus
--   sign is not recognised in this context, so a negative type-level
--   integer is instead written as <tt><a>Neg</a> n</tt>.
module Data.TypeNums.Ints

-- | (Kind) An integer that may be negative.
data TInt
Pos :: Nat -> TInt
Neg :: Nat -> TInt

-- | This class gives the (value-level) integer associated with a
--   type-level integer. There are instances of this class for every
--   concrete natural: 0, 1, 2, etc. There are also instances of this class
--   for every negated natural, such as <tt><a>Neg</a> 1</tt>.
class KnownInt (n :: k)

-- | Get the value associated with a type-level integer
intVal :: forall {k} (n :: k) proxy. KnownInt n => proxy n -> Integer

-- | Get the value associated with a type-level integer. The difference
--   between this function and <a>intVal</a> is that it takes a
--   <a>Proxy#</a> parameter, which has zero runtime representation and so
--   is entirely free.
intVal' :: forall {k} (n :: k). KnownInt n => Proxy# n -> Integer

-- | This type represents unknown type-level integers.
data SomeInt
SomeInt :: Proxy n -> SomeInt

-- | Convert an integer into an unknown type-level integer.
someIntVal :: Integer -> SomeInt
instance GHC.Classes.Eq Data.TypeNums.Ints.SomeInt
instance GHC.Internal.TypeNats.KnownNat n => Data.TypeNums.Ints.KnownInt n
instance GHC.Internal.TypeNats.KnownNat n => Data.TypeNums.Ints.KnownInt ('Data.TypeNums.Ints.Neg n)
instance GHC.Internal.TypeNats.KnownNat n => Data.TypeNums.Ints.KnownInt ('Data.TypeNums.Ints.Pos n)
instance GHC.Classes.Ord Data.TypeNums.Ints.SomeInt
instance GHC.Internal.Read.Read Data.TypeNums.Ints.SomeInt
instance GHC.Internal.Show.Show Data.TypeNums.Ints.SomeInt


-- | This module exposes the inner workings of type-level arithmetic for
--   further extensions.
module Data.TypeNums.Arithmetic.Internal

-- | The kind of the result of addition.
type family AddK k1 k2

-- | The kind of the result of subtraction.
type family SubK k1 k2

-- | The kind of the result of multiplication.
type family MulK k1 k2

-- | The kind of the result of division by a natural number
type family IntDivK k

-- | The kind of the result of type-level exponentiation
type family ExpK k1 k2

-- | The kind of the result of negation
type family NegK k

-- | The absolute value of a type-level number
type family Abs (x :: k) :: k

-- | The result of negating a <a>TInt</a>
type family Negate (x :: k) :: NegK k

-- | The reciprocal of a type-level number
type family Recip (x :: k) :: Rat

-- | Reduce a type-level rational into its canonical form
type family Simplify (x :: Rat) :: Rat

-- | Round a type-level number towards zero
type family Truncate (x :: k) :: TInt

-- | Round a type-level number towards negative infinity
type family Floor (x :: k) :: TInt

-- | Round a type-level number towards positive infinity
type family Ceiling (x :: k) :: TInt

-- | The sum of two type-level numbers.
type family Add (x :: k1) (y :: k2) :: AddK k1 k2

-- | The difference of two type-level numbers
--   
--   For the difference of two naturals <tt>a</tt> and <tt>b</tt>,
--   <tt>a-b</tt> is also a natural, so only exists for <tt>a</tt> &gt;=
--   <tt>b</tt>. @since 0.1.2
type family Sub (x :: k1) (y :: k2) :: SubK k1 k2

-- | The product of two type-level numbers
type family Mul (x :: k1) (y :: k2) :: MulK k1 k2

-- | The result of dividing two type-level numbers.
type family RatDiv (x :: k1) (y :: k2) :: Rat

-- | The quotient and remainder of a type-level integer and a natural
--   number. For a negative dividend, the remainder part is positive such
--   that x = q*y + r @since 0.1.4
type family DivMod (x :: k) (y :: Nat) :: (IntDivK k, IntDivK k)

-- | The quotient and remainder of a type-level integer and a natural
--   number. For a negative dividend, the remainder part is negative such
--   that x = q*y + r @since 0.1.4
type family QuotRem (x :: k) (y :: Nat) :: (IntDivK k, IntDivK k)

-- | The quotient of a type-level integer and a natural number.
type family Div (x :: k) (y :: Nat) :: IntDivK k
infixl 7 `Div`

-- | The remainder of a type-level integer and a natural number For a
--   negative number, behaves similarly to <a>mod</a>. @since 0.1.4
type family Mod (x :: k) (y :: Nat) :: IntDivK k
infixl 7 `Mod`

-- | The integer part of the result of dividing an integer by a natural
--   number
type family Quot (x :: k) (y :: Nat) :: IntDivK k
infixl 7 `Quot`

-- | The remainder of the result of dividing an integer by a natural number
type family Rem (x :: k) (y :: Nat) :: IntDivK k
infixl 7 `Rem`

-- | The greatest common divisor of two type-level integers
type family GCD (x :: k1) (y :: k2) :: Nat

-- | The least common multiple of two type-level integers
type family LCM (x :: k1) (y :: k2) :: Nat

-- | Exponentiation of a type-level number by an integer
type family Exp (x :: k1) (y :: k2) :: ExpK k1 k2

-- | The floor of the logarithm of a type-level number NB. unlike
--   <a>Log2</a>, <tt>Log n 0</tt> here is a type error.
type family IntLog (n :: Nat) (x :: k) :: TInt


-- | Type level rational numbers expressed as a ratio between a type-level
--   integer and a type-level natural. For example <tt><a>Neg</a> 3 :%
--   2</tt>.
--   
--   See also: <a>Data.TypeInts</a>
module Data.TypeNums.Rats

-- | Type constructor for a rational
data Rat
(:%) :: k -> Nat -> Rat

-- | This class gives the (value-level) rational associated with a
--   type-level rational. There are instances of this class for every
--   combination of a concrete integer and concrete natural.
class KnownRat (r :: k)

-- | Get the value associated with a type-level rational
ratVal :: forall {k} proxy (r :: k). KnownRat r => proxy r -> Rational

-- | Get the value associated with a type-level rational. The difference
--   between this function and <a>ratVal</a> is that it takes a
--   <a>Proxy#</a> parameter, which has zero runtime representation and so
--   is entirely free.
ratVal' :: forall {k} (r :: k). KnownRat r => Proxy# r -> Rational

-- | This type represents unknown type-level integers.
data SomeRat
SomeRat :: Proxy r -> SomeRat

-- | Convert a rational into an unknown type-level rational.
someRatVal :: Rational -> SomeRat
instance GHC.Classes.Eq Data.TypeNums.Rats.SomeRat
instance forall k (n :: k). (TypeError ...) => Data.TypeNums.Rats.KnownRat (n 'Data.TypeNums.Rats.Type.:% 0)
instance forall k (n :: k) (d :: GHC.Internal.TypeNats.Nat). (Data.TypeNums.Ints.KnownInt n, GHC.Internal.TypeNats.KnownNat d, d Data.TypeNums.Equality./= 0) => Data.TypeNums.Rats.KnownRat (n 'Data.TypeNums.Rats.Type.:% d)
instance forall k (n :: k). Data.TypeNums.Ints.KnownInt n => Data.TypeNums.Rats.KnownRat n
instance GHC.Classes.Ord Data.TypeNums.Rats.SomeRat
instance GHC.Internal.Read.Read Data.TypeNums.Rats.SomeRat
instance GHC.Internal.Show.Show Data.TypeNums.Rats.SomeRat


-- | This module provides a unified interface for natural numbers, signed
--   integers, and rationals at the type level, in a way fully compatible
--   with existing code using type-level naturals.
--   
--   Natural numbers are expressed as always, e.g. <tt>5</tt>. Negative
--   integers are written as <tt>Neg 3</tt>. Ratios are written as <tt>3 :%
--   2</tt>.
--   
--   There are some naming conflicts between this module and
--   <a>GHC.TypeLits</a>, notably the comparison and arithmetic operators.
--   This module reexports <tt>Nat</tt>, <tt>KnownNat</tt>, <tt>natVal</tt>
--   and <tt>natVal'</tt> so you may import just this module and not
--   <a>GHC.TypeLits</a>.
--   
--   If you wish to use other functionality from <a>GHC.TypeLits</a>, this
--   package also provides the module <a>Data.TypeLits</a> that includes
--   (almost) full functionality from <a>GHC.TypeLits</a>, but with the
--   conflicts resolving in this packages favour.
module Data.TypeNums

-- | A type synonym for <a>Natural</a>.
--   
--   Previously, this was an opaque data type, but it was changed to a type
--   synonym.
type Nat = Natural

-- | This class gives the integer associated with a type-level natural.
--   There are instances of the class for every concrete literal: 0, 1, 2,
--   etc.
class KnownNat (n :: Nat)

natVal :: forall (n :: Nat) proxy. KnownNat n => proxy n -> Integer

natVal' :: forall (n :: Nat). KnownNat n => Proxy# n -> Integer

-- | This type represents unknown type-level natural numbers.
data SomeNat
SomeNat :: Proxy n -> SomeNat

-- | Convert an integer into an unknown type-level natural.
someNatVal :: Integer -> Maybe SomeNat

-- | (Kind) An integer that may be negative.
data TInt
Pos :: Nat -> TInt
Neg :: Nat -> TInt

-- | This class gives the (value-level) integer associated with a
--   type-level integer. There are instances of this class for every
--   concrete natural: 0, 1, 2, etc. There are also instances of this class
--   for every negated natural, such as <tt><a>Neg</a> 1</tt>.
class KnownInt (n :: k)

-- | Get the value associated with a type-level integer
intVal :: forall {k} (n :: k) proxy. KnownInt n => proxy n -> Integer

-- | Get the value associated with a type-level integer. The difference
--   between this function and <a>intVal</a> is that it takes a
--   <a>Proxy#</a> parameter, which has zero runtime representation and so
--   is entirely free.
intVal' :: forall {k} (n :: k). KnownInt n => Proxy# n -> Integer

-- | This type represents unknown type-level integers.
data SomeInt
SomeInt :: Proxy n -> SomeInt

-- | Convert an integer into an unknown type-level integer.
someIntVal :: Integer -> SomeInt

-- | Type constructor for a rational
data Rat
(:%) :: k -> Nat -> Rat

-- | This class gives the (value-level) rational associated with a
--   type-level rational. There are instances of this class for every
--   combination of a concrete integer and concrete natural.
class KnownRat (r :: k)

-- | Get the value associated with a type-level rational
ratVal :: forall {k} proxy (r :: k). KnownRat r => proxy r -> Rational

-- | Get the value associated with a type-level rational. The difference
--   between this function and <a>ratVal</a> is that it takes a
--   <a>Proxy#</a> parameter, which has zero runtime representation and so
--   is entirely free.
ratVal' :: forall {k} (r :: k). KnownRat r => Proxy# r -> Rational

-- | This type represents unknown type-level integers.
data SomeRat
SomeRat :: Proxy r -> SomeRat

-- | Convert a rational into an unknown type-level rational.
someRatVal :: Rational -> SomeRat

-- | Reduce a type-level rational into its canonical form
type family Simplify (x :: Rat) :: Rat

-- | Boolean type-level equals. Useful for e.g. <tt><a>If</a> (x ==?
--   0)</tt>
type family (a :: k1) ==? (b :: k2) :: Bool
infix 4 ==?

-- | Boolean type-level not-equals.
type (a :: k1) /=? (b :: k2) = Not a ==? b
infix 4 /=?

-- | Equality constraint, used as e.g. <tt>(x == 3) =&gt; _</tt>
type (a :: k1) == (b :: k2) = a ==? b ~ 'True
infix 4 ==

-- | Not-equal constraint
type (a :: k1) /= (b :: k2) = a ==? b ~ 'False
infix 4 /=

-- | Boolean comparison of two type-level numbers
type family (a :: k1) <=? (b :: k2) :: Bool
infix 4 <=?
type (a :: k1) <= (b :: k2) = a <=? b ~ 'True
infix 4 <=
type (a :: k1) < (b :: k2) = b <=? a ~ 'False
infix 4 <
type (a :: k1) >= (b :: k2) = b <=? a ~ 'True
infix 4 >=
type (a :: k1) > (b :: k2) = a <=? b ~ 'False
infix 4 >

-- | The absolute value of a type-level number
type family Abs (x :: k) :: k

-- | The result of negating a <a>TInt</a>
type family Negate (x :: k) :: NegK k

-- | The reciprocal of a type-level number
type family Recip (x :: k) :: Rat

-- | Round a type-level number towards negative infinity
type family Floor (x :: k) :: TInt

-- | Round a type-level number towards positive infinity
type family Ceiling (x :: k) :: TInt

-- | Round a type-level number towards zero
type family Truncate (x :: k) :: TInt

-- | The sum of two type-level numbers
type (a :: k1) + (b :: k2) = Add a b
infixl 6 +

-- | The difference of two type-level numbers
--   
--   For the difference of two naturals <tt>a</tt> and <tt>b</tt>,
--   <tt>a-b</tt> is also a natural, so only exists for <tt>a</tt> &gt;=
--   <tt>b</tt>.
type (a :: k1) - (b :: k2) = Sub a b
infixl 6 -

-- | The product of two type-level numbers.
--   
--   Due to changes in GHC 8.6, using this operator infix and unqualified
--   requires the NoStarIsType language extension to be active. See the GHC
--   8.6.x migration guide for details:
--   <a>https://ghc.haskell.org/trac/ghc/wiki/Migration/8.6</a>
type (a :: k1) * (b :: k2) = Mul a b
infixl 7 *

-- | The ratio of two type-level numbers
type (a :: k1) / (b :: k2) = RatDiv a b
infixl 7 /

-- | A type-level number raised to an integer power. For <tt>Nat</tt>
--   powers, the result kind is the same as the base. For <tt>TInt</tt>
--   powers, the result kind is <tt>Rat</tt>.
type (a :: k1) ^ (b :: k2) = Exp a b
infixr 8 ^

-- | The quotient and remainder of a type-level integer and a natural
--   number. For a negative dividend, the remainder part is positive such
--   that x = q*y + r @since 0.1.4
type family DivMod (x :: k) (y :: Nat) :: (IntDivK k, IntDivK k)

-- | The quotient and remainder of a type-level integer and a natural
--   number. For a negative dividend, the remainder part is negative such
--   that x = q*y + r @since 0.1.4
type family QuotRem (x :: k) (y :: Nat) :: (IntDivK k, IntDivK k)

-- | The quotient of a type-level integer and a natural number.
type family Div (x :: k) (y :: Nat) :: IntDivK k
infixl 7 `Div`

-- | The remainder of a type-level integer and a natural number For a
--   negative number, behaves similarly to <a>mod</a>. @since 0.1.4
type family Mod (x :: k) (y :: Nat) :: IntDivK k
infixl 7 `Mod`

-- | The integer part of the result of dividing an integer by a natural
--   number
type family Quot (x :: k) (y :: Nat) :: IntDivK k
infixl 7 `Quot`

-- | The remainder of the result of dividing an integer by a natural number
type family Rem (x :: k) (y :: Nat) :: IntDivK k
infixl 7 `Rem`

-- | The greatest common divisor of two type-level integers
type family GCD (x :: k1) (y :: k2) :: Nat

-- | The floor of the logarithm of a type-level number NB. unlike
--   <a>Log2</a>, <tt>Log n 0</tt> here is a type error.
type family IntLog (n :: Nat) (x :: k) :: TInt

-- | The floor of the logarithm base 2 of a type-level number. Note that
--   unlike <a>Log2</a>, this errors on <tt>Log2 0</tt>.
type Log2 (x :: k) = IntLog 2 x


-- | This module provides the same interface as <a>GHC.TypeLits</a>, but
--   with naming conflicts resolved in favour of this package. For example,
--   <a>(&lt;=)</a> resolves to the kind-polymorphic version from
--   <a>Data.TypeNums</a>.
--   
--   If you are only working with type-level numbers, import
--   <a>Data.TypeNums</a> instead. This module is purely for convenience
--   for those who want to use both functionality from <a>GHC.TypeLits</a>
--   and functionality from <a>Data.TypeNums</a>.
module Data.TypeLits

-- | A type synonym for <a>Natural</a>.
--   
--   Previously, this was an opaque data type, but it was changed to a type
--   synonym.
type Nat = Natural

-- | This class gives the integer associated with a type-level natural.
--   There are instances of the class for every concrete literal: 0, 1, 2,
--   etc.
class KnownNat (n :: Nat)

natVal :: forall (n :: Nat) proxy. KnownNat n => proxy n -> Integer

natVal' :: forall (n :: Nat). KnownNat n => Proxy# n -> Integer

-- | This type represents unknown type-level natural numbers.
data SomeNat
SomeNat :: Proxy n -> SomeNat

-- | Convert an integer into an unknown type-level natural.
someNatVal :: Integer -> Maybe SomeNat

-- | We either get evidence that this function was instantiated with the
--   same type-level numbers, or <a>Nothing</a>.
sameNat :: forall (a :: Nat) (b :: Nat) proxy1 proxy2. (KnownNat a, KnownNat b) => proxy1 a -> proxy2 b -> Maybe (a :~: b)

-- | (Kind) An integer that may be negative.
data TInt
Pos :: Nat -> TInt
Neg :: Nat -> TInt

-- | This class gives the (value-level) integer associated with a
--   type-level integer. There are instances of this class for every
--   concrete natural: 0, 1, 2, etc. There are also instances of this class
--   for every negated natural, such as <tt><a>Neg</a> 1</tt>.
class KnownInt (n :: k)

-- | Get the value associated with a type-level integer
intVal :: forall {k} (n :: k) proxy. KnownInt n => proxy n -> Integer

-- | Get the value associated with a type-level integer. The difference
--   between this function and <a>intVal</a> is that it takes a
--   <a>Proxy#</a> parameter, which has zero runtime representation and so
--   is entirely free.
intVal' :: forall {k} (n :: k). KnownInt n => Proxy# n -> Integer

-- | This type represents unknown type-level integers.
data SomeInt
SomeInt :: Proxy n -> SomeInt

-- | Convert an integer into an unknown type-level integer.
someIntVal :: Integer -> SomeInt

-- | Type constructor for a rational
data Rat
(:%) :: k -> Nat -> Rat

-- | This class gives the (value-level) rational associated with a
--   type-level rational. There are instances of this class for every
--   combination of a concrete integer and concrete natural.
class KnownRat (r :: k)

-- | Get the value associated with a type-level rational
ratVal :: forall {k} proxy (r :: k). KnownRat r => proxy r -> Rational

-- | Get the value associated with a type-level rational. The difference
--   between this function and <a>ratVal</a> is that it takes a
--   <a>Proxy#</a> parameter, which has zero runtime representation and so
--   is entirely free.
ratVal' :: forall {k} (r :: k). KnownRat r => Proxy# r -> Rational

-- | This type represents unknown type-level integers.
data SomeRat
SomeRat :: Proxy r -> SomeRat

-- | Convert a rational into an unknown type-level rational.
someRatVal :: Rational -> SomeRat

-- | Reduce a type-level rational into its canonical form
type family Simplify (x :: Rat) :: Rat

-- | Boolean type-level equals. Useful for e.g. <tt><a>If</a> (x ==?
--   0)</tt>
type family (a :: k1) ==? (b :: k2) :: Bool
infix 4 ==?

-- | Boolean type-level not-equals.
type (a :: k1) /=? (b :: k2) = Not a ==? b
infix 4 /=?

-- | Boolean comparison of two type-level numbers
type family (a :: k1) <=? (b :: k2) :: Bool
infix 4 <=?

-- | Equality constraint, used as e.g. <tt>(x == 3) =&gt; _</tt>
type (a :: k1) == (b :: k2) = a ==? b ~ 'True
infix 4 ==

-- | Not-equal constraint
type (a :: k1) /= (b :: k2) = a ==? b ~ 'False
infix 4 /=
type (a :: k1) <= (b :: k2) = a <=? b ~ 'True
infix 4 <=
type (a :: k1) < (b :: k2) = b <=? a ~ 'False
infix 4 <
type (a :: k1) >= (b :: k2) = b <=? a ~ 'True
infix 4 >=
type (a :: k1) > (b :: k2) = a <=? b ~ 'False
infix 4 >

-- | The absolute value of a type-level number
type family Abs (x :: k) :: k

-- | The result of negating a <a>TInt</a>
type family Negate (x :: k) :: NegK k

-- | The reciprocal of a type-level number
type family Recip (x :: k) :: Rat

-- | Round a type-level number towards negative infinity
type family Floor (x :: k) :: TInt

-- | Round a type-level number towards positive infinity
type family Ceiling (x :: k) :: TInt

-- | Round a type-level number towards zero
type family Truncate (x :: k) :: TInt

-- | The sum of two type-level numbers
type (a :: k1) + (b :: k2) = Add a b
infixl 6 +

-- | The difference of two type-level numbers
--   
--   For the difference of two naturals <tt>a</tt> and <tt>b</tt>,
--   <tt>a-b</tt> is also a natural, so only exists for <tt>a</tt> &gt;=
--   <tt>b</tt>.
type (a :: k1) - (b :: k2) = Sub a b
infixl 6 -

-- | The product of two type-level numbers.
--   
--   Due to changes in GHC 8.6, using this operator infix and unqualified
--   requires the NoStarIsType language extension to be active. See the GHC
--   8.6.x migration guide for details:
--   <a>https://ghc.haskell.org/trac/ghc/wiki/Migration/8.6</a>
type (a :: k1) * (b :: k2) = Mul a b
infixl 7 *

-- | The ratio of two type-level numbers
type (a :: k1) / (b :: k2) = RatDiv a b
infixl 7 /

-- | A type-level number raised to an integer power. For <tt>Nat</tt>
--   powers, the result kind is the same as the base. For <tt>TInt</tt>
--   powers, the result kind is <tt>Rat</tt>.
type (a :: k1) ^ (b :: k2) = Exp a b
infixr 8 ^

-- | The quotient and remainder of a type-level integer and a natural
--   number. For a negative dividend, the remainder part is positive such
--   that x = q*y + r @since 0.1.4
type family DivMod (x :: k) (y :: Nat) :: (IntDivK k, IntDivK k)

-- | The quotient and remainder of a type-level integer and a natural
--   number. For a negative dividend, the remainder part is negative such
--   that x = q*y + r @since 0.1.4
type family QuotRem (x :: k) (y :: Nat) :: (IntDivK k, IntDivK k)

-- | The quotient of a type-level integer and a natural number.
type family Div (x :: k) (y :: Nat) :: IntDivK k
infixl 7 `Div`

-- | The remainder of a type-level integer and a natural number For a
--   negative number, behaves similarly to <a>mod</a>. @since 0.1.4
type family Mod (x :: k) (y :: Nat) :: IntDivK k
infixl 7 `Mod`

-- | The integer part of the result of dividing an integer by a natural
--   number
type family Quot (x :: k) (y :: Nat) :: IntDivK k
infixl 7 `Quot`

-- | The remainder of the result of dividing an integer by a natural number
type family Rem (x :: k) (y :: Nat) :: IntDivK k
infixl 7 `Rem`

-- | The greatest common divisor of two type-level integers
type family GCD (x :: k1) (y :: k2) :: Nat

-- | The floor of the logarithm of a type-level number NB. unlike
--   <a>Log2</a>, <tt>Log n 0</tt> here is a type error.
type family IntLog (n :: Nat) (x :: k) :: TInt

-- | The floor of the logarithm base 2 of a type-level number. Note that
--   unlike <a>Log2</a>, this errors on <tt>Log2 0</tt>.
type Log2 (x :: k) = IntLog 2 x

-- | (Kind) This is the kind of type-level symbols.
data Symbol

-- | Concatenation of type-level symbols.
type family AppendSymbol (a :: Symbol) (b :: Symbol) :: Symbol

-- | Comparison of type-level symbols, as a function.
type family CmpSymbol (a :: Symbol) (b :: Symbol) :: Ordering

-- | This class gives the string associated with a type-level symbol. There
--   are instances of the class for every concrete literal: "hello", etc.
class KnownSymbol (n :: Symbol)

symbolVal :: forall (n :: Symbol) proxy. KnownSymbol n => proxy n -> String

symbolVal' :: forall (n :: Symbol). KnownSymbol n => Proxy# n -> String

-- | This type represents unknown type-level symbols.
data SomeSymbol

SomeSymbol :: Proxy n -> SomeSymbol

-- | Convert a string into an unknown type-level symbol.
someSymbolVal :: String -> SomeSymbol

-- | We either get evidence that this function was instantiated with the
--   same type-level symbols, or <a>Nothing</a>.
sameSymbol :: forall (a :: Symbol) (b :: Symbol) proxy1 proxy2. (KnownSymbol a, KnownSymbol b) => proxy1 a -> proxy2 b -> Maybe (a :~: b)

-- | The type-level equivalent of <a>error</a>.
--   
--   The polymorphic kind of this type allows it to be used in several
--   settings. For instance, it can be used as a constraint, e.g. to
--   provide a better error message for a non-existent instance,
--   
--   <pre>
--   -- in a context
--   instance TypeError (Text "Cannot <tt>Show</tt> functions." :$$:
--                       Text "Perhaps there is a missing argument?")
--         =&gt; Show (a -&gt; b) where
--       showsPrec = error "unreachable"
--   </pre>
--   
--   It can also be placed on the right-hand side of a type-level function
--   to provide an error for an invalid case,
--   
--   <pre>
--   type family ByteSize x where
--      ByteSize Word16   = 2
--      ByteSize Word8    = 1
--      ByteSize a        = TypeError (Text "The type " :&lt;&gt;: ShowType a :&lt;&gt;:
--                                     Text " is not exportable.")
--   </pre>
type family TypeError (a :: ErrorMessage) :: b

-- | A description of a custom type error.
data ErrorMessage

-- | Show the text as is.
Text :: Symbol -> ErrorMessage

-- | Pretty print the type. <tt>ShowType :: k -&gt; ErrorMessage</tt>
ShowType :: t -> ErrorMessage

-- | Put two pieces of error message next to each other.
(:<>:) :: ErrorMessage -> ErrorMessage -> ErrorMessage

-- | Stack two pieces of error message on top of each other.
(:$$:) :: ErrorMessage -> ErrorMessage -> ErrorMessage
infixl 6 :<>:
infixl 5 :$$:
