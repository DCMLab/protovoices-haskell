-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A library for generating 2D Charts and Plots
--   
--   A library for generating 2D Charts and Plots, with backends provided
--   by Cairo (<a>http://hackage.haskell.org/package/Chart-cairo</a>) and
--   Diagrams (<a>http://hackage.haskell.org/package/Chart-diagrams</a>).
--   Documentation: <a>https://github.com/timbod7/haskell-chart/wiki</a>.
@package Chart
@version 1.9.5


module Graphics.Rendering.Chart.Geometry

-- | A rectangle is defined by two points.
data Rect
Rect :: Point -> Point -> Rect

-- | A point in two dimensions.
data Point
Point :: Double -> Double -> Point
[p_x] :: Point -> Double
[p_y] :: Point -> Double

-- | A vector in two dimensions.
data Vector
Vector :: Double -> Double -> Vector
[v_x] :: Vector -> Double
[v_y] :: Vector -> Double
type RectSize = (Double, Double)
type Range = (Double, Double)

-- | Convert a <a>Point</a> to a <a>Vector</a>.
pointToVec :: Point -> Vector

-- | Create a rectangle based upon the coordinates of 4 points.
mkrect :: Point -> Point -> Point -> Point -> Rect

-- | Make a path from a rectangle.
rectPath :: Rect -> Path

-- | Add a point and a vector.
pvadd :: Point -> Vector -> Point

-- | Subtract a vector from a point.
pvsub :: Point -> Vector -> Point

-- | Subtract two points.
psub :: Point -> Point -> Vector

-- | Angle of a vector (counterclockwise from positive x-axis)
vangle :: Vector -> Double

-- | Length/magnitude of a vector
vlen :: Vector -> Double

-- | Scale a vector by a constant.
vscale :: Double -> Vector -> Vector

-- | Test if a point is within a rectangle.
within :: Point -> Rect -> Bool

-- | Intersects the rectangles. If they intersect the intersection
--   rectangle is returned. <a>LMin</a> is the empty rectangle /
--   intersection and <a>LMax</a> is the infinite plane.
intersectRect :: Limit Rect -> Limit Rect -> Limit Rect

-- | Edge of a rectangle.
data RectEdge
E_Top :: RectEdge
E_Bottom :: RectEdge
E_Left :: RectEdge
E_Right :: RectEdge
data Limit a
LMin :: Limit a
LValue :: a -> Limit a
LMax :: Limit a

-- | A function mapping between points.
type PointMapFn x y = (Limit x, Limit y) -> Point

-- | The path type used by Charts.
--   
--   A path can consist of several subpaths. Each is started by a
--   <a>MoveTo</a> operation. All subpaths are open, except the last one,
--   which may be closed using the <a>Close</a> operation. When filling a
--   path all subpaths are closed implicitly.
--   
--   Closing a subpath means that a line is drawn from the end point to the
--   start point of the subpath.
--   
--   If a <a>Arc</a> (or <a>ArcNeg</a>) is drawn a implicit line from the
--   last end point of the subpath is drawn to the beginning of the arc.
--   Another implicit line is drawn from the end of an arc to the beginning
--   of the next path segment.
--   
--   The beginning of a subpath is either (0,0) or set by a <a>MoveTo</a>
--   instruction. If the first subpath is started with an arc the beginning
--   of that subpath is the beginning of the arc.
data Path
MoveTo :: Point -> Path -> Path
LineTo :: Point -> Path -> Path
Arc :: Point -> Double -> Double -> Double -> Path -> Path
ArcNeg :: Point -> Double -> Double -> Double -> Path -> Path
End :: Path
Close :: Path

-- | Move the paths pointer to the given location and draw a straight line
--   while doing so.
lineTo :: Point -> Path

-- | Move the paths pointer to the given location.
moveTo :: Point -> Path

-- | Short-cut for <a>lineTo</a>, if you don't want to create a
--   <a>Point</a>.
lineTo' :: Double -> Double -> Path

-- | Short-cut for <a>moveTo</a>, if you don't want to create a
--   <a>Point</a>.
moveTo' :: Double -> Double -> Path

-- | Draw the arc of a circle. A straight line connects the end of the
--   previous path with the beginning of the arc. The zero angle points in
--   direction of the positive x-axis. Angles increase in clock-wise
--   direction. If the stop angle is smaller then the start angle it is
--   increased by multiples of <tt>2 * pi</tt> until is is greater or
--   equal.
arc :: Point -> Double -> Double -> Double -> Path

-- | Short-cut for <a>arc</a>, if you don't want to create a <a>Point</a>.
arc' :: Double -> Double -> Double -> Double -> Double -> Path

-- | Like <a>arc</a>, but draws from the stop angle to the start angle
--   instead of between them.
arcNeg :: Point -> Double -> Double -> Double -> Path

-- | Short-cut for <a>arcNeg</a>, if you don't want to create a
--   <a>Point</a>.
arcNeg' :: Double -> Double -> Double -> Double -> Double -> Path

-- | A closed empty path. Closes a path when appended.
close :: Path

-- | Fold the given path to a monoid structure.
foldPath :: Monoid m => (Point -> m) -> (Point -> m) -> (Point -> Double -> Double -> Double -> m) -> (Point -> Double -> Double -> Double -> m) -> m -> Path -> m

-- | Enriches the path with explicit instructions to draw lines, that
--   otherwise would be implicit. See <a>Path</a> for details about what
--   lines in paths are implicit.
makeLinesExplicit :: Path -> Path

-- | Transform a point using the given matrix.
transformP :: Matrix -> Point -> Point

-- | Scale a point.
scaleP :: Vector -> Point -> Point

-- | Rotate a point around the origin. The angle is given in radians.
rotateP :: Double -> Point -> Point

-- | Translate a point.
translateP :: Vector -> Point -> Point

-- | Copied from Graphics.Rendering.Cairo.Matrix
data Matrix
Matrix :: !Double -> !Double -> !Double -> !Double -> !Double -> !Double -> Matrix
[xx] :: Matrix -> !Double
[yx] :: Matrix -> !Double
[xy] :: Matrix -> !Double
[yy] :: Matrix -> !Double
[x0] :: Matrix -> !Double
[y0] :: Matrix -> !Double

-- | Copied from Graphics.Rendering.Cairo.Matrix
identity :: Matrix

-- | Copied from Graphics.Rendering.Cairo.Matrix Rotations angle is given
--   in radians.
rotate :: Double -> Matrix -> Matrix

-- | Copied and adopted from Graphics.Rendering.Cairo.Matrix
scale :: Vector -> Matrix -> Matrix

-- | Copied and adopted from Graphics.Rendering.Cairo.Matrix
translate :: Vector -> Matrix -> Matrix

-- | Copied from Graphics.Rendering.Cairo.Matrix
scalarMultiply :: Double -> Matrix -> Matrix

-- | Copied from Graphics.Rendering.Cairo.Matrix
adjoint :: Matrix -> Matrix

-- | Copied from Graphics.Rendering.Cairo.Matrix
invert :: Matrix -> Matrix
instance GHC.Internal.Base.Monoid Graphics.Rendering.Chart.Geometry.Path
instance GHC.Internal.Num.Num Graphics.Rendering.Chart.Geometry.Matrix
instance GHC.Internal.Base.Semigroup Graphics.Rendering.Chart.Geometry.Path
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Graphics.Rendering.Chart.Geometry.Limit a)
instance GHC.Internal.Show.Show Graphics.Rendering.Chart.Geometry.Matrix
instance GHC.Internal.Show.Show Graphics.Rendering.Chart.Geometry.Point
instance GHC.Internal.Show.Show Graphics.Rendering.Chart.Geometry.Rect
instance GHC.Internal.Show.Show Graphics.Rendering.Chart.Geometry.Vector


module Graphics.Rendering.Chart.Backend.Types

-- | The different supported line ends.
data LineCap

-- | Just cut the line straight.
LineCapButt :: LineCap

-- | Make a rounded line end.
LineCapRound :: LineCap

-- | Make a square that ends the line.
LineCapSquare :: LineCap

-- | The different supported ways to join line ends.
data LineJoin

-- | Extends the outline until they meet each other.
LineJoinMiter :: LineJoin

-- | Draw a circle fragment to connet line end.
LineJoinRound :: LineJoin

-- | Like miter, but cuts it off if a certain threshold is exceeded.
LineJoinBevel :: LineJoin

-- | Data type for the style of a line.
data LineStyle
LineStyle :: Double -> AlphaColour Double -> [Double] -> LineCap -> LineJoin -> LineStyle

-- | The thickness of a line in device units.
[_line_width] :: LineStyle -> Double

-- | The color of a line.
[_line_color] :: LineStyle -> AlphaColour Double

-- | The dash pattern. Every value at a even index gives a dash width and
--   every value at a odd index gives a gap width in device units.
[_line_dashes] :: LineStyle -> [Double]

-- | How to end a line.
[_line_cap] :: LineStyle -> LineCap

-- | How to connect two lines.
[_line_join] :: LineStyle -> LineJoin

-- | The possible slants of a font.
data FontSlant

-- | Normal font style without slant.
FontSlantNormal :: FontSlant

-- | With a slight slant.
FontSlantItalic :: FontSlant

-- | With a greater slant.
FontSlantOblique :: FontSlant

-- | The possible weights of a font.
data FontWeight

-- | Normal font style without weight.
FontWeightNormal :: FontWeight

-- | Bold font.
FontWeightBold :: FontWeight

-- | Data type for a font.
data FontStyle
FontStyle :: String -> Double -> FontSlant -> FontWeight -> AlphaColour Double -> FontStyle

-- | The font family or font face to use.
[_font_name] :: FontStyle -> String

-- | The height of the rendered font in device coordinates.
[_font_size] :: FontStyle -> Double

-- | The slant to render with.
[_font_slant] :: FontStyle -> FontSlant

-- | The weight to render with.
[_font_weight] :: FontStyle -> FontWeight

-- | The color to render text with.
[_font_color] :: FontStyle -> AlphaColour Double

-- | Possible horizontal anchor points for text.
data HTextAnchor
HTA_Left :: HTextAnchor
HTA_Centre :: HTextAnchor
HTA_Right :: HTextAnchor

-- | Possible vertical anchor points for text.
data VTextAnchor
VTA_Top :: VTextAnchor
VTA_Centre :: VTextAnchor
VTA_Bottom :: VTextAnchor
VTA_BaseLine :: VTextAnchor

-- | Text metrics returned by <tt>textSize</tt>.
data TextSize
TextSize :: Double -> Double -> Double -> Double -> Double -> TextSize

-- | The total width of the text.
[textSizeWidth] :: TextSize -> Double

-- | The ascent or space above the baseline.
[textSizeAscent] :: TextSize -> Double

-- | The decent or space below the baseline.
[textSizeDescent] :: TextSize -> Double

-- | The Y bearing.
[textSizeYBearing] :: TextSize -> Double

-- | The total height of the text.
[textSizeHeight] :: TextSize -> Double

-- | Abstract data type for a fill style.
--   
--   The contained action sets the required fill style in the rendering
--   state.
newtype FillStyle
FillStyleSolid :: AlphaColour Double -> FillStyle
[_fill_color] :: FillStyle -> AlphaColour Double

-- | A function to align points for a certain rendering device.
type AlignmentFn = Point -> Point

-- | Holds the point and coordinate alignment function.
data AlignmentFns
AlignmentFns :: AlignmentFn -> AlignmentFn -> AlignmentFns

-- | An adjustment applied immediately prior to points being displayed in
--   device coordinates.
--   
--   When device coordinates correspond to pixels, a cleaner image is
--   created if this transform rounds to the nearest pixel. With
--   higher-resolution output, this transform can just be the identity
--   function.
--   
--   This is usually used to align prior to stroking.
[afPointAlignFn] :: AlignmentFns -> AlignmentFn

-- | The adjustment applied immediately prior to coordinates being
--   transformed.
--   
--   This is usually used to align prior to filling.
[afCoordAlignFn] :: AlignmentFns -> AlignmentFn

-- | Alignment to render on raster based graphics.
bitmapAlignmentFns :: AlignmentFns

-- | Alignment to render on vector based graphics.
vectorAlignmentFns :: AlignmentFns
line_cap :: Lens' LineStyle LineCap
line_color :: Lens' LineStyle (AlphaColour Double)
line_dashes :: Lens' LineStyle [Double]
line_join :: Lens' LineStyle LineJoin
line_width :: Lens' LineStyle Double
font_color :: Lens' FontStyle (AlphaColour Double)
font_name :: Lens' FontStyle String
font_size :: Lens' FontStyle Double
font_slant :: Lens' FontStyle FontSlant
font_weight :: Lens' FontStyle FontWeight
fill_color :: Iso' FillStyle (AlphaColour Double)
instance Data.Default.Internal.Default Graphics.Rendering.Chart.Backend.Types.FillStyle
instance Data.Default.Internal.Default Graphics.Rendering.Chart.Backend.Types.FontSlant
instance Data.Default.Internal.Default Graphics.Rendering.Chart.Backend.Types.FontStyle
instance Data.Default.Internal.Default Graphics.Rendering.Chart.Backend.Types.FontWeight
instance Data.Default.Internal.Default Graphics.Rendering.Chart.Backend.Types.LineStyle
instance GHC.Classes.Eq Graphics.Rendering.Chart.Backend.Types.FillStyle
instance GHC.Classes.Eq Graphics.Rendering.Chart.Backend.Types.FontSlant
instance GHC.Classes.Eq Graphics.Rendering.Chart.Backend.Types.FontStyle
instance GHC.Classes.Eq Graphics.Rendering.Chart.Backend.Types.FontWeight
instance GHC.Classes.Eq Graphics.Rendering.Chart.Backend.Types.HTextAnchor
instance GHC.Classes.Eq Graphics.Rendering.Chart.Backend.Types.LineCap
instance GHC.Classes.Eq Graphics.Rendering.Chart.Backend.Types.LineJoin
instance GHC.Classes.Eq Graphics.Rendering.Chart.Backend.Types.LineStyle
instance GHC.Classes.Eq Graphics.Rendering.Chart.Backend.Types.TextSize
instance GHC.Classes.Eq Graphics.Rendering.Chart.Backend.Types.VTextAnchor
instance GHC.Classes.Ord Graphics.Rendering.Chart.Backend.Types.FontSlant
instance GHC.Classes.Ord Graphics.Rendering.Chart.Backend.Types.FontWeight
instance GHC.Classes.Ord Graphics.Rendering.Chart.Backend.Types.HTextAnchor
instance GHC.Classes.Ord Graphics.Rendering.Chart.Backend.Types.LineCap
instance GHC.Classes.Ord Graphics.Rendering.Chart.Backend.Types.LineJoin
instance GHC.Classes.Ord Graphics.Rendering.Chart.Backend.Types.VTextAnchor
instance GHC.Internal.Show.Show Graphics.Rendering.Chart.Backend.Types.FillStyle
instance GHC.Internal.Show.Show Graphics.Rendering.Chart.Backend.Types.FontSlant
instance GHC.Internal.Show.Show Graphics.Rendering.Chart.Backend.Types.FontStyle
instance GHC.Internal.Show.Show Graphics.Rendering.Chart.Backend.Types.FontWeight
instance GHC.Internal.Show.Show Graphics.Rendering.Chart.Backend.Types.HTextAnchor
instance GHC.Internal.Show.Show Graphics.Rendering.Chart.Backend.Types.LineCap
instance GHC.Internal.Show.Show Graphics.Rendering.Chart.Backend.Types.LineJoin
instance GHC.Internal.Show.Show Graphics.Rendering.Chart.Backend.Types.LineStyle
instance GHC.Internal.Show.Show Graphics.Rendering.Chart.Backend.Types.TextSize
instance GHC.Internal.Show.Show Graphics.Rendering.Chart.Backend.Types.VTextAnchor


-- | This module provides the implementation details common to all
--   <tt>ChartBackend</tt>s.
module Graphics.Rendering.Chart.Backend.Impl

-- | The abstract drawing operation generated when using the the chart
--   drawing API.
--   
--   See the documentation of the different function for the correct
--   semantics of each instruction:
--   
--   <ul>
--   <li><a>strokePath</a>, <a>fillPath</a></li>
--   <li><a>drawText</a>, <a>textSize</a></li>
--   <li><a>getPointAlignFn</a>, <a>getCoordAlignFn</a>,
--   <a>AlignmentFns</a></li>
--   <li><a>withTransform</a>, <a>withClipRegion</a></li>
--   <li><a>withLineStyle</a>, <a>withFillStyle</a>,
--   <a>withFontStyle</a></li>
--   </ul>
data ChartBackendInstr a
[StrokePath] :: Path -> ChartBackendInstr ()
[FillPath] :: Path -> ChartBackendInstr ()
[GetTextSize] :: String -> ChartBackendInstr TextSize
[DrawText] :: Point -> String -> ChartBackendInstr ()
[GetAlignments] :: ChartBackendInstr AlignmentFns
[WithTransform] :: forall a. Matrix -> Program ChartBackendInstr a -> ChartBackendInstr a
[WithFontStyle] :: forall a. FontStyle -> Program ChartBackendInstr a -> ChartBackendInstr a
[WithFillStyle] :: forall a. FillStyle -> Program ChartBackendInstr a -> ChartBackendInstr a
[WithLineStyle] :: forall a. LineStyle -> Program ChartBackendInstr a -> ChartBackendInstr a
[WithClipRegion] :: forall a. Rect -> Program ChartBackendInstr a -> ChartBackendInstr a

-- | A <a>BackendProgram</a> provides the capability to render a chart
--   somewhere.
--   
--   The coordinate system of the backend has its initial origin (0,0) in
--   the top left corner of the drawing plane. The x-axis points towards
--   the top right corner and the y-axis points towards the bottom left
--   corner. The unit used by coordinates, the font size, and lengths is
--   the always the same, but depends on the backend. All angles are
--   measured in radians.
--   
--   The line, fill and font style are set to their default values
--   initially.
--   
--   Information about the semantics of the instructions can be found in
--   the documentation of <a>ChartBackendInstr</a>.
type BackendProgram a = Program ChartBackendInstr a

-- | Stroke the outline of the given path using the current
--   <a>LineStyle</a>. This function does <i>not</i> perform alignment
--   operations on the path. See <a>Path</a> for the exact semantic of
--   paths.
strokePath :: Path -> BackendProgram ()

-- | Fill the given path using the current <a>FillStyle</a>. The given path
--   will be closed prior to filling. This function does <i>not</i> perform
--   alignment operations on the path. See <a>Path</a> for the exact
--   semantic of paths.
fillPath :: Path -> BackendProgram ()

-- | Calculate a <a>TextSize</a> object with rendering information about
--   the given string without actually rendering it.
textSize :: String -> BackendProgram TextSize

-- | Draw a single-line textual label anchored by the baseline (vertical)
--   left (horizontal) point. Uses the current <a>FontStyle</a> for
--   drawing.
drawText :: Point -> String -> BackendProgram ()

-- | Apply the given transformation in this local environment when drawing.
--   The given transformation is applied after the current transformation.
--   This means both are combined.
withTransform :: Matrix -> BackendProgram a -> BackendProgram a

-- | Use the given font style in this local environment when drawing text.
--   
--   An implementing backend is expected to guarantee to support the
--   following font families: <tt>serif</tt>, <tt>sans-serif</tt> and
--   <tt>monospace</tt>;
--   
--   If the backend is not able to find or load a given font it is required
--   to fall back to a custom fail-safe font and use it instead.
withFontStyle :: FontStyle -> BackendProgram a -> BackendProgram a

-- | Use the given fill style in this local environment when filling paths.
withFillStyle :: FillStyle -> BackendProgram a -> BackendProgram a

-- | Use the given line style in this local environment when stroking
--   paths.
withLineStyle :: LineStyle -> BackendProgram a -> BackendProgram a

-- | Use the given clipping rectangle when drawing in this local
--   environment. The new clipping region is intersected with the given
--   clip region. You cannot escape the clip!
withClipRegion :: Rect -> BackendProgram a -> BackendProgram a

-- | Get the point alignment function
getPointAlignFn :: BackendProgram (Point -> Point)

-- | Get the coordinate alignment function
getCoordAlignFn :: BackendProgram (Point -> Point)


-- | This module provides the API for drawing operations abstracted to
--   drive arbitrary Backend.
module Graphics.Rendering.Chart.Backend

-- | A <a>BackendProgram</a> provides the capability to render a chart
--   somewhere.
--   
--   The coordinate system of the backend has its initial origin (0,0) in
--   the top left corner of the drawing plane. The x-axis points towards
--   the top right corner and the y-axis points towards the bottom left
--   corner. The unit used by coordinates, the font size, and lengths is
--   the always the same, but depends on the backend. All angles are
--   measured in radians.
--   
--   The line, fill and font style are set to their default values
--   initially.
--   
--   Information about the semantics of the instructions can be found in
--   the documentation of <a>ChartBackendInstr</a>.
type BackendProgram a = Program ChartBackendInstr a

-- | Fill the given path using the current <a>FillStyle</a>. The given path
--   will be closed prior to filling. This function does <i>not</i> perform
--   alignment operations on the path. See <a>Path</a> for the exact
--   semantic of paths.
fillPath :: Path -> BackendProgram ()

-- | Stroke the outline of the given path using the current
--   <a>LineStyle</a>. This function does <i>not</i> perform alignment
--   operations on the path. See <a>Path</a> for the exact semantic of
--   paths.
strokePath :: Path -> BackendProgram ()

-- | Draw a single-line textual label anchored by the baseline (vertical)
--   left (horizontal) point. Uses the current <a>FontStyle</a> for
--   drawing.
drawText :: Point -> String -> BackendProgram ()

-- | Calculate a <a>TextSize</a> object with rendering information about
--   the given string without actually rendering it.
textSize :: String -> BackendProgram TextSize

-- | Apply the given transformation in this local environment when drawing.
--   The given transformation is applied after the current transformation.
--   This means both are combined.
withTransform :: Matrix -> BackendProgram a -> BackendProgram a

-- | Use the given clipping rectangle when drawing in this local
--   environment. The new clipping region is intersected with the given
--   clip region. You cannot escape the clip!
withClipRegion :: Rect -> BackendProgram a -> BackendProgram a

-- | Use the given font style in this local environment when drawing text.
--   
--   An implementing backend is expected to guarantee to support the
--   following font families: <tt>serif</tt>, <tt>sans-serif</tt> and
--   <tt>monospace</tt>;
--   
--   If the backend is not able to find or load a given font it is required
--   to fall back to a custom fail-safe font and use it instead.
withFontStyle :: FontStyle -> BackendProgram a -> BackendProgram a

-- | Use the given fill style in this local environment when filling paths.
withFillStyle :: FillStyle -> BackendProgram a -> BackendProgram a

-- | Use the given line style in this local environment when stroking
--   paths.
withLineStyle :: LineStyle -> BackendProgram a -> BackendProgram a

-- | Get the point alignment function
getPointAlignFn :: BackendProgram (Point -> Point)

-- | Get the coordinate alignment function
getCoordAlignFn :: BackendProgram (Point -> Point)

-- | Text metrics returned by <tt>textSize</tt>.
data TextSize
TextSize :: Double -> Double -> Double -> Double -> Double -> TextSize

-- | The total width of the text.
[textSizeWidth] :: TextSize -> Double

-- | The ascent or space above the baseline.
[textSizeAscent] :: TextSize -> Double

-- | The decent or space below the baseline.
[textSizeDescent] :: TextSize -> Double

-- | The Y bearing.
[textSizeYBearing] :: TextSize -> Double

-- | The total height of the text.
[textSizeHeight] :: TextSize -> Double

-- | The different supported line ends.
data LineCap

-- | Just cut the line straight.
LineCapButt :: LineCap

-- | Make a rounded line end.
LineCapRound :: LineCap

-- | Make a square that ends the line.
LineCapSquare :: LineCap

-- | The different supported ways to join line ends.
data LineJoin

-- | Extends the outline until they meet each other.
LineJoinMiter :: LineJoin

-- | Draw a circle fragment to connet line end.
LineJoinRound :: LineJoin

-- | Like miter, but cuts it off if a certain threshold is exceeded.
LineJoinBevel :: LineJoin

-- | Data type for the style of a line.
data LineStyle
LineStyle :: Double -> AlphaColour Double -> [Double] -> LineCap -> LineJoin -> LineStyle

-- | The thickness of a line in device units.
[_line_width] :: LineStyle -> Double

-- | The color of a line.
[_line_color] :: LineStyle -> AlphaColour Double

-- | The dash pattern. Every value at a even index gives a dash width and
--   every value at a odd index gives a gap width in device units.
[_line_dashes] :: LineStyle -> [Double]

-- | How to end a line.
[_line_cap] :: LineStyle -> LineCap

-- | How to connect two lines.
[_line_join] :: LineStyle -> LineJoin
line_width :: Lens' LineStyle Double
line_color :: Lens' LineStyle (AlphaColour Double)
line_dashes :: Lens' LineStyle [Double]
line_cap :: Lens' LineStyle LineCap
line_join :: Lens' LineStyle LineJoin

-- | Abstract data type for a fill style.
--   
--   The contained action sets the required fill style in the rendering
--   state.
newtype FillStyle
FillStyleSolid :: AlphaColour Double -> FillStyle
[_fill_color] :: FillStyle -> AlphaColour Double

-- | The possible weights of a font.
data FontWeight

-- | Normal font style without weight.
FontWeightNormal :: FontWeight

-- | Bold font.
FontWeightBold :: FontWeight

-- | The possible slants of a font.
data FontSlant

-- | Normal font style without slant.
FontSlantNormal :: FontSlant

-- | With a slight slant.
FontSlantItalic :: FontSlant

-- | With a greater slant.
FontSlantOblique :: FontSlant

-- | Data type for a font.
data FontStyle
FontStyle :: String -> Double -> FontSlant -> FontWeight -> AlphaColour Double -> FontStyle

-- | The font family or font face to use.
[_font_name] :: FontStyle -> String

-- | The height of the rendered font in device coordinates.
[_font_size] :: FontStyle -> Double

-- | The slant to render with.
[_font_slant] :: FontStyle -> FontSlant

-- | The weight to render with.
[_font_weight] :: FontStyle -> FontWeight

-- | The color to render text with.
[_font_color] :: FontStyle -> AlphaColour Double

-- | Possible horizontal anchor points for text.
data HTextAnchor
HTA_Left :: HTextAnchor
HTA_Centre :: HTextAnchor
HTA_Right :: HTextAnchor

-- | Possible vertical anchor points for text.
data VTextAnchor
VTA_Top :: VTextAnchor
VTA_Centre :: VTextAnchor
VTA_Bottom :: VTextAnchor
VTA_BaseLine :: VTextAnchor
font_name :: Lens' FontStyle String
font_size :: Lens' FontStyle Double
font_slant :: Lens' FontStyle FontSlant
font_weight :: Lens' FontStyle FontWeight
font_color :: Lens' FontStyle (AlphaColour Double)

-- | A function to align points for a certain rendering device.
type AlignmentFn = Point -> Point

-- | Holds the point and coordinate alignment function.
data AlignmentFns

-- | Alignment to render on vector based graphics.
vectorAlignmentFns :: AlignmentFns

-- | Alignment to render on raster based graphics.
bitmapAlignmentFns :: AlignmentFns


-- | This module contains basic types and functions used for drawing.
--   
--   Note that Template Haskell is used to derive accessor functions (see
--   <a>Lens</a>) for each field of the following data types:
--   
--   <ul>
--   <li><a>PointStyle</a></li>
--   </ul>
--   
--   These accessors are not shown in this API documentation. They have the
--   same name as the field, but with the trailing underscore dropped.
--   Hence for data field <tt>f_::F</tt> in type <tt>D</tt>, they have type
--   
--   <pre>
--   f :: Control.Lens.Lens' D F
--   </pre>
module Graphics.Rendering.Chart.Drawing

-- | The different shapes a point can have.
data PointShape

-- | A circle.
PointShapeCircle :: PointShape

-- | Number of vertices and is right-side-up?
PointShapePolygon :: Int -> Bool -> PointShape

-- | A plus sign.
PointShapePlus :: PointShape

-- | A cross.
PointShapeCross :: PointShape

-- | Combination of a cross and a plus.
PointShapeStar :: PointShape
PointShapeArrowHead :: Double -> PointShape

-- | Ratio of minor to major axis and rotation
PointShapeEllipse :: Double -> Double -> PointShape

-- | Abstract data type for the style of a plotted point.
data PointStyle
PointStyle :: AlphaColour Double -> AlphaColour Double -> Double -> Double -> PointShape -> PointStyle

-- | The color to fill the point with.
[_point_color] :: PointStyle -> AlphaColour Double

-- | The color to stroke the outline with.
[_point_border_color] :: PointStyle -> AlphaColour Double

-- | The width of the outline.
[_point_border_width] :: PointStyle -> Double

-- | The radius of the tightest surrounding circle of the point.
[_point_radius] :: PointStyle -> Double

-- | The shape.
[_point_shape] :: PointStyle -> PointShape

-- | Draw a single point at the given location.
drawPoint :: PointStyle -> Point -> BackendProgram ()

-- | Align the path by applying the given function on all points.
alignPath :: (Point -> Point) -> Path -> Path

-- | Align the path using the environment's alignment function for
--   coordinates. This is generally useful when filling. See
--   <a>alignPath</a> and <a>getCoordAlignFn</a>.
alignFillPath :: Path -> BackendProgram Path

-- | Align the path using the environment's alignment function for points.
--   This is generally useful when stroking. See <a>alignPath</a> and
--   <a>getPointAlignFn</a>.
alignStrokePath :: Path -> BackendProgram Path

-- | The points will be aligned by the <a>getCoordAlignFn</a>, so that when
--   drawing bitmaps, the edges of the region will fall between pixels.
alignFillPoints :: [Point] -> BackendProgram [Point]

-- | The points will be aligned by the <a>getPointAlignFn</a>, so that when
--   drawing bitmaps, 1 pixel wide lines will be centred on the pixels.
alignStrokePoints :: [Point] -> BackendProgram [Point]

-- | Align the point using the environment's alignment function for
--   coordinates. See <a>getCoordAlignFn</a>.
alignFillPoint :: Point -> BackendProgram Point

-- | Align the point using the environment's alignment function for points.
--   See <a>getPointAlignFn</a>.
alignStrokePoint :: Point -> BackendProgram Point

-- | Draw lines between the specified points.
strokePointPath :: [Point] -> BackendProgram ()

-- | Fill the region with the given corners.
fillPointPath :: [Point] -> BackendProgram ()

-- | Apply a local rotation. The angle is given in radians.
withRotation :: Double -> BackendProgram a -> BackendProgram a

-- | Apply a local translation.
withTranslation :: Point -> BackendProgram a -> BackendProgram a

-- | Apply a local scale.
withScale :: Vector -> BackendProgram a -> BackendProgram a

-- | Apply a local scale on the x-axis.
withScaleX :: Double -> BackendProgram a -> BackendProgram a

-- | Apply a local scale on the y-axis.
withScaleY :: Double -> BackendProgram a -> BackendProgram a

-- | Changes the <a>LineStyle</a> and <a>FillStyle</a> to comply with the
--   given <a>PointStyle</a>.
withPointStyle :: PointStyle -> BackendProgram a -> BackendProgram a
withDefaultStyle :: BackendProgram a -> BackendProgram a

-- | Draw a line of text that is aligned at a different anchor point. See
--   <a>drawText</a>.
drawTextA :: HTextAnchor -> VTextAnchor -> Point -> String -> BackendProgram ()

-- | Draw a textual label anchored by one of its corners or edges, with
--   rotation. Rotation angle is given in degrees, rotation is performed
--   around anchor point. See <a>drawText</a>.
drawTextR :: HTextAnchor -> VTextAnchor -> Double -> Point -> String -> BackendProgram ()

-- | Draw a multi-line textual label anchored by one of its corners or
--   edges, with rotation. Rotation angle is given in degrees, rotation is
--   performed around anchor point. See <a>drawText</a>.
drawTextsR :: HTextAnchor -> VTextAnchor -> Double -> Point -> String -> BackendProgram ()

-- | Return the bounding rectangle for a text string positioned where it
--   would be drawn by <a>drawText</a>. See <a>textSize</a>.
textDrawRect :: HTextAnchor -> VTextAnchor -> Point -> String -> BackendProgram Rect

-- | Get the width and height of the string when rendered. See
--   <a>textSize</a>.
textDimension :: String -> BackendProgram RectSize

-- | The default sequence of colours to use when plotings different data
--   sets in a graph.
defaultColorSeq :: [AlphaColour Double]

-- | Create a solid line style (not dashed).
solidLine :: Double -> AlphaColour Double -> LineStyle

-- | Create a dashed line style.
dashedLine :: Double -> [Double] -> AlphaColour Double -> LineStyle

-- | Style for filled circle points.
filledCircles :: Double -> AlphaColour Double -> PointStyle

-- | Style for stroked circle points.
hollowCircles :: Double -> Double -> AlphaColour Double -> PointStyle

-- | Style for filled polygon points.
filledPolygon :: Double -> Int -> Bool -> AlphaColour Double -> PointStyle

-- | Style for stroked polygon points.
hollowPolygon :: Double -> Double -> Int -> Bool -> AlphaColour Double -> PointStyle

-- | Plus sign point style.
plusses :: Double -> Double -> AlphaColour Double -> PointStyle

-- | Cross point style.
exes :: Double -> Double -> AlphaColour Double -> PointStyle

-- | Combination of plus and cross point style.
stars :: Double -> Double -> AlphaColour Double -> PointStyle
arrows :: Double -> Double -> Double -> AlphaColour Double -> PointStyle

-- | Fill style that fill everything this the given colour.
solidFillStyle :: AlphaColour Double -> FillStyle
point_color :: Lens' PointStyle (AlphaColour Double)
point_border_color :: Lens' PointStyle (AlphaColour Double)
point_border_width :: Lens' PointStyle Double
point_radius :: Lens' PointStyle Double
point_shape :: Lens' PointStyle PointShape
instance Data.Default.Internal.Default Graphics.Rendering.Chart.Drawing.PointStyle


-- | Datatypes and functions common to the implementation of the various
--   plot types.
module Graphics.Rendering.Chart.Plot.Types

-- | Interface to control plotting on a 2D area.
data Plot x y
Plot :: (PointMapFn x y -> BackendProgram ()) -> [(String, Rect -> BackendProgram ())] -> ([x], [y]) -> Plot x y

-- | Given the mapping between model space coordinates and device
--   coordinates, render this plot into a chart.
[_plot_render] :: Plot x y -> PointMapFn x y -> BackendProgram ()

-- | Details for how to show this plot in a legend. For each item the
--   string is the text to show, and the function renders a graphical
--   sample of the plot.
[_plot_legend] :: Plot x y -> [(String, Rect -> BackendProgram ())]

-- | All of the model space coordinates to be plotted. These are used to
--   autoscale the axes where necessary.
[_plot_all_points] :: Plot x y -> ([x], [y])

-- | Join any two plots together (they will share a legend).
joinPlot :: Plot x y -> Plot x y -> Plot x y

-- | A type class abstracting the conversion of a value to a Plot.
class ToPlot (a :: Type -> Type -> Type)
toPlot :: ToPlot a => a x y -> Plot x y
mapXY :: PointMapFn x y -> (x, y) -> Point
plot_render :: forall x y f. Functor f => ((PointMapFn x y -> BackendProgram ()) -> f (PointMapFn x y -> BackendProgram ())) -> Plot x y -> f (Plot x y)
plot_legend :: forall x y f. Functor f => ([(String, Rect -> BackendProgram ())] -> f [(String, Rect -> BackendProgram ())]) -> Plot x y -> f (Plot x y)
plot_all_points :: forall x y f. Functor f => (([x], [y]) -> f ([x], [y])) -> Plot x y -> f (Plot x y)
instance Graphics.Rendering.Chart.Plot.Types.ToPlot Graphics.Rendering.Chart.Plot.Types.Plot


-- | Functions to plot sets of points, marked in various styles.
module Graphics.Rendering.Chart.Plot.Points

-- | Value defining a series of datapoints, and a style in which to render
--   them.
data PlotPoints x y
PlotPoints :: String -> PointStyle -> [(x, y)] -> PlotPoints x y
[_plot_points_title] :: PlotPoints x y -> String
[_plot_points_style] :: PlotPoints x y -> PointStyle
[_plot_points_values] :: PlotPoints x y -> [(x, y)]
plot_points_title :: forall x y f. Functor f => (String -> f String) -> PlotPoints x y -> f (PlotPoints x y)
plot_points_style :: forall x y f. Functor f => (PointStyle -> f PointStyle) -> PlotPoints x y -> f (PlotPoints x y)
plot_points_values :: forall x1 y1 x2 y2 f. Functor f => ([(x1, y1)] -> f [(x2, y2)]) -> PlotPoints x1 y1 -> f (PlotPoints x2 y2)
instance Data.Default.Internal.Default (Graphics.Rendering.Chart.Plot.Points.PlotPoints x y)
instance Graphics.Rendering.Chart.Plot.Types.ToPlot Graphics.Rendering.Chart.Plot.Points.PlotPoints


-- | Line plots
module Graphics.Rendering.Chart.Plot.Lines

-- | Value defining a series of (possibly disjointed) lines, and a style in
--   which to render them.
data PlotLines x y
PlotLines :: String -> LineStyle -> [[(x, y)]] -> [[(Limit x, Limit y)]] -> PlotLines x y
[_plot_lines_title] :: PlotLines x y -> String
[_plot_lines_style] :: PlotLines x y -> LineStyle

-- | The lines to be plotted
[_plot_lines_values] :: PlotLines x y -> [[(x, y)]]

-- | Additional lines to be plotted, specified using the Limit type to
--   allow referencing the edges of the plot area.
[_plot_lines_limit_values] :: PlotLines x y -> [[(Limit x, Limit y)]]
defaultPlotLineStyle :: LineStyle

-- | Helper function to plot a single horizontal line.
hlinePlot :: String -> LineStyle -> b -> Plot a b

-- | Helper function to plot a single vertical line.
vlinePlot :: String -> LineStyle -> a -> Plot a b
plot_lines_title :: forall x y f. Functor f => (String -> f String) -> PlotLines x y -> f (PlotLines x y)
plot_lines_style :: forall x y f. Functor f => (LineStyle -> f LineStyle) -> PlotLines x y -> f (PlotLines x y)
plot_lines_values :: forall x y f. Functor f => ([[(x, y)]] -> f [[(x, y)]]) -> PlotLines x y -> f (PlotLines x y)
plot_lines_limit_values :: forall x y f. Functor f => ([[(Limit x, Limit y)]] -> f [[(Limit x, Limit y)]]) -> PlotLines x y -> f (PlotLines x y)
instance Data.Default.Internal.Default (Graphics.Rendering.Chart.Plot.Lines.PlotLines x y)
instance Graphics.Rendering.Chart.Plot.Types.ToPlot Graphics.Rendering.Chart.Plot.Lines.PlotLines


-- | Plots that don't show, but occupy space so as to effect axis scaling
module Graphics.Rendering.Chart.Plot.Hidden

-- | Value defining some hidden x and y values. The values are not
--   displayed, but they still affect axis scaling.
data PlotHidden x y
PlotHidden :: [x] -> [y] -> PlotHidden x y
[_plot_hidden_x_values] :: PlotHidden x y -> [x]
[_plot_hidden_y_values] :: PlotHidden x y -> [y]
plot_hidden_x_values :: forall x1 y x2 f. Functor f => ([x1] -> f [x2]) -> PlotHidden x1 y -> f (PlotHidden x2 y)
plot_hidden_y_values :: forall x y1 y2 f. Functor f => ([y1] -> f [y2]) -> PlotHidden x y1 -> f (PlotHidden x y2)
instance Graphics.Rendering.Chart.Plot.Types.ToPlot Graphics.Rendering.Chart.Plot.Hidden.PlotHidden


-- | Plots that fill the area between two lines.
module Graphics.Rendering.Chart.Plot.FillBetween

-- | Value specifying a plot filling the area between two sets of Y
--   coordinates, given common X coordinates.
data PlotFillBetween x y
PlotFillBetween :: String -> FillStyle -> Maybe LineStyle -> [(x, (y, y))] -> PlotFillBetween x y
[_plot_fillbetween_title] :: PlotFillBetween x y -> String
[_plot_fillbetween_style] :: PlotFillBetween x y -> FillStyle
[_plot_fillbetween_line] :: PlotFillBetween x y -> Maybe LineStyle
[_plot_fillbetween_values] :: PlotFillBetween x y -> [(x, (y, y))]
plot_fillbetween_title :: forall x y f. Functor f => (String -> f String) -> PlotFillBetween x y -> f (PlotFillBetween x y)
plot_fillbetween_style :: forall x y f. Functor f => (FillStyle -> f FillStyle) -> PlotFillBetween x y -> f (PlotFillBetween x y)
plot_fillbetween_line :: forall x y f. Functor f => (Maybe LineStyle -> f (Maybe LineStyle)) -> PlotFillBetween x y -> f (PlotFillBetween x y)
plot_fillbetween_values :: forall x1 y1 x2 y2 f. Functor f => ([(x1, (y1, y1))] -> f [(x2, (y2, y2))]) -> PlotFillBetween x1 y1 -> f (PlotFillBetween x2 y2)
instance Data.Default.Internal.Default (Graphics.Rendering.Chart.Plot.FillBetween.PlotFillBetween x y)
instance Graphics.Rendering.Chart.Plot.Types.ToPlot Graphics.Rendering.Chart.Plot.FillBetween.PlotFillBetween


-- | Plot series of points with associated error bars.
module Graphics.Rendering.Chart.Plot.ErrBars

-- | Value defining a series of error intervals, and a style in which to
--   render them.
data PlotErrBars x y
PlotErrBars :: String -> LineStyle -> Double -> Double -> [ErrPoint x y] -> PlotErrBars x y
[_plot_errbars_title] :: PlotErrBars x y -> String
[_plot_errbars_line_style] :: PlotErrBars x y -> LineStyle
[_plot_errbars_tick_length] :: PlotErrBars x y -> Double
[_plot_errbars_overhang] :: PlotErrBars x y -> Double
[_plot_errbars_values] :: PlotErrBars x y -> [ErrPoint x y]
data ErrPoint x y
ErrPoint :: ErrValue x -> ErrValue y -> ErrPoint x y
[ep_x] :: ErrPoint x y -> ErrValue x
[ep_y] :: ErrPoint x y -> ErrValue y

-- | Value for holding a point with associated error bounds for each axis.
data ErrValue x
ErrValue :: x -> x -> x -> ErrValue x
[ev_low] :: ErrValue x -> x
[ev_best] :: ErrValue x -> x
[ev_high] :: ErrValue x -> x

-- | When the error is symmetric, we can simply pass in dx for the error.
symErrPoint :: (Num a, Num b) => a -> b -> a -> b -> ErrPoint a b
plot_errbars_title :: forall x y f. Functor f => (String -> f String) -> PlotErrBars x y -> f (PlotErrBars x y)
plot_errbars_line_style :: forall x y f. Functor f => (LineStyle -> f LineStyle) -> PlotErrBars x y -> f (PlotErrBars x y)
plot_errbars_tick_length :: forall x y f. Functor f => (Double -> f Double) -> PlotErrBars x y -> f (PlotErrBars x y)
plot_errbars_overhang :: forall x y f. Functor f => (Double -> f Double) -> PlotErrBars x y -> f (PlotErrBars x y)
plot_errbars_values :: forall x1 y1 x2 y2 f. Functor f => ([ErrPoint x1 y1] -> f [ErrPoint x2 y2]) -> PlotErrBars x1 y1 -> f (PlotErrBars x2 y2)
instance Data.Default.Internal.Default (Graphics.Rendering.Chart.Plot.ErrBars.PlotErrBars x y)
instance (GHC.Internal.Show.Show x, GHC.Internal.Show.Show y) => GHC.Internal.Show.Show (Graphics.Rendering.Chart.Plot.ErrBars.ErrPoint x y)
instance GHC.Internal.Show.Show x => GHC.Internal.Show.Show (Graphics.Rendering.Chart.Plot.ErrBars.ErrValue x)
instance Graphics.Rendering.Chart.Plot.Types.ToPlot Graphics.Rendering.Chart.Plot.ErrBars.PlotErrBars


-- | Candlestick charts for financial plotting
module Graphics.Rendering.Chart.Plot.Candle

-- | Value defining a financial interval: opening and closing prices, with
--   maxima and minima; and a style in which to render them. By convention,
--   there are different fill styles depending on whether the price rises
--   (open &lt; close) or falls (close &lt; open). (This plot type can also
--   be re-purposed for statistical intervals, e.g. minimum, first
--   quartile, median, third quartile, maximum.)
data PlotCandle x y
PlotCandle :: String -> LineStyle -> Bool -> FillStyle -> FillStyle -> Double -> Double -> Double -> [Candle x y] -> PlotCandle x y
[_plot_candle_title] :: PlotCandle x y -> String
[_plot_candle_line_style] :: PlotCandle x y -> LineStyle
[_plot_candle_fill] :: PlotCandle x y -> Bool
[_plot_candle_rise_fill_style] :: PlotCandle x y -> FillStyle
[_plot_candle_fall_fill_style] :: PlotCandle x y -> FillStyle
[_plot_candle_tick_length] :: PlotCandle x y -> Double
[_plot_candle_width] :: PlotCandle x y -> Double
[_plot_candle_centre] :: PlotCandle x y -> Double
[_plot_candle_values] :: PlotCandle x y -> [Candle x y]

-- | A Value holding price intervals for a given x-coord. An alternative
--   view is that these are statistical intervals: the 0th, 25th, 50th,
--   75th, and 100th percentiles.
data Candle x y
Candle :: x -> y -> y -> y -> y -> y -> Candle x y
[candle_x] :: Candle x y -> x
[candle_low] :: Candle x y -> y
[candle_open] :: Candle x y -> y
[candle_mid] :: Candle x y -> y
[candle_close] :: Candle x y -> y
[candle_high] :: Candle x y -> y
plot_candle_title :: forall x y f. Functor f => (String -> f String) -> PlotCandle x y -> f (PlotCandle x y)
plot_candle_line_style :: forall x y f. Functor f => (LineStyle -> f LineStyle) -> PlotCandle x y -> f (PlotCandle x y)
plot_candle_tick_length :: forall x y f. Functor f => (Double -> f Double) -> PlotCandle x y -> f (PlotCandle x y)
plot_candle_width :: forall x y f. Functor f => (Double -> f Double) -> PlotCandle x y -> f (PlotCandle x y)
plot_candle_centre :: forall x y f. Functor f => (Double -> f Double) -> PlotCandle x y -> f (PlotCandle x y)
plot_candle_fill :: forall x y f. Functor f => (Bool -> f Bool) -> PlotCandle x y -> f (PlotCandle x y)
plot_candle_rise_fill_style :: forall x y f. Functor f => (FillStyle -> f FillStyle) -> PlotCandle x y -> f (PlotCandle x y)
plot_candle_fall_fill_style :: forall x y f. Functor f => (FillStyle -> f FillStyle) -> PlotCandle x y -> f (PlotCandle x y)
plot_candle_values :: forall x1 y1 x2 y2 f. Functor f => ([Candle x1 y1] -> f [Candle x2 y2]) -> PlotCandle x1 y1 -> f (PlotCandle x2 y2)
instance Data.Default.Internal.Default (Graphics.Rendering.Chart.Plot.Candle.PlotCandle x y)
instance (GHC.Internal.Show.Show x, GHC.Internal.Show.Show y) => GHC.Internal.Show.Show (Graphics.Rendering.Chart.Plot.Candle.Candle x y)
instance Graphics.Rendering.Chart.Plot.Types.ToPlot Graphics.Rendering.Chart.Plot.Candle.PlotCandle


-- | Non chart specific utility functions.
module Graphics.Rendering.Chart.Utils

-- | Checks if the given value is and actual numeric value and not a
--   concept like NaN or infinity.
isValidNumber :: RealFloat a => a -> Bool

-- | Shorthand for the decimal logarithm
log10 :: Floating a => a -> a

-- | Version of <a>maybe</a> that returns a monadic value.
maybeM :: Monad m => b -> (a -> m b) -> Maybe a -> m b

-- | Specialization to ()
whenJust :: Monad m => Maybe a -> (a -> m ()) -> m ()


-- | This module contains the definition of the <a>Renderable</a> type,
--   which is a composable drawing element, along with assorted functions
--   to them.
module Graphics.Rendering.Chart.Renderable

-- | A Renderable is a record of functions required to layout a graphic
--   element.
data Renderable a
Renderable :: BackendProgram RectSize -> (RectSize -> BackendProgram (PickFn a)) -> Renderable a

-- | Calculate the minimum size of the renderable.
[minsize] :: Renderable a -> BackendProgram RectSize

-- | Draw the renderable with a rectangle, which covers the origin to a
--   given point.
--   
--   The resulting "pick" function maps a point in the image to a value.
[render] :: Renderable a -> RectSize -> BackendProgram (PickFn a)

-- | A type class abtracting the conversion of a value to a Renderable.
class ToRenderable a
toRenderable :: ToRenderable a => a -> Renderable ()

-- | A function that maps a point in device coordinates to some value.
--   
--   Perhaps it might be generalised from Maybe a to (MonadPlus m ) =&gt; m
--   a in the future.
type PickFn a = Point -> Maybe a
data Rectangle
Rectangle :: RectSize -> Maybe FillStyle -> Maybe LineStyle -> RectCornerStyle -> Rectangle
[_rect_minsize] :: Rectangle -> RectSize
[_rect_fillStyle] :: Rectangle -> Maybe FillStyle
[_rect_lineStyle] :: Rectangle -> Maybe LineStyle
[_rect_cornerStyle] :: Rectangle -> RectCornerStyle
data RectCornerStyle
RCornerSquare :: RectCornerStyle
RCornerBevel :: Double -> RectCornerStyle
RCornerRounded :: Double -> RectCornerStyle
rectangleToRenderable :: Rectangle -> Renderable a

-- | Draw the specified rectangle such that its top-left vertex is placed
--   at the given position
drawRectangle :: Point -> Rectangle -> BackendProgram (PickFn a)

-- | Overlay a renderable over a solid background fill.
fillBackground :: FillStyle -> Renderable a -> Renderable a

-- | Add some spacing at the edges of a renderable.
addMargins :: (Double, Double, Double, Double) -> Renderable a -> Renderable a
emptyRenderable :: Renderable a

-- | Helper function for using a renderable, when we generate it in the
--   BackendProgram monad.
embedRenderable :: BackendProgram (Renderable a) -> Renderable a

-- | Construct a renderable from a text string, aligned with the axes.
label :: FontStyle -> HTextAnchor -> VTextAnchor -> String -> Renderable String

-- | Construct a renderable from a text string, rotated wrt to axes. The
--   angle of rotation is in degrees, measured clockwise from the
--   horizontal.
rlabel :: FontStyle -> HTextAnchor -> VTextAnchor -> Double -> String -> Renderable String

-- | Create a blank renderable with a specified minimum size.
spacer :: RectSize -> Renderable a

-- | Create a blank renderable with a minimum size the same as some other
--   renderable.
spacer1 :: Renderable a -> Renderable b

-- | Replace the pick function of a renderable with another.
setPickFn :: PickFn b -> Renderable a -> Renderable b

-- | Map a function over the result of a renderable's pickfunction, keeping
--   only <a>Just</a> results.
mapMaybePickFn :: (a -> Maybe b) -> Renderable a -> Renderable b

-- | Map a function over result of a renderable's pickfunction.
mapPickFn :: (a -> b) -> Renderable a -> Renderable b
nullPickFn :: PickFn a
rect_minsize :: Lens' Rectangle RectSize
rect_fillStyle :: Lens' Rectangle (Maybe FillStyle)
rect_lineStyle :: Lens' Rectangle (Maybe LineStyle)
rect_cornerStyle :: Lens' Rectangle RectCornerStyle
instance Data.Default.Internal.Default Graphics.Rendering.Chart.Renderable.Rectangle
instance GHC.Internal.Base.Functor Graphics.Rendering.Chart.Renderable.Renderable
instance Graphics.Rendering.Chart.Renderable.ToRenderable Graphics.Rendering.Chart.Renderable.Rectangle
instance Graphics.Rendering.Chart.Renderable.ToRenderable (Graphics.Rendering.Chart.Renderable.Renderable a)


-- | Sparklines are mini graphs inspired by Edward Tufte; see
--   <a>http://www.edwardtufte.com/bboard/q-and-a-fetch-msg?msg_id=0001OR</a>
--   and <a>http://en.wikipedia.org/wiki/Sparkline</a> for more
--   information.
--   
--   The original implementation (by Hitesh Jasani) used the gd package as
--   a backend renderer, and is still available at
--   <a>http://hackage.haskell.org/package/hsparklines</a>.
--   
--   The present version integrates with the Chart package, in the sense
--   that Sparklines are just another kind of (<tt>ToRenderable a =&gt;
--   a</tt>), so they can be composed into grids and used with the rest of
--   Chart.
--   
--   <pre>
--   dp :: [Double]
--   dp = [24,21,32.3,24,15,34,43,55,57,72,74,75,73,72,55,44]
--   
--   sl = SparkLine barSpark dp
--   fopts = FileOptions (sparkSize sl) PNG
--   renderableToFile fopts (sparkLineToRenderable sl) "bar_spark.png" 
--   </pre>
module Graphics.Rendering.Chart.SparkLine

-- | A sparkline is a single sequence of data values, treated as y-values.
--   The x-values are anonymous and implicit in the sequence.
data SparkLine
SparkLine :: SparkOptions -> [Double] -> SparkLine
[sl_options] :: SparkLine -> SparkOptions
[sl_data] :: SparkLine -> [Double]

-- | Options to render the sparklines in different ways.
data SparkOptions
SparkOptions :: Bool -> Int -> Int -> (Double, Double) -> Colour Double -> Colour Double -> Colour Double -> Colour Double -> Bool -> Bool -> Bool -> SparkOptions

-- | smooth or bars
[so_smooth] :: SparkOptions -> Bool

-- | step size
[so_step] :: SparkOptions -> Int

-- | graph height (pixels)
[so_height] :: SparkOptions -> Int

-- | data point limits
[so_limits] :: SparkOptions -> (Double, Double)

-- | background color
[so_bgColor] :: SparkOptions -> Colour Double

-- | color of minimum datapoint
[so_minColor] :: SparkOptions -> Colour Double

-- | color of maximum datapoint
[so_maxColor] :: SparkOptions -> Colour Double

-- | color of last datapoint
[so_lastColor] :: SparkOptions -> Colour Double

-- | display minimum marker
[so_minMarker] :: SparkOptions -> Bool

-- | display maximum marker
[so_maxMarker] :: SparkOptions -> Bool

-- | display last marker
[so_lastMarker] :: SparkOptions -> Bool

-- | Default options for a smooth sparkline.
smoothSpark :: SparkOptions

-- | Default options for a barchart sparkline.
barSpark :: SparkOptions

-- | Return the width and height of the SparkLine.
sparkSize :: SparkLine -> (Int, Int)

-- | Render a SparkLine to a drawing surface.
renderSparkLine :: SparkLine -> BackendProgram (PickFn ())

-- | Create a renderable from a SparkLine.
sparkLineToRenderable :: SparkLine -> Renderable ()

-- | Compute the width of a SparkLine, for rendering purposes.
sparkWidth :: SparkLine -> Int
instance GHC.Internal.Show.Show Graphics.Rendering.Chart.SparkLine.SparkOptions
instance Graphics.Rendering.Chart.Renderable.ToRenderable Graphics.Rendering.Chart.SparkLine.SparkLine


-- | Show textual annotations on a chart.
module Graphics.Rendering.Chart.Plot.Annotation

-- | Value for describing a series of text annotations to be placed at
--   arbitrary points on the graph. Annotations can be rotated and styled.
data PlotAnnotation x y
PlotAnnotation :: HTextAnchor -> VTextAnchor -> Double -> FontStyle -> Rectangle -> Vector -> [(x, y, String)] -> PlotAnnotation x y
[_plot_annotation_hanchor] :: PlotAnnotation x y -> HTextAnchor
[_plot_annotation_vanchor] :: PlotAnnotation x y -> VTextAnchor

-- | Angle, in degrees, to rotate the annotation about the anchor point.
[_plot_annotation_angle] :: PlotAnnotation x y -> Double
[_plot_annotation_style] :: PlotAnnotation x y -> FontStyle

-- | Rectangle which style determines the background of the annotation text
--   and which <a>_rect_minsize</a> determines the additional width and
--   height of the background area
[_plot_annotation_background] :: PlotAnnotation x y -> Rectangle
[_plot_annotation_offset] :: PlotAnnotation x y -> Vector
[_plot_annotation_values] :: PlotAnnotation x y -> [(x, y, String)]
plot_annotation_hanchor :: forall x y f. Functor f => (HTextAnchor -> f HTextAnchor) -> PlotAnnotation x y -> f (PlotAnnotation x y)
plot_annotation_vanchor :: forall x y f. Functor f => (VTextAnchor -> f VTextAnchor) -> PlotAnnotation x y -> f (PlotAnnotation x y)
plot_annotation_angle :: forall x y f. Functor f => (Double -> f Double) -> PlotAnnotation x y -> f (PlotAnnotation x y)
plot_annotation_style :: forall x y f. Functor f => (FontStyle -> f FontStyle) -> PlotAnnotation x y -> f (PlotAnnotation x y)
plot_annotation_background :: forall x y f. Functor f => (Rectangle -> f Rectangle) -> PlotAnnotation x y -> f (PlotAnnotation x y)
plot_annotation_offset :: forall x y f. Functor f => (Vector -> f Vector) -> PlotAnnotation x y -> f (PlotAnnotation x y)
plot_annotation_values :: forall x1 y1 x2 y2 f. Functor f => ([(x1, y1, String)] -> f [(x2, y2, String)]) -> PlotAnnotation x1 y1 -> f (PlotAnnotation x2 y2)
instance Data.Default.Internal.Default (Graphics.Rendering.Chart.Plot.Annotation.PlotAnnotation x y)
instance Graphics.Rendering.Chart.Plot.Types.ToPlot Graphics.Rendering.Chart.Plot.Annotation.PlotAnnotation


-- | A container type for values that can be composed by horizonal and
--   vertical layout.
module Graphics.Rendering.Chart.Grid

-- | Abstract datatype representing a grid.
data Grid a
type Span = (Int, Int)

-- | When more space is available for an item than the total width of
--   items, extra added space is proportional to 'space weight'.
type SpaceWeight = (Double, Double)

-- | A 1x1 grid from a given value, with no extra space.
tval :: a -> Grid a

-- | A WxH (measured in cells) grid from a given value, with space weight
--   (1,1).
tspan :: a -> Span -> Grid a

-- | A 1x1 empty grid.
empty :: Grid a

-- | A 0x0 empty grid.
nullt :: Grid a

-- | A synonym for <a>beside</a>.
(.|.) :: Grid a -> Grid a -> Grid a

-- | A synonym for <a>above</a>.
(./.) :: Grid a -> Grid a -> Grid a
above :: Grid a -> Grid a -> Grid a
aboveN :: [Grid a] -> Grid a
beside :: Grid a -> Grid a -> Grid a
besideN :: [Grid a] -> Grid a

-- | One grid over the other. The first argument is shallow, the second is
--   deep.
overlay :: Grid a -> Grid a -> Grid a
width :: Grid a -> Int
height :: Grid a -> Int
gridToRenderable :: Grid (Renderable a) -> Renderable a

-- | Sets the space weight of *every* cell of the grid to given value.
weights :: SpaceWeight -> Grid a -> Grid a

-- | A value placed below the grid, occupying 1 row with the same
--   horizontal span as the grid.
aboveWide :: Grid a -> a -> Grid a

-- | A value occupying 1 row with the same horizontal span as the grid.
wideAbove :: a -> Grid a -> Grid a

-- | A value placed to the left of the grid, occupying 1 column with the
--   same vertical span as the grid.
tallBeside :: a -> Grid a -> Grid a

-- | A value placed to the right of the grid, occupying 1 column with the
--   same vertical span as the grid.
besideTall :: Grid a -> a -> Grid a

-- | A value placed under a grid, with the same span as the grid.
fullOverlayUnder :: a -> Grid a -> Grid a

-- | A value placed over a grid, with the same span as the grid.
fullOverlayOver :: a -> Grid a -> Grid a
instance GHC.Internal.Base.Functor Graphics.Rendering.Chart.Grid.Grid
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Graphics.Rendering.Chart.Grid.Grid a)
instance Graphics.Rendering.Chart.Renderable.ToRenderable a => Graphics.Rendering.Chart.Renderable.ToRenderable (Graphics.Rendering.Chart.Grid.Grid a)


-- | A basic pie chart.
--   
--   Pie charts are handled different to other plots, in that they have
--   their own layout, and can't be composed with other plots. A pie chart
--   is rendered with code in the following form:
--   
--   <pre>
--   values :: [PieItem]
--   values = [...]
--   layout :: PieLayout
--   layout = pie_plot ^: pie_data ^= values
--          $ def
--   renderable = toRenderable layout
--   </pre>
module Graphics.Rendering.Chart.Plot.Pie
data PieLayout
PieLayout :: String -> FontStyle -> PieChart -> FillStyle -> Double -> PieLayout
[_pie_title] :: PieLayout -> String
[_pie_title_style] :: PieLayout -> FontStyle
[_pie_plot] :: PieLayout -> PieChart
[_pie_background] :: PieLayout -> FillStyle
[_pie_margin] :: PieLayout -> Double
data PieChart
PieChart :: [PieItem] -> [AlphaColour Double] -> FontStyle -> LineStyle -> Double -> PieChart
[_pie_data] :: PieChart -> [PieItem]
[_pie_colors] :: PieChart -> [AlphaColour Double]
[_pie_label_style] :: PieChart -> FontStyle
[_pie_label_line_style] :: PieChart -> LineStyle
[_pie_start_angle] :: PieChart -> Double
data PieItem
PieItem :: String -> Double -> Double -> PieItem
[_pitem_label] :: PieItem -> String
[_pitem_offset] :: PieItem -> Double
[_pitem_value] :: PieItem -> Double
pieToRenderable :: PieLayout -> Renderable (PickFn a)
pieChartToRenderable :: PieChart -> Renderable (PickFn a)
pie_title :: Lens' PieLayout String
pie_title_style :: Lens' PieLayout FontStyle
pie_plot :: Lens' PieLayout PieChart
pie_background :: Lens' PieLayout FillStyle
pie_margin :: Lens' PieLayout Double
pie_data :: Lens' PieChart [PieItem]
pie_colors :: Lens' PieChart [AlphaColour Double]
pie_label_style :: Lens' PieChart FontStyle
pie_label_line_style :: Lens' PieChart LineStyle
pie_start_angle :: Lens' PieChart Double
pitem_label :: Lens' PieItem String
pitem_offset :: Lens' PieItem Double
pitem_value :: Lens' PieItem Double
instance Data.Default.Internal.Default Graphics.Rendering.Chart.Plot.Pie.PieChart
instance Data.Default.Internal.Default Graphics.Rendering.Chart.Plot.Pie.PieItem
instance Data.Default.Internal.Default Graphics.Rendering.Chart.Plot.Pie.PieLayout
instance Graphics.Rendering.Chart.Renderable.ToRenderable Graphics.Rendering.Chart.Plot.Pie.PieChart
instance Graphics.Rendering.Chart.Renderable.ToRenderable Graphics.Rendering.Chart.Plot.Pie.PieLayout


-- | Types and functions for handling the legend(s) on a chart. A legend is
--   an area on the chart used to label the plotted values.
module Graphics.Rendering.Chart.Legend
data Legend x y
Legend :: LegendStyle -> [(String, Rect -> BackendProgram ())] -> Legend x y
data LegendStyle
LegendStyle :: FontStyle -> Double -> Double -> LegendOrientation -> LegendPosition -> LegendStyle
[_legend_label_style] :: LegendStyle -> FontStyle
[_legend_margin] :: LegendStyle -> Double
[_legend_plot_size] :: LegendStyle -> Double
[_legend_orientation] :: LegendStyle -> LegendOrientation
[_legend_position] :: LegendStyle -> LegendPosition

-- | Legends can be constructed in two orientations: in rows (where we
--   specify the maximum number of columns), and in columns (where we
--   specify the maximum number of rows)
data LegendOrientation
LORows :: Int -> LegendOrientation
LOCols :: Int -> LegendOrientation

-- | Defines the position of the legend, relative to the plot.
data LegendPosition
LegendAbove :: LegendPosition
LegendBelow :: LegendPosition
LegendRight :: LegendPosition
LegendLeft :: LegendPosition
legendToRenderable :: Legend x y -> Renderable String
legend_label_style :: Lens' LegendStyle FontStyle
legend_margin :: Lens' LegendStyle Double
legend_plot_size :: Lens' LegendStyle Double
legend_orientation :: Lens' LegendStyle LegendOrientation
legend_position :: Lens' LegendStyle LegendPosition
instance Data.Default.Internal.Default Graphics.Rendering.Chart.Legend.LegendStyle
instance Graphics.Rendering.Chart.Renderable.ToRenderable (Graphics.Rendering.Chart.Legend.Legend x y)


-- | Type definitions for Axes
module Graphics.Rendering.Chart.Axis.Types

-- | The basic data associated with an axis showing values of type x.
data AxisData x
AxisData :: AxisVisibility -> (Range -> x -> Double) -> (Range -> Double -> x) -> [(x, Double)] -> [[(x, String)]] -> [x] -> AxisData x

-- | Which parts of the axis shall be displayed.
[_axis_visibility] :: AxisData x -> AxisVisibility

-- | The _axis_viewport function maps values into device coordinates.
[_axis_viewport] :: AxisData x -> Range -> x -> Double

-- | The _axis_tropweiv function maps device coordinates back to values.
[_axis_tropweiv] :: AxisData x -> Range -> Double -> x

-- | The tick marks on the axis as pairs. The first element is the position
--   on the axis (in viewport units) and the second element is the length
--   of the tick in output coordinates. The tick starts on the axis, and
--   positive numbers are drawn towards the plot area.
[_axis_ticks] :: AxisData x -> [(x, Double)]

-- | The labels on an axis as pairs. The first element of the pair is the
--   position on the axis (in viewport units) and the second is the label
--   text string. Note that multiple sets of labels can be specified, and
--   are shown successively further away from the axis line.
[_axis_labels] :: AxisData x -> [[(x, String)]]

-- | The positions on the axis (in viewport units) where we want to show
--   grid lines.
[_axis_grid] :: AxisData x -> [x]

-- | Configures whick visual elements of a axis are shown at the
--   appropriate edge of a plot area.
data AxisVisibility
AxisVisibility :: Bool -> Bool -> Bool -> AxisVisibility

-- | Whether to display a line along the axis.
[_axis_show_line] :: AxisVisibility -> Bool

-- | Whether to display the tick marks.
[_axis_show_ticks] :: AxisVisibility -> Bool

-- | Whether to display the labels.
[_axis_show_labels] :: AxisVisibility -> Bool

-- | Collect the information we need to render an axis. The bool is true if
--   the axis direction is reversed.
data AxisT x
AxisT :: RectEdge -> AxisStyle -> Bool -> AxisData x -> AxisT x

-- | Control values for how an axis gets displayed.
data AxisStyle
AxisStyle :: LineStyle -> FontStyle -> LineStyle -> Double -> AxisStyle

-- | <a>LineStyle</a> to use for axis line and ticks.
[_axis_line_style] :: AxisStyle -> LineStyle

-- | <a>FontStyle</a> to use for axis labels.
[_axis_label_style] :: AxisStyle -> FontStyle

-- | <a>LineStyle</a> to use for axis grid.
[_axis_grid_style] :: AxisStyle -> LineStyle

-- | How far the labels are to be drawn from the axis.
[_axis_label_gap] :: AxisStyle -> Double

-- | A typeclass abstracting the functions we need to be able to plot
--   against an axis of type a
class Ord a => PlotValue a
toValue :: PlotValue a => a -> Double
fromValue :: PlotValue a => Double -> a
autoAxis :: PlotValue a => AxisFn a

-- | A function to generate the axis data, given the data values to be
--   plotted against it.
type AxisFn x = [x] -> AxisData x

-- | The default <a>LineStyle</a> of an axis.
defaultAxisLineStyle :: LineStyle

-- | The default <a>LineStyle</a> of a plot area grid.
defaultGridLineStyle :: LineStyle

-- | Construct an axis given the positions for ticks, grid lines, and
--   labels, and the labelling function
makeAxis :: PlotValue x => ([x] -> [String]) -> ([x], [x], [x]) -> AxisData x

-- | Construct an axis given the positions for ticks, grid lines, and
--   labels, and the positioning and labelling functions
makeAxis' :: Ord x => (x -> Double) -> (Double -> x) -> ([x] -> [String]) -> ([x], [x], [x]) -> AxisData x

-- | Construct a renderable from an axis, in order that it can be composed
--   with other renderables and drawn. This does not include the drawing of
--   the grid, which must be done separately by the <a>renderAxisGrid</a>
--   function.
axisToRenderable :: AxisT x -> Renderable x
renderAxisGrid :: RectSize -> AxisT z -> BackendProgram ()

-- | Calculate the amount by which the labels extend beyond the ends of the
--   axis.
axisOverhang :: Ord x => AxisT x -> BackendProgram (Double, Double)

-- | A linear mapping of points in one range to another.
vmap :: PlotValue x => (x, x) -> Range -> x -> Double

-- | The inverse mapping from device co-ordinate range back to interesting
--   values.
invmap :: PlotValue x => (x, x) -> Range -> Double -> x

-- | A linear mapping of points in one range to another.
linMap :: (a -> Double) -> (a, a) -> Range -> a -> Double

-- | An inverse linear mapping of points from one range to another.
invLinMap :: (Double -> a) -> (a -> Double) -> (a, a) -> Range -> Double -> a

-- | Modifier to position grid lines to line up with the ticks
axisGridAtTicks :: AxisData x -> AxisData x

-- | Modifier to position grid lines to line up with only the major ticks
axisGridAtBigTicks :: AxisData x -> AxisData x

-- | Modifier to position grid lines to line up with the labels
axisGridAtLabels :: AxisData x -> AxisData x

-- | Modifier to remove grid lines from an axis
axisGridHide :: AxisData x -> AxisData x

-- | Modifier to change labels on an axis
axisLabelsOverride :: [(x, String)] -> AxisData x -> AxisData x
axis_show_line :: Lens' AxisVisibility Bool
axis_show_ticks :: Lens' AxisVisibility Bool
axis_show_labels :: Lens' AxisVisibility Bool
axis_visibility :: forall x f. Functor f => (AxisVisibility -> f AxisVisibility) -> AxisData x -> f (AxisData x)
axis_viewport :: forall x f. Functor f => ((Range -> x -> Double) -> f (Range -> x -> Double)) -> AxisData x -> f (AxisData x)
axis_tropweiv :: forall x f. Functor f => ((Range -> Double -> x) -> f (Range -> Double -> x)) -> AxisData x -> f (AxisData x)
axis_ticks :: forall x f. Functor f => ([(x, Double)] -> f [(x, Double)]) -> AxisData x -> f (AxisData x)
axis_labels :: forall x f. Functor f => ([[(x, String)]] -> f [[(x, String)]]) -> AxisData x -> f (AxisData x)
axis_grid :: forall x f. Functor f => ([x] -> f [x]) -> AxisData x -> f (AxisData x)
axis_line_style :: Lens' AxisStyle LineStyle
axis_label_style :: Lens' AxisStyle FontStyle
axis_grid_style :: Lens' AxisStyle LineStyle
axis_label_gap :: Lens' AxisStyle Double
instance Data.Default.Internal.Default Graphics.Rendering.Chart.Axis.Types.AxisStyle
instance Data.Default.Internal.Default Graphics.Rendering.Chart.Axis.Types.AxisVisibility


-- | Calculate and render unit indexed axes
module Graphics.Rendering.Chart.Axis.Unit
unitAxis :: AxisData ()
instance Graphics.Rendering.Chart.Axis.Types.PlotValue ()


-- | Calculate and render time axes
module Graphics.Rendering.Chart.Axis.Time

-- | TimeSeq is a (potentially infinite) set of times. When passed a
--   reference time, the function returns a a pair of lists. The first
--   contains all times in the set less than the reference time in
--   decreasing order. The second contains all times in the set greater
--   than or equal to the reference time, in increasing order.
type TimeSeq = UTCTime -> ([UTCTime], [UTCTime])

-- | How to display a time
type TimeLabelFn = UTCTime -> String
data TimeLabelAlignment
UnderTicks :: TimeLabelAlignment
BetweenTicks :: TimeLabelAlignment

-- | A typeclass abstracting the functions we need to be able to plot
--   against an axis of time type <tt>d</tt>.
class TimeValue t
utctimeFromTV :: TimeValue t => t -> UTCTime
tvFromUTCTime :: TimeValue t => UTCTime -> t
doubleFromTimeValue :: TimeValue t => t -> Double
timeValueFromDouble :: TimeValue t => Double -> t

-- | Create an <a>AxisFn</a> to for a time axis.
--   
--   The values to be plotted against this axis can be created with
--   <tt>doubleFromLocalTime</tt>.
--   
--   Implementation detail: <a>PlotValue</a> constraint is needed to use
--   <a>vmap</a>.
timeValueAxis :: TimeValue t => TimeSeq -> TimeSeq -> TimeLabelFn -> TimeLabelAlignment -> TimeSeq -> TimeLabelFn -> TimeLabelAlignment -> AxisFn t

-- | Automatically choose a suitable time axis, based upon the time range
--   of data. The values to be plotted against this axis can be created
--   with <a>doubleFromTimeValue</a>.
autoTimeValueAxis :: TimeValue t => AxisFn t

-- | A <a>TimeSeq</a> for calendar days.
days :: TimeSeq

-- | A <a>TimeSeq</a> for calendar months.
months :: TimeSeq

-- | A <a>TimeSeq</a> for calendar years.
years :: TimeSeq
instance Graphics.Rendering.Chart.Axis.Types.PlotValue Data.Time.Calendar.Days.Day
instance Graphics.Rendering.Chart.Axis.Types.PlotValue Data.Time.LocalTime.Internal.LocalTime.LocalTime
instance Graphics.Rendering.Chart.Axis.Types.PlotValue Data.Time.Clock.Internal.UTCTime.UTCTime
instance GHC.Internal.Show.Show Graphics.Rendering.Chart.Axis.Time.TimeLabelAlignment
instance Graphics.Rendering.Chart.Axis.Time.TimeValue Data.Time.Calendar.Days.Day
instance Graphics.Rendering.Chart.Axis.Time.TimeValue Data.Time.LocalTime.Internal.LocalTime.LocalTime
instance Graphics.Rendering.Chart.Axis.Time.TimeValue Data.Time.Clock.Internal.UTCTime.UTCTime


-- | Calculate and render time axes

-- | <i>Deprecated: Use Graphics.Rendering.Chart.Axis.Time module</i>
module Graphics.Rendering.Chart.Axis.LocalTime

-- | TimeSeq is a (potentially infinite) set of times. When passed a
--   reference time, the function returns a a pair of lists. The first
--   contains all times in the set less than the reference time in
--   decreasing order. The second contains all times in the set greater
--   than or equal to the reference time, in increasing order.
type TimeSeq = LocalTime -> ([LocalTime], [LocalTime])

-- | How to display a time
type TimeLabelFn = LocalTime -> String
data TimeLabelAlignment
UnderTicks :: TimeLabelAlignment
BetweenTicks :: TimeLabelAlignment

-- | Create an <a>AxisFn</a> to for a time axis.
--   
--   The values to be plotted against this axis can be created with
--   <a>doubleFromLocalTime</a>.
timeAxis :: TimeSeq -> TimeSeq -> TimeLabelFn -> TimeLabelAlignment -> TimeSeq -> TimeLabelFn -> TimeLabelAlignment -> AxisFn LocalTime

-- | Automatically choose a suitable time axis, based upon the time range
--   of data. The values to be plotted against this axis can be created
--   with <a>doubleFromLocalTime</a>.
autoTimeAxis :: AxisFn LocalTime

-- | A <a>TimeSeq</a> for calendar days.
days :: TimeSeq

-- | A <a>TimeSeq</a> for calendar months.
months :: TimeSeq

-- | A <a>TimeSeq</a> for calendar years.
years :: TimeSeq

-- | Map a LocalTime value to a plot coordinate.
doubleFromLocalTime :: LocalTime -> Double
instance GHC.Internal.Show.Show Graphics.Rendering.Chart.Axis.LocalTime.TimeLabelAlignment


-- | Calculate and render indexed axes
module Graphics.Rendering.Chart.Axis.Indexed

-- | Type for capturing values plotted by index number (ie position in a
--   list) rather than a numerical value.
newtype PlotIndex
PlotIndex :: Int -> PlotIndex
[plotindex_i] :: PlotIndex -> Int

-- | Create an axis for values indexed by position. The list of strings are
--   the labels to be used.
autoIndexAxis' :: Integral i => Bool -> [String] -> AxisFn i
autoIndexAxis :: Integral i => [String] -> AxisFn i

-- | Augment a list of values with index numbers for plotting.
addIndexes :: [a] -> [(PlotIndex, a)]
instance GHC.Internal.Enum.Enum Graphics.Rendering.Chart.Axis.Indexed.PlotIndex
instance GHC.Classes.Eq Graphics.Rendering.Chart.Axis.Indexed.PlotIndex
instance GHC.Internal.Real.Integral Graphics.Rendering.Chart.Axis.Indexed.PlotIndex
instance GHC.Internal.Num.Num Graphics.Rendering.Chart.Axis.Indexed.PlotIndex
instance GHC.Classes.Ord Graphics.Rendering.Chart.Axis.Indexed.PlotIndex
instance Graphics.Rendering.Chart.Axis.Types.PlotValue Graphics.Rendering.Chart.Axis.Indexed.PlotIndex
instance GHC.Internal.Real.Real Graphics.Rendering.Chart.Axis.Indexed.PlotIndex
instance GHC.Internal.Show.Show Graphics.Rendering.Chart.Axis.Indexed.PlotIndex


-- | Calculate and render floating value axes including doubles with
--   linear, log, and percentage scaling.
module Graphics.Rendering.Chart.Axis.Floating

-- | A wrapper class for doubles used to indicate they are to be plotted
--   against a percentage axis.
newtype Percent
Percent :: Double -> Percent
[unPercent] :: Percent -> Double
data LinearAxisParams a
LinearAxisParams :: ([a] -> [String]) -> Int -> Int -> LinearAxisParams a

-- | The function used to show the axes labels.
[_la_labelf] :: LinearAxisParams a -> [a] -> [String]

-- | The target number of labels to be shown.
[_la_nLabels] :: LinearAxisParams a -> Int

-- | The target number of ticks to be shown.
[_la_nTicks] :: LinearAxisParams a -> Int

-- | A wrapper class for doubles used to indicate they are to be plotted
--   against a log axis.
newtype LogValue
LogValue :: Double -> LogValue
[unLogValue] :: LogValue -> Double
data LogAxisParams a
LogAxisParams :: ([a] -> [String]) -> LogAxisParams a

-- | The function used to show the axes labels.
[_loga_labelf] :: LogAxisParams a -> [a] -> [String]

-- | Generate a linear axis with the specified bounds
scaledAxis :: RealFloat a => LinearAxisParams a -> (a, a) -> AxisFn a

-- | Generate a linear axis automatically, scaled appropriately for the
--   input data.
autoScaledAxis :: RealFloat a => LinearAxisParams a -> AxisFn a

-- | Generate a log axis automatically, scaled appropriately for the input
--   data.
autoScaledLogAxis :: RealFloat a => LogAxisParams a -> AxisFn a

-- | Given a target number of values, and a list of input points, find
--   evenly spaced values from the set {1*X, 2*X, 2.5*X, 5*X} (where X is
--   some power of ten) that evenly cover the input points.
autoSteps :: Int -> [Double] -> [Double]
la_labelf :: forall a1 a2 f. Functor f => (([a1] -> [String]) -> f ([a2] -> [String])) -> LinearAxisParams a1 -> f (LinearAxisParams a2)
la_nLabels :: forall a f. Functor f => (Int -> f Int) -> LinearAxisParams a -> f (LinearAxisParams a)
la_nTicks :: forall a f. Functor f => (Int -> f Int) -> LinearAxisParams a -> f (LinearAxisParams a)
loga_labelf :: forall a1 a2 p f. (Profunctor p, Functor f) => p ([a1] -> [String]) (f ([a2] -> [String])) -> p (LogAxisParams a1) (f (LogAxisParams a2))
instance (GHC.Internal.Show.Show a, GHC.Internal.Float.RealFloat a) => Data.Default.Internal.Default (Graphics.Rendering.Chart.Axis.Floating.LinearAxisParams a)
instance (GHC.Internal.Show.Show a, GHC.Internal.Float.RealFloat a) => Data.Default.Internal.Default (Graphics.Rendering.Chart.Axis.Floating.LogAxisParams a)
instance GHC.Classes.Eq Graphics.Rendering.Chart.Axis.Floating.LogValue
instance GHC.Classes.Eq Graphics.Rendering.Chart.Axis.Floating.Percent
instance GHC.Internal.Float.Floating Graphics.Rendering.Chart.Axis.Floating.LogValue
instance GHC.Internal.Float.Floating Graphics.Rendering.Chart.Axis.Floating.Percent
instance GHC.Internal.Real.Fractional Graphics.Rendering.Chart.Axis.Floating.LogValue
instance GHC.Internal.Real.Fractional Graphics.Rendering.Chart.Axis.Floating.Percent
instance GHC.Internal.Num.Num Graphics.Rendering.Chart.Axis.Floating.LogValue
instance GHC.Internal.Num.Num Graphics.Rendering.Chart.Axis.Floating.Percent
instance GHC.Classes.Ord Graphics.Rendering.Chart.Axis.Floating.LogValue
instance GHC.Classes.Ord Graphics.Rendering.Chart.Axis.Floating.Percent
instance Graphics.Rendering.Chart.Axis.Types.PlotValue GHC.Types.Double
instance Graphics.Rendering.Chart.Axis.Types.PlotValue GHC.Types.Float
instance Graphics.Rendering.Chart.Axis.Types.PlotValue Graphics.Rendering.Chart.Axis.Floating.LogValue
instance Graphics.Rendering.Chart.Axis.Types.PlotValue Graphics.Rendering.Chart.Axis.Floating.Percent
instance GHC.Internal.Float.RealFloat Graphics.Rendering.Chart.Axis.Floating.LogValue
instance GHC.Internal.Float.RealFloat Graphics.Rendering.Chart.Axis.Floating.Percent
instance GHC.Internal.Real.RealFrac Graphics.Rendering.Chart.Axis.Floating.LogValue
instance GHC.Internal.Real.RealFrac Graphics.Rendering.Chart.Axis.Floating.Percent
instance GHC.Internal.Real.Real Graphics.Rendering.Chart.Axis.Floating.LogValue
instance GHC.Internal.Real.Real Graphics.Rendering.Chart.Axis.Floating.Percent
instance GHC.Internal.Show.Show Graphics.Rendering.Chart.Axis.Floating.LogValue
instance GHC.Internal.Show.Show Graphics.Rendering.Chart.Axis.Floating.Percent


-- | Calculate and render integer indexed axes
module Graphics.Rendering.Chart.Axis.Int
defaultIntAxis :: Show a => LinearAxisParams a
scaledIntAxis :: (Integral i, PlotValue i) => LinearAxisParams i -> (i, i) -> AxisFn i
autoScaledIntAxis :: (Integral i, PlotValue i) => LinearAxisParams i -> AxisFn i
instance Graphics.Rendering.Chart.Axis.Types.PlotValue GHC.Types.Int
instance Graphics.Rendering.Chart.Axis.Types.PlotValue GHC.Internal.Int.Int16
instance Graphics.Rendering.Chart.Axis.Types.PlotValue GHC.Internal.Int.Int32
instance Graphics.Rendering.Chart.Axis.Types.PlotValue GHC.Internal.Int.Int64
instance Graphics.Rendering.Chart.Axis.Types.PlotValue GHC.Internal.Int.Int8
instance Graphics.Rendering.Chart.Axis.Types.PlotValue GHC.Num.Integer.Integer
instance Graphics.Rendering.Chart.Axis.Types.PlotValue GHC.Types.Word
instance Graphics.Rendering.Chart.Axis.Types.PlotValue GHC.Internal.Word.Word16
instance Graphics.Rendering.Chart.Axis.Types.PlotValue GHC.Internal.Word.Word32
instance Graphics.Rendering.Chart.Axis.Types.PlotValue GHC.Internal.Word.Word64
instance Graphics.Rendering.Chart.Axis.Types.PlotValue GHC.Internal.Word.Word8


-- | Code to calculate and render axes.
module Graphics.Rendering.Chart.Axis


-- | Vector plots
module Graphics.Rendering.Chart.Plot.Vectors
data PlotVectors x y
PlotVectors :: String -> VectorStyle -> Double -> [(x, y)] -> ((x, y) -> (x, y)) -> [((x, y), (x, y))] -> PlotVectors x y
[_plot_vectors_title] :: PlotVectors x y -> String
[_plot_vectors_style] :: PlotVectors x y -> VectorStyle

-- | Set to 1 (default) to normalize the length of vectors to a space
--   between them (so that the vectors never overlap on the graph). Set to
--   0 to disable any scaling. Values in between 0 and 1 are also permitted
--   to adjust scaling.
[_plot_vectors_scale] :: PlotVectors x y -> Double

-- | Provide a square-tiled regular grid.
[_plot_vectors_grid] :: PlotVectors x y -> [(x, y)]

-- | Provide a vector field (R^2 -&gt; R^2) function.
[_plot_vectors_mapf] :: PlotVectors x y -> (x, y) -> (x, y)

-- | Provide a prepared list of (start,vector) pairs.
[_plot_vectors_values] :: PlotVectors x y -> [((x, y), (x, y))]
data VectorStyle
VectorStyle :: LineStyle -> PointStyle -> VectorStyle
[_vector_line_style] :: VectorStyle -> LineStyle
[_vector_head_style] :: VectorStyle -> PointStyle
plotVectorField :: (PlotValue x, PlotValue y) => PlotVectors x y -> Plot x y
plot_vectors_mapf :: forall x y f. Functor f => (((x, y) -> (x, y)) -> f ((x, y) -> (x, y))) -> PlotVectors x y -> f (PlotVectors x y)
plot_vectors_grid :: forall x y f. Functor f => ([(x, y)] -> f [(x, y)]) -> PlotVectors x y -> f (PlotVectors x y)
plot_vectors_title :: forall x y f. Functor f => (String -> f String) -> PlotVectors x y -> f (PlotVectors x y)
plot_vectors_style :: forall x y f. Functor f => (VectorStyle -> f VectorStyle) -> PlotVectors x y -> f (PlotVectors x y)
plot_vectors_scale :: forall x y f. Functor f => (Double -> f Double) -> PlotVectors x y -> f (PlotVectors x y)
plot_vectors_values :: forall x y f. Functor f => ([((x, y), (x, y))] -> f [((x, y), (x, y))]) -> PlotVectors x y -> f (PlotVectors x y)
vector_line_style :: Lens' VectorStyle LineStyle
vector_head_style :: Lens' VectorStyle PointStyle
instance Data.Default.Internal.Default (Graphics.Rendering.Chart.Plot.Vectors.PlotVectors x y)
instance Data.Default.Internal.Default Graphics.Rendering.Chart.Plot.Vectors.VectorStyle


-- | Bar Charts
module Graphics.Rendering.Chart.Plot.Bars
data PlotBars x y
PlotBars :: BarsSettings -> [String] -> [(x, [(y, String)])] -> PlotBars x y
[_plot_bars_settings] :: PlotBars x y -> BarsSettings

-- | The title of each element of [y]. These will be shown in the legend.
[_plot_bars_titles] :: PlotBars x y -> [String]

-- | The actual points to be plotted, and their labels
[_plot_bars_values_with_labels] :: PlotBars x y -> [(x, [(y, String)])]
data PlotBarsStyle

-- | Bars for a fixed x are stacked vertically on top of each other.
BarsStacked :: PlotBarsStyle

-- | Bars for a fixed x are put horizontally beside each other.
BarsClustered :: PlotBarsStyle
data PlotBarsSpacing

-- | All bars have the same width in pixels.
BarsFixWidth :: Double -> PlotBarsSpacing

-- | (BarsFixGap g mw) means make the gaps between the bars equal to g, but
--   with a minimum bar width of mw
BarsFixGap :: Double -> Double -> PlotBarsSpacing

-- | How bars for a given (x,[y]) are aligned with respect to screen
--   coordinate corresponding to x (deviceX).
data PlotBarsAlignment

-- | The left edge of bars is at deviceX
BarsLeft :: PlotBarsAlignment

-- | Bars are centered around deviceX
BarsCentered :: PlotBarsAlignment

-- | The right edge of bars is at deviceX
BarsRight :: PlotBarsAlignment
class PlotValue a => BarsPlotValue a
barsIsNull :: BarsPlotValue a => a -> Bool

-- | The starting level for the chart, a function of some statistic
--   (normally the lowest value or just const 0).
barsReference :: BarsPlotValue a => [a] -> a
barsAdd :: BarsPlotValue a => a -> a -> a
data BarHorizAnchor
BHA_Left :: BarHorizAnchor
BHA_Centre :: BarHorizAnchor
BHA_Right :: BarHorizAnchor
data BarVertAnchor
BVA_Bottom :: BarVertAnchor
BVA_Centre :: BarVertAnchor
BVA_Top :: BarVertAnchor
plotBars :: BarsPlotValue y => PlotBars x y -> Plot x y
plotHBars :: BarsPlotValue x => PlotBars y x -> Plot x y
plot_bars_style :: forall x y f. Functor f => (PlotBarsStyle -> f PlotBarsStyle) -> PlotBars x y -> f (PlotBars x y)
plot_bars_item_styles :: forall x y f. Functor f => ([(FillStyle, Maybe LineStyle)] -> f [(FillStyle, Maybe LineStyle)]) -> PlotBars x y -> f (PlotBars x y)
plot_bars_titles :: forall x y f. Functor f => ([String] -> f [String]) -> PlotBars x y -> f (PlotBars x y)
plot_bars_spacing :: forall x y f. Functor f => (PlotBarsSpacing -> f PlotBarsSpacing) -> PlotBars x y -> f (PlotBars x y)
plot_bars_alignment :: forall x y f. Functor f => (PlotBarsAlignment -> f PlotBarsAlignment) -> PlotBars x y -> f (PlotBars x y)
plot_bars_singleton_width :: forall x y f. Functor f => (Double -> f Double) -> PlotBars x y -> f (PlotBars x y)
plot_bars_label_bar_hanchor :: forall x y f. Functor f => (BarHorizAnchor -> f BarHorizAnchor) -> PlotBars x y -> f (PlotBars x y)
plot_bars_label_bar_vanchor :: forall x y f. Functor f => (BarVertAnchor -> f BarVertAnchor) -> PlotBars x y -> f (PlotBars x y)
plot_bars_label_text_hanchor :: forall x y f. Functor f => (HTextAnchor -> f HTextAnchor) -> PlotBars x y -> f (PlotBars x y)
plot_bars_label_text_vanchor :: forall x y f. Functor f => (VTextAnchor -> f VTextAnchor) -> PlotBars x y -> f (PlotBars x y)
plot_bars_label_angle :: forall x y f. Functor f => (Double -> f Double) -> PlotBars x y -> f (PlotBars x y)
plot_bars_label_style :: forall x y f. Functor f => (FontStyle -> f FontStyle) -> PlotBars x y -> f (PlotBars x y)
plot_bars_label_offset :: forall x y f. Functor f => (Vector -> f Vector) -> PlotBars x y -> f (PlotBars x y)
plot_bars_values :: forall x y f. Functor f => ([(x, [y])] -> f [(x, [y])]) -> PlotBars x y -> f (PlotBars x y)
plot_bars_settings :: forall x y f. Functor f => (BarsSettings -> f BarsSettings) -> PlotBars x y -> f (PlotBars x y)
plot_bars_values_with_labels :: forall x1 y1 x2 y2 f. Functor f => ([(x1, [(y1, String)])] -> f [(x2, [(y2, String)])]) -> PlotBars x1 y1 -> f (PlotBars x2 y2)
addLabels :: Show y => [(x, [y])] -> [(x, [(y, String)])]
instance Graphics.Rendering.Chart.Plot.Bars.BarsPlotValue GHC.Types.Double
instance Graphics.Rendering.Chart.Plot.Bars.BarsPlotValue GHC.Types.Int
instance Graphics.Rendering.Chart.Plot.Bars.BarsPlotValue Graphics.Rendering.Chart.Axis.Floating.LogValue
instance Data.Default.Internal.Default Graphics.Rendering.Chart.Plot.Bars.BarsSettings
instance Data.Default.Internal.Default (Graphics.Rendering.Chart.Plot.Bars.PlotBars x y)
instance GHC.Internal.Show.Show Graphics.Rendering.Chart.Plot.Bars.BarHorizAnchor
instance GHC.Internal.Show.Show Graphics.Rendering.Chart.Plot.Bars.BarVertAnchor
instance GHC.Internal.Show.Show Graphics.Rendering.Chart.Plot.Bars.PlotBarsAlignment
instance GHC.Internal.Show.Show Graphics.Rendering.Chart.Plot.Bars.PlotBarsSpacing
instance GHC.Internal.Show.Show Graphics.Rendering.Chart.Plot.Bars.PlotBarsStyle


-- | Area spots are a collection of unconnected filled circles, with x,y
--   position, and an independent z value to be represented by the relative
--   area of the spots.
module Graphics.Rendering.Chart.Plot.AreaSpots

-- | A collection of unconnected spots, with x,y position, and an
--   independent z value to be represented by the area of the spot.
data AreaSpots z x y
AreaSpots :: String -> Double -> AlphaColour Double -> Colour Double -> Double -> Double -> [(x, y, z)] -> AreaSpots z x y
[_area_spots_title] :: AreaSpots z x y -> String
[_area_spots_linethick] :: AreaSpots z x y -> Double
[_area_spots_linecolour] :: AreaSpots z x y -> AlphaColour Double
[_area_spots_fillcolour] :: AreaSpots z x y -> Colour Double
[_area_spots_opacity] :: AreaSpots z x y -> Double

-- | the largest size of spot
[_area_spots_max_radius] :: AreaSpots z x y -> Double
[_area_spots_values] :: AreaSpots z x y -> [(x, y, z)]
area_spots_title :: forall z x y f. Functor f => (String -> f String) -> AreaSpots z x y -> f (AreaSpots z x y)
area_spots_linethick :: forall z x y f. Functor f => (Double -> f Double) -> AreaSpots z x y -> f (AreaSpots z x y)
area_spots_linecolour :: forall z x y f. Functor f => (AlphaColour Double -> f (AlphaColour Double)) -> AreaSpots z x y -> f (AreaSpots z x y)
area_spots_fillcolour :: forall z x y f. Functor f => (Colour Double -> f (Colour Double)) -> AreaSpots z x y -> f (AreaSpots z x y)
area_spots_opacity :: forall z x y f. Functor f => (Double -> f Double) -> AreaSpots z x y -> f (AreaSpots z x y)
area_spots_max_radius :: forall z x y f. Functor f => (Double -> f Double) -> AreaSpots z x y -> f (AreaSpots z x y)
area_spots_values :: forall z1 x1 y1 z2 x2 y2 f. Functor f => ([(x1, y1, z1)] -> f [(x2, y2, z2)]) -> AreaSpots z1 x1 y1 -> f (AreaSpots z2 x2 y2)

-- | A collection of unconnected spots, with x,y position, an independent z
--   value to be represented by the area of the spot, and in addition, a
--   fourth variable t to be represented by a colour from a given palette.
--   (A linear transfer function from t to palette is assumed.)
data AreaSpots4D z t x y
AreaSpots4D :: String -> Double -> [Colour Double] -> Double -> Double -> [(x, y, z, t)] -> AreaSpots4D z t x y
[_area_spots_4d_title] :: AreaSpots4D z t x y -> String
[_area_spots_4d_linethick] :: AreaSpots4D z t x y -> Double
[_area_spots_4d_palette] :: AreaSpots4D z t x y -> [Colour Double]
[_area_spots_4d_opacity] :: AreaSpots4D z t x y -> Double

-- | the largest size of spot
[_area_spots_4d_max_radius] :: AreaSpots4D z t x y -> Double
[_area_spots_4d_values] :: AreaSpots4D z t x y -> [(x, y, z, t)]
area_spots_4d_title :: forall z t x y f. Functor f => (String -> f String) -> AreaSpots4D z t x y -> f (AreaSpots4D z t x y)
area_spots_4d_linethick :: forall z t x y f. Functor f => (Double -> f Double) -> AreaSpots4D z t x y -> f (AreaSpots4D z t x y)
area_spots_4d_palette :: forall z t x y f. Functor f => ([Colour Double] -> f [Colour Double]) -> AreaSpots4D z t x y -> f (AreaSpots4D z t x y)
area_spots_4d_opacity :: forall z t x y f. Functor f => (Double -> f Double) -> AreaSpots4D z t x y -> f (AreaSpots4D z t x y)
area_spots_4d_max_radius :: forall z t x y f. Functor f => (Double -> f Double) -> AreaSpots4D z t x y -> f (AreaSpots4D z t x y)
area_spots_4d_values :: forall z1 t1 x1 y1 z2 t2 x2 y2 f. Functor f => ([(x1, y1, z1, t1)] -> f [(x2, y2, z2, t2)]) -> AreaSpots4D z1 t1 x1 y1 -> f (AreaSpots4D z2 t2 x2 y2)
instance Data.Default.Internal.Default (Graphics.Rendering.Chart.Plot.AreaSpots.AreaSpots z x y)
instance Data.Default.Internal.Default (Graphics.Rendering.Chart.Plot.AreaSpots.AreaSpots4D z t x y)
instance Graphics.Rendering.Chart.Axis.Types.PlotValue z => Graphics.Rendering.Chart.Plot.Types.ToPlot (Graphics.Rendering.Chart.Plot.AreaSpots.AreaSpots z)
instance (Graphics.Rendering.Chart.Axis.Types.PlotValue z, Graphics.Rendering.Chart.Axis.Types.PlotValue t, GHC.Internal.Show.Show t) => Graphics.Rendering.Chart.Plot.Types.ToPlot (Graphics.Rendering.Chart.Plot.AreaSpots.AreaSpots4D z t)

module Numeric.Histogram
type Range a = (a, a)

-- | 'binBounds a b n' generates bounds for <tt>n</tt> bins spaced linearly
--   between <tt>a</tt> and <tt>b</tt>
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; binBounds 0 3 4
--   [(0.0,0.75),(0.75,1.5),(1.5,2.25),(2.25,3.0)]
--   </pre>
binBounds :: RealFrac a => a -> a -> Int -> [Range a]

-- | 'histValues a b n vs' returns the bins for the histogram of
--   <tt>vs</tt> on the range from <tt>a</tt> to <tt>b</tt> with <tt>n</tt>
--   bins
histValues :: RealFrac a => a -> a -> Int -> [a] -> Vector (Range a, Int)

-- | 'histValues a b n vs' returns the bins for the weighted histogram of
--   <tt>vs</tt> on the range from <tt>a</tt> to <tt>b</tt> with <tt>n</tt>
--   bins
histWeightedValues :: RealFrac a => a -> a -> Int -> [(Double, a)] -> Vector (Range a, Double)

-- | 'histWithBins bins xs' is the histogram of weighted values <tt>xs</tt>
--   with <tt>bins</tt>
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   histWithBins
--       (V.fromList [(0.0, 0.75), (0.75, 1.5), (1.5, 2.25), (2.25, 3.0)])
--       [(1, 0), (1, 0), (1, 1), (1, 2), (1, 2), (1, 2), (1, 3)]
--   :}
--   [((0.0,0.75),2),((0.75,1.5),1),((1.5,2.25),3),((2.25,3.0),1)]
--   </pre>
histWithBins :: (Num w, RealFrac a) => Vector (Range a) -> [(w, a)] -> Vector (Range a, w)

module Graphics.Rendering.Chart.Plot.Histogram
data PlotHist x y
PlotHist :: String -> Int -> [x] -> Bool -> Maybe (x, x) -> Bool -> FillStyle -> LineStyle -> (Double -> Int -> y) -> PlotHist x y

-- | Plot title
[_plot_hist_title] :: PlotHist x y -> String

-- | Number of bins
[_plot_hist_bins] :: PlotHist x y -> Int

-- | Values to histogram
[_plot_hist_values] :: PlotHist x y -> [x]

-- | Don't attempt to plot bins with zero counts. Useful when the y-axis is
--   logarithmically scaled.
[_plot_hist_no_zeros] :: PlotHist x y -> Bool

-- | Override the range of the histogram. If <tt>Nothing</tt> the range of
--   <tt>_plot_hist_values</tt> is used.
--   
--   Note that any normalization is always computed over the full data set,
--   including samples not falling in the histogram range.
[_plot_hist_range] :: PlotHist x y -> Maybe (x, x)

-- | Plot vertical lines between bins
[_plot_hist_drop_lines] :: PlotHist x y -> Bool

-- | Fill style of the bins
[_plot_hist_fill_style] :: PlotHist x y -> FillStyle

-- | Line style of the bin outlines
[_plot_hist_line_style] :: PlotHist x y -> LineStyle

-- | Normalization function
[_plot_hist_norm_func] :: PlotHist x y -> Double -> Int -> y

-- | Convert a <tt>PlotHist</tt> to a <tt>Plot</tt>
--   
--   N.B. In principle this should be Chart's <tt>ToPlot</tt> class but
--   unfortunately this does not allow us to set bounds on the x and y axis
--   types, hence the need for this function.
histToPlot :: (RealFrac x, Num y, Ord y) => PlotHist x y -> Plot x y

-- | The default style is an unnormalized histogram of 20 bins.
defaultPlotHist :: PlotHist x Int

-- | <tt>defaultPlotHist</tt> but with real counts
defaultFloatPlotHist :: PlotHist x Double

-- | <tt>defaultPlotHist</tt> but normalized such that the integral of the
--   histogram is one.
defaultNormedPlotHist :: PlotHist x Double

-- | Obtain the bin dimensions of a given <tt>PlotHist</tt>.
histToBins :: (RealFrac x, Num y, Ord y) => PlotHist x y -> [((x, x), y)]
plot_hist_title :: forall x y f. Functor f => (String -> f String) -> PlotHist x y -> f (PlotHist x y)
plot_hist_bins :: forall x y f. Functor f => (Int -> f Int) -> PlotHist x y -> f (PlotHist x y)
plot_hist_values :: forall x y f. Functor f => ([x] -> f [x]) -> PlotHist x y -> f (PlotHist x y)
plot_hist_no_zeros :: forall x y f. Functor f => (Bool -> f Bool) -> PlotHist x y -> f (PlotHist x y)
plot_hist_range :: forall x y f. Functor f => (Maybe (x, x) -> f (Maybe (x, x))) -> PlotHist x y -> f (PlotHist x y)
plot_hist_drop_lines :: forall x y f. Functor f => (Bool -> f Bool) -> PlotHist x y -> f (PlotHist x y)
plot_hist_line_style :: forall x y f. Functor f => (LineStyle -> f LineStyle) -> PlotHist x y -> f (PlotHist x y)
plot_hist_fill_style :: forall x y f. Functor f => (FillStyle -> f FillStyle) -> PlotHist x y -> f (PlotHist x y)
plot_hist_norm_func :: forall x y1 y2 f. Functor f => ((Double -> Int -> y1) -> f (Double -> Int -> y2)) -> PlotHist x y1 -> f (PlotHist x y2)
instance Data.Default.Internal.Default (Graphics.Rendering.Chart.Plot.Histogram.PlotHist x GHC.Types.Int)


-- | Code to calculate and render various types of plots.
module Graphics.Rendering.Chart.Plot


-- | This module glues together axes and plots to actually create a
--   renderable for a chart.
--   
--   Note that Template haskell is used to derive accessor functions (see
--   <a>Lens</a>) for each field of the following data types:
--   
--   <ul>
--   <li><a>Layout</a></li>
--   <li><a>LayoutLR</a></li>
--   <li><a>StackedLayouts</a></li>
--   <li><a>LayoutAxis</a></li>
--   </ul>
module Graphics.Rendering.Chart.Layout

-- | A Layout value is a single plot area, with single x and y axis. The
--   title is at the top and the legend at the bottom. It's parametrized by
--   the types of values to be plotted on the x and y axes.
data Layout x y
Layout :: FillStyle -> Maybe FillStyle -> String -> FontStyle -> LayoutAxis x -> AxisVisibility -> AxisVisibility -> LayoutAxis y -> AxisVisibility -> AxisVisibility -> [Plot x y] -> Maybe LegendStyle -> Double -> Bool -> Layout x y

-- | How to fill the background of everything.
[_layout_background] :: Layout x y -> FillStyle

-- | How to fill the background of the plot, if different from the overall
--   background.
[_layout_plot_background] :: Layout x y -> Maybe FillStyle

-- | Title to display above the chart.
[_layout_title] :: Layout x y -> String

-- | Font style to use for the title.
[_layout_title_style] :: Layout x y -> FontStyle

-- | Rules to generate the x axis.
[_layout_x_axis] :: Layout x y -> LayoutAxis x

-- | Visibility options for the top axis.
[_layout_top_axis_visibility] :: Layout x y -> AxisVisibility

-- | Visibility options for the bottom axis.
[_layout_bottom_axis_visibility] :: Layout x y -> AxisVisibility

-- | Rules to generate the y axis.
[_layout_y_axis] :: Layout x y -> LayoutAxis y

-- | Visibility options for the left axis.
[_layout_left_axis_visibility] :: Layout x y -> AxisVisibility

-- | Visibility options for the right axis.
[_layout_right_axis_visibility] :: Layout x y -> AxisVisibility

-- | The data sets to plot in the chart. They are plotted over each other.
[_layout_plots] :: Layout x y -> [Plot x y]

-- | How to style the legend.
[_layout_legend] :: Layout x y -> Maybe LegendStyle

-- | The margin distance to use.
[_layout_margin] :: Layout x y -> Double

-- | If the grid shall be rendered beneath (<tt>False</tt>) or over
--   (<tt>True</tt>) all plots.
[_layout_grid_last] :: Layout x y -> Bool

-- | A LayoutLR value is a single plot area, with an x axis and independent
--   left and right y axes, with a title at the top; legend at the bottom.
--   It's parametrized by the types of values to be plotted on the x and
--   two y axes.
data LayoutLR x y1 y2
LayoutLR :: FillStyle -> Maybe FillStyle -> String -> FontStyle -> LayoutAxis x -> AxisVisibility -> AxisVisibility -> LayoutAxis y1 -> AxisVisibility -> LayoutAxis y2 -> AxisVisibility -> [Either (Plot x y1) (Plot x y2)] -> Maybe LegendStyle -> Double -> Bool -> LayoutLR x y1 y2

-- | How to fill the background of everything.
[_layoutlr_background] :: LayoutLR x y1 y2 -> FillStyle

-- | How to fill the background of the plot, if different from the overall
--   background.
[_layoutlr_plot_background] :: LayoutLR x y1 y2 -> Maybe FillStyle

-- | Title to display above the chart.
[_layoutlr_title] :: LayoutLR x y1 y2 -> String

-- | Font style to use for the title.
[_layoutlr_title_style] :: LayoutLR x y1 y2 -> FontStyle

-- | Rules to generate the x axis.
[_layoutlr_x_axis] :: LayoutLR x y1 y2 -> LayoutAxis x

-- | Visibility options for the top axis.
[_layoutlr_top_axis_visibility] :: LayoutLR x y1 y2 -> AxisVisibility

-- | Visibility options for the bottom axis.
[_layoutlr_bottom_axis_visibility] :: LayoutLR x y1 y2 -> AxisVisibility

-- | Rules to generate the left y axis.
[_layoutlr_left_axis] :: LayoutLR x y1 y2 -> LayoutAxis y1

-- | Visibility options for the left axis.
[_layoutlr_left_axis_visibility] :: LayoutLR x y1 y2 -> AxisVisibility

-- | Rules to generate the right y axis.
[_layoutlr_right_axis] :: LayoutLR x y1 y2 -> LayoutAxis y2

-- | Visibility options for the right axis.
[_layoutlr_right_axis_visibility] :: LayoutLR x y1 y2 -> AxisVisibility

-- | The data sets to plot in the chart. They are plotted over each other.
--   The either type associates the plot with the left or right y axis.
[_layoutlr_plots] :: LayoutLR x y1 y2 -> [Either (Plot x y1) (Plot x y2)]

-- | How to style the legend.
[_layoutlr_legend] :: LayoutLR x y1 y2 -> Maybe LegendStyle

-- | The margin distance to use.
[_layoutlr_margin] :: LayoutLR x y1 y2 -> Double

-- | If the grid shall be rendered beneath (<tt>False</tt>) or over
--   (<tt>True</tt>) all plots.
[_layoutlr_grid_last] :: LayoutLR x y1 y2 -> Bool

-- | Type of axis that is used in <a>Layout</a> and <a>LayoutLR</a>.
--   
--   To generate the actual axis type (<a>AxisData</a> and <a>AxisT</a>)
--   the <a>_laxis_generate</a> function is called and custom settings are
--   applied with <a>_laxis_override</a>. Note that the
--   <a>AxisVisibility</a> values in <a>Layout</a> and <a>LayoutLR</a>
--   override visibility related settings of the axis.
data LayoutAxis x
LayoutAxis :: FontStyle -> String -> AxisStyle -> AxisFn x -> (AxisData x -> AxisData x) -> Bool -> LayoutAxis x

-- | Font style to use for the axis title.
[_laxis_title_style] :: LayoutAxis x -> FontStyle

-- | Title displayed for the axis.
[_laxis_title] :: LayoutAxis x -> String

-- | Axis style applied.
[_laxis_style] :: LayoutAxis x -> AxisStyle

-- | Function that generates the axis data, based upon the points plotted.
--   The default value is <a>autoAxis</a>.
[_laxis_generate] :: LayoutAxis x -> AxisFn x

-- | Function that can be used to override the generated axis data. The
--   default value is <a>id</a>.
[_laxis_override] :: LayoutAxis x -> AxisData x -> AxisData x

-- | True if left to right (bottom to top) is to show descending values.
[_laxis_reverse] :: LayoutAxis x -> Bool

-- | Information on what is at a specifc location of a <a>Layout</a> or
--   <a>LayoutLR</a>. This is delivered by the <a>PickFn</a> of a
--   <a>Renderable</a>.
data LayoutPick x y1 y2

-- | A legend entry.
LayoutPick_Legend :: String -> LayoutPick x y1 y2

-- | The title.
LayoutPick_Title :: String -> LayoutPick x y1 y2

-- | The title of the top x axis.
LayoutPick_XTopAxisTitle :: String -> LayoutPick x y1 y2

-- | The title of the bottom x axis.
LayoutPick_XBottomAxisTitle :: String -> LayoutPick x y1 y2

-- | The title of the left y axis.
LayoutPick_YLeftAxisTitle :: String -> LayoutPick x y1 y2

-- | The title of the right y axis.
LayoutPick_YRightAxisTitle :: String -> LayoutPick x y1 y2

-- | The plot area at the given plot coordinates.
LayoutPick_PlotArea :: x -> y1 -> y2 -> LayoutPick x y1 y2

-- | The top x axis at the given plot coordinate.
LayoutPick_XTopAxis :: x -> LayoutPick x y1 y2

-- | The bottom x axis at the given plot coordinate.
LayoutPick_XBottomAxis :: x -> LayoutPick x y1 y2

-- | The left y axis at the given plot coordinate.
LayoutPick_YLeftAxis :: y1 -> LayoutPick x y1 y2

-- | The right y axis at the given plot coordinate.
LayoutPick_YRightAxis :: y2 -> LayoutPick x y1 y2

-- | A container for a set of vertically <a>StackedLayout</a>s. The x axis
--   of the different layouts will be aligned.
data StackedLayouts x
StackedLayouts :: [StackedLayout x] -> Bool -> StackedLayouts x

-- | The stacked layouts from top (first element) to bottom (last element).
[_slayouts_layouts] :: StackedLayouts x -> [StackedLayout x]

-- | If the different legends shall be combined in one legend at the
--   bottom.
[_slayouts_compress_legend] :: StackedLayouts x -> Bool

-- | A layout with its y type hidden, so that it can be stacked with other
--   layouts with differing y axis, but the same x axis. See
--   <a>StackedLayouts</a>.
data StackedLayout x

-- | A <a>Layout</a> to stack.
StackedLayout :: Layout x y -> StackedLayout x

-- | A <a>LayoutLR</a> to stack.
StackedLayoutLR :: LayoutLR x yl yr -> StackedLayout x

-- | A <tt>MAxisFn</tt> is a function that generates an (optional) axis
--   given the points plotted against that axis.
type MAxisFn t = [t] -> Maybe AxisData t

-- | Render the given <a>Layout</a>.
layoutToRenderable :: (Ord x, Ord y) => Layout x y -> Renderable (LayoutPick x y y)
layoutToGrid :: (Ord x, Ord y) => Layout x y -> Grid (Renderable (LayoutPick x y y))

-- | Render the given <a>LayoutLR</a>.
layoutLRToRenderable :: (Ord x, Ord yl, Ord yr) => LayoutLR x yl yr -> Renderable (LayoutPick x yl yr)
layoutLRToGrid :: (Ord x, Ord yl, Ord yr) => LayoutLR x yl yr -> Grid (Renderable (LayoutPick x yl yr))

-- | Render several layouts with the same x-axis type and range, vertically
--   stacked so that their origins and x-values are aligned.
--   
--   The legends from all the charts may be optionally combined, and shown
--   once on the bottom chart. See <a>StackedLayouts</a> for further
--   information.
renderStackedLayouts :: Ord x => StackedLayouts x -> Renderable ()
laxis_title_style :: forall x f. Functor f => (FontStyle -> f FontStyle) -> LayoutAxis x -> f (LayoutAxis x)
laxis_title :: forall x f. Functor f => (String -> f String) -> LayoutAxis x -> f (LayoutAxis x)
laxis_style :: forall x f. Functor f => (AxisStyle -> f AxisStyle) -> LayoutAxis x -> f (LayoutAxis x)
laxis_generate :: forall x f. Functor f => (AxisFn x -> f (AxisFn x)) -> LayoutAxis x -> f (LayoutAxis x)
laxis_override :: forall x f. Functor f => ((AxisData x -> AxisData x) -> f (AxisData x -> AxisData x)) -> LayoutAxis x -> f (LayoutAxis x)
laxis_reverse :: forall x f. Functor f => (Bool -> f Bool) -> LayoutAxis x -> f (LayoutAxis x)
layout_background :: forall x y f. Functor f => (FillStyle -> f FillStyle) -> Layout x y -> f (Layout x y)
layout_plot_background :: forall x y f. Functor f => (Maybe FillStyle -> f (Maybe FillStyle)) -> Layout x y -> f (Layout x y)
layout_title :: forall x y f. Functor f => (String -> f String) -> Layout x y -> f (Layout x y)
layout_title_style :: forall x y f. Functor f => (FontStyle -> f FontStyle) -> Layout x y -> f (Layout x y)
layout_x_axis :: forall x y f. Functor f => (LayoutAxis x -> f (LayoutAxis x)) -> Layout x y -> f (Layout x y)
layout_top_axis_visibility :: forall x y f. Functor f => (AxisVisibility -> f AxisVisibility) -> Layout x y -> f (Layout x y)
layout_bottom_axis_visibility :: forall x y f. Functor f => (AxisVisibility -> f AxisVisibility) -> Layout x y -> f (Layout x y)
layout_y_axis :: forall x y f. Functor f => (LayoutAxis y -> f (LayoutAxis y)) -> Layout x y -> f (Layout x y)
layout_left_axis_visibility :: forall x y f. Functor f => (AxisVisibility -> f AxisVisibility) -> Layout x y -> f (Layout x y)
layout_right_axis_visibility :: forall x y f. Functor f => (AxisVisibility -> f AxisVisibility) -> Layout x y -> f (Layout x y)
layout_margin :: forall x y f. Functor f => (Double -> f Double) -> Layout x y -> f (Layout x y)
layout_plots :: forall x y f. Functor f => ([Plot x y] -> f [Plot x y]) -> Layout x y -> f (Layout x y)
layout_legend :: forall x y f. Functor f => (Maybe LegendStyle -> f (Maybe LegendStyle)) -> Layout x y -> f (Layout x y)
layout_grid_last :: forall x y f. Functor f => (Bool -> f Bool) -> Layout x y -> f (Layout x y)

-- | Setter to update all axis styles on a <a>Layout</a>
layout_axes_styles :: forall x y f. Settable f => (AxisStyle -> f AxisStyle) -> Layout x y -> f (Layout x y)

-- | Setter to update all the axes title styles on a <a>Layout</a>
layout_axes_title_styles :: forall x y f. Settable f => (FontStyle -> f FontStyle) -> Layout x y -> f (Layout x y)

-- | Setter to update all the font styles on a <a>Layout</a>
layout_all_font_styles :: forall x y f. Settable f => (FontStyle -> f FontStyle) -> Layout x y -> f (Layout x y)

-- | Setter to update the foreground color of core chart elements on a
--   <a>Layout</a>
layout_foreground :: forall x y f. Settable f => (AlphaColour Double -> f (AlphaColour Double)) -> Layout x y -> f (Layout x y)
layoutlr_background :: forall x y1 y2 f. Functor f => (FillStyle -> f FillStyle) -> LayoutLR x y1 y2 -> f (LayoutLR x y1 y2)
layoutlr_plot_background :: forall x y1 y2 f. Functor f => (Maybe FillStyle -> f (Maybe FillStyle)) -> LayoutLR x y1 y2 -> f (LayoutLR x y1 y2)
layoutlr_title :: forall x y1 y2 f. Functor f => (String -> f String) -> LayoutLR x y1 y2 -> f (LayoutLR x y1 y2)
layoutlr_title_style :: forall x y1 y2 f. Functor f => (FontStyle -> f FontStyle) -> LayoutLR x y1 y2 -> f (LayoutLR x y1 y2)
layoutlr_x_axis :: forall x y1 y2 f. Functor f => (LayoutAxis x -> f (LayoutAxis x)) -> LayoutLR x y1 y2 -> f (LayoutLR x y1 y2)
layoutlr_top_axis_visibility :: forall x y1 y2 f. Functor f => (AxisVisibility -> f AxisVisibility) -> LayoutLR x y1 y2 -> f (LayoutLR x y1 y2)
layoutlr_bottom_axis_visibility :: forall x y1 y2 f. Functor f => (AxisVisibility -> f AxisVisibility) -> LayoutLR x y1 y2 -> f (LayoutLR x y1 y2)
layoutlr_left_axis :: forall x y1 y2 f. Functor f => (LayoutAxis y1 -> f (LayoutAxis y1)) -> LayoutLR x y1 y2 -> f (LayoutLR x y1 y2)
layoutlr_right_axis :: forall x y1 y2 f. Functor f => (LayoutAxis y2 -> f (LayoutAxis y2)) -> LayoutLR x y1 y2 -> f (LayoutLR x y1 y2)
layoutlr_left_axis_visibility :: forall x y1 y2 f. Functor f => (AxisVisibility -> f AxisVisibility) -> LayoutLR x y1 y2 -> f (LayoutLR x y1 y2)
layoutlr_right_axis_visibility :: forall x y1 y2 f. Functor f => (AxisVisibility -> f AxisVisibility) -> LayoutLR x y1 y2 -> f (LayoutLR x y1 y2)
layoutlr_plots :: forall x y1 y2 f. Functor f => ([Either (Plot x y1) (Plot x y2)] -> f [Either (Plot x y1) (Plot x y2)]) -> LayoutLR x y1 y2 -> f (LayoutLR x y1 y2)
layoutlr_legend :: forall x y1 y2 f. Functor f => (Maybe LegendStyle -> f (Maybe LegendStyle)) -> LayoutLR x y1 y2 -> f (LayoutLR x y1 y2)
layoutlr_margin :: forall x y1 y2 f. Functor f => (Double -> f Double) -> LayoutLR x y1 y2 -> f (LayoutLR x y1 y2)
layoutlr_grid_last :: forall x y1 y2 f. Functor f => (Bool -> f Bool) -> LayoutLR x y1 y2 -> f (LayoutLR x y1 y2)

-- | Setter to update all axis styles on a <a>LayoutLR</a>
layoutlr_axes_styles :: forall x y1 y2 f. Settable f => (AxisStyle -> f AxisStyle) -> LayoutLR x y1 y2 -> f (LayoutLR x y1 y2)

-- | Setter to update all the axes title styles on a <a>LayoutLR</a>
layoutlr_axes_title_styles :: forall x y1 y2 f. Settable f => (FontStyle -> f FontStyle) -> LayoutLR x y1 y2 -> f (LayoutLR x y1 y2)

-- | Setter to update all the font styles on a <a>LayoutLR</a>
layoutlr_all_font_styles :: forall x y1 y2 f. Settable f => (FontStyle -> f FontStyle) -> LayoutLR x y1 y2 -> f (LayoutLR x y1 y2)

-- | Setter to update the foreground color of core chart elements on a
--   <a>LayoutLR</a>
layoutlr_foreground :: forall x y1 y2 f. Settable f => (AlphaColour Double -> f (AlphaColour Double)) -> LayoutLR x y1 y2 -> f (LayoutLR x y1 y2)
slayouts_layouts :: forall x1 x2 f. Functor f => ([StackedLayout x1] -> f [StackedLayout x2]) -> StackedLayouts x1 -> f (StackedLayouts x2)
slayouts_compress_legend :: forall x f. Functor f => (Bool -> f Bool) -> StackedLayouts x -> f (StackedLayouts x)
instance (Graphics.Rendering.Chart.Axis.Types.PlotValue x, Graphics.Rendering.Chart.Axis.Types.PlotValue y) => Data.Default.Internal.Default (Graphics.Rendering.Chart.Layout.Layout x y)
instance Graphics.Rendering.Chart.Axis.Types.PlotValue t => Data.Default.Internal.Default (Graphics.Rendering.Chart.Layout.LayoutAxis t)
instance (Graphics.Rendering.Chart.Axis.Types.PlotValue x, Graphics.Rendering.Chart.Axis.Types.PlotValue y1, Graphics.Rendering.Chart.Axis.Types.PlotValue y2) => Data.Default.Internal.Default (Graphics.Rendering.Chart.Layout.LayoutLR x y1 y2)
instance Data.Default.Internal.Default (Graphics.Rendering.Chart.Layout.StackedLayouts x)
instance (GHC.Internal.Show.Show x, GHC.Internal.Show.Show y1, GHC.Internal.Show.Show y2) => GHC.Internal.Show.Show (Graphics.Rendering.Chart.Layout.LayoutPick x y1 y2)
instance (GHC.Classes.Ord x, GHC.Classes.Ord y) => Graphics.Rendering.Chart.Renderable.ToRenderable (Graphics.Rendering.Chart.Layout.Layout x y)
instance (GHC.Classes.Ord x, GHC.Classes.Ord yl, GHC.Classes.Ord yr) => Graphics.Rendering.Chart.Renderable.ToRenderable (Graphics.Rendering.Chart.Layout.LayoutLR x yl yr)
instance GHC.Classes.Ord x => Graphics.Rendering.Chart.Renderable.ToRenderable (Graphics.Rendering.Chart.Layout.StackedLayouts x)

module Graphics.Rendering.Chart.State

-- | Add a plot to the <a>Layout</a> being constructed.
plot :: ToPlot p => EC (Layout x y) (p x y) -> EC (Layout x y) ()

-- | Add a plot against the left axis to the <a>LayoutLR</a> being
--   constructed.
plotLeft :: ToPlot p => EC (LayoutLR x y1 y2) (p x y1) -> EC (LayoutLR x y1 y2) ()

-- | Add a plot against the right axis tof the <a>LayoutLR</a> being
--   constructed.
plotRight :: ToPlot p => EC (LayoutLR x y1 y2) (p x y2) -> EC (LayoutLR x y1 y2) ()

-- | Pop and return the next color from the state
takeColor :: EC l (AlphaColour Double)

-- | Pop and return the next shape from the state
takeShape :: EC l PointShape

-- | The state held when monadically constructing a graphical element
data CState
colors :: Lens' CState [AlphaColour Double]
shapes :: Lens' CState [PointShape]

-- | We use nested State monads to give nice syntax. The outer state is the
--   graphical element being constructed (typically a layout). The inner
--   state contains any additional state reqired. This approach means that
--   lenses and the state monad lens operators can be used directly on the
--   value being constructed.
type EC l a = StateT l State CState a

-- | Run the monadic <a>EC</a> computation, and return the graphical
--   element (ie the outer monad' state)
execEC :: Default l => EC l a -> l

-- | Nest the construction of a graphical element within the construction
--   of another.
liftEC :: Default l1 => EC l1 a -> EC l2 l1

-- | Lift a a computation over <a>CState</a>
liftCState :: State CState a -> EC l a
instance Data.Default.Internal.Default Graphics.Rendering.Chart.State.CState
instance (Data.Default.Internal.Default a, Graphics.Rendering.Chart.Renderable.ToRenderable a) => Graphics.Rendering.Chart.Renderable.ToRenderable (Graphics.Rendering.Chart.State.EC a b)


-- | A framework for creating 2D charts in Haskell.
--   
--   For the simplest API, see the <a>Graphics.Rendering.Chart.Easy</a>
--   module.
--   
--   When more control is required, understanding the various data types is
--   necessary. The basic model is that you define a value representing a
--   chart to be displayed (eg. a <a>Layout</a>), and then convert it to a
--   <a>Renderable</a> by applying <a>toRenderable</a>. This
--   <a>Renderable</a> is then actually output by calling a function in an
--   appropriate graphics backend, eg <tt>renderableToFile</tt>.
--   
--   Currently, there are three types of charts:
--   
--   <ul>
--   <li><a>Layout</a> is a standard XY chart</li>
--   <li><a>LayoutLR</a> is an XY chart with independent left and right
--   axes</li>
--   <li><a>PieLayout</a> is a pie chart</li>
--   </ul>
--   
--   <a>Layout</a> and <a>LayoutLR</a> charts can be stacked vertically
--   using the <a>StackedLayouts</a> type.
--   
--   <a>Renderable</a>s can be composed in arbitrary ways using the
--   <a>Graphics.Rendering.Chart.Grid</a> module.
--   
--   Many of the record structure involved in the API have a large number
--   of fields. <tt>Lens</tt>es are provided to access each field. Also,
--   for each record type, there is generally a default value, which can be
--   accessed through the <tt>def</tt> value of the <tt>Default</tt>
--   typeclass.
module Graphics.Rendering.Chart


-- | A high level API for generating a plot quickly.
--   
--   Importing the Easy module brings into scope all core functions and
--   types required for working with the chart library. This includes key
--   external dependencies such as Control.Lens and Data.Colour. The module
--   also provides several helper functions for quickly generating common
--   plots. Note that chart backends must still be explicitly imported, as
--   some backends cannot be built on all platforms.
--   
--   Example usage:
--   
--   <pre>
--   import Graphics.Rendering.Chart.Easy
--   import Graphics.Rendering.Chart.Backend.Cairo
--   
--   signal :: [Double] -&gt; [(Double,Double)]
--   signal xs = [ (x,(sin (x*3.14159/45) + 1) / 2 * (sin (x*3.14159/5))) | x &lt;- xs ]
--   
--   main = toFile def "example.png" $ do
--       layout_title .= "Amplitude Modulation"
--       plot (line "am" [signal [0,(0.5)..400]])
--       plot (points "am points" (signal [0,7..400]))
--   </pre>
--   
--   More examples can be found on the <a>library's wiki</a>
module Graphics.Rendering.Chart.Easy
class ColourOps (f :: Type -> Type)

-- | <tt>darken s c</tt> blends a colour with black without changing it's
--   opacity.
--   
--   For <a>Colour</a>, <tt>darken s c = blend s c mempty</tt>
darken :: (ColourOps f, Num a) => a -> f a -> f a
class AffineSpace (f :: Type -> Type)

-- | Compute a affine Combination (weighted-average) of points. The last
--   parameter will get the remaining weight. e.g.
--   
--   <pre>
--   affineCombo [(0.2,a), (0.3,b)] c == 0.2*a + 0.3*b + 0.5*c
--   </pre>
--   
--   Weights can be negative, or greater than 1.0; however, be aware that
--   non-convex combinations may lead to out of gamut colours.
affineCombo :: (AffineSpace f, Num a) => [(a, f a)] -> f a -> f a

-- | This type represents a <a>Colour</a> that may be semi-transparent.
--   
--   The <a>Monoid</a> instance allows you to composite colours.
--   
--   <pre>
--   x `mappend` y == x `over` y
--   </pre>
--   
--   To get the (pre-multiplied) colour channel of an <a>AlphaColour</a>
--   <tt>c</tt>, simply composite <tt>c</tt> over black.
--   
--   <pre>
--   c `over` black
--   </pre>
data AlphaColour a

-- | This type represents the human preception of colour. The <tt>a</tt>
--   parameter is a numeric type used internally for the representation.
--   
--   The <a>Monoid</a> instance allows one to add colours, but beware that
--   adding colours can take you out of gamut. Consider using <a>blend</a>
--   whenever possible.
data Colour a

-- | Change the type used to represent the colour coordinates.
colourConvert :: (Fractional b, Real a) => Colour a -> Colour b
black :: Num a => Colour a

-- | This <a>AlphaColour</a> is entirely transparent and has no associated
--   colour channel.
transparent :: Num a => AlphaColour a

-- | Change the type used to represent the colour coordinates.
alphaColourConvert :: (Fractional b, Real a) => AlphaColour a -> AlphaColour b

-- | Creates an opaque <a>AlphaColour</a> from a <a>Colour</a>.
opaque :: Num a => Colour a -> AlphaColour a

-- | Returns an <a>AlphaColour</a> more transparent by a factor of
--   <tt>o</tt>.
dissolve :: Num a => a -> AlphaColour a -> AlphaColour a

-- | Creates an <a>AlphaColour</a> from a <a>Colour</a> with a given
--   opacity.
--   
--   <pre>
--   c `withOpacity` o == dissolve o (opaque c)
--   </pre>
withOpacity :: Num a => Colour a -> a -> AlphaColour a

-- | Compute the weighted average of two points. e.g.
--   
--   <pre>
--   blend 0.4 a b = 0.4*a + 0.6*b
--   </pre>
--   
--   The weight can be negative, or greater than 1.0; however, be aware
--   that non-convex combinations may lead to out of gamut colours.
blend :: (Num a, AffineSpace f) => a -> f a -> f a -> f a

-- | <tt>c1 `atop` c2</tt> returns the <a>AlphaColour</a> produced by
--   covering the portion of <tt>c2</tt> visible by <tt>c1</tt>. The
--   resulting alpha channel is always the same as the alpha channel of
--   <tt>c2</tt>.
--   
--   <pre>
--   c1 `atop` (opaque c2) == c1 `over` (opaque c2)
--   AlphaChannel (c1 `atop` c2) == AlphaChannel c2
--   </pre>
atop :: Fractional a => AlphaColour a -> AlphaColour a -> AlphaColour a

-- | Returns the opacity of an <a>AlphaColour</a>.
alphaChannel :: AlphaColour a -> a

-- | Constuct a line plot with the given title and data, using the next
--   available color.
line :: String -> [[(x, y)]] -> EC l (PlotLines x y)

-- | Construct a scatter plot with the given title and data, using the next
--   available color and point shape.
points :: String -> [(x, y)] -> EC l (PlotPoints x y)

-- | Construct a bar chart with the given titles and data, using the next
--   available colors
bars :: (PlotValue x, BarsPlotValue y) => [String] -> [(x, [y])] -> EC l (PlotBars x y)

-- | Set the contents of the colour source, for subsequent plots
setColors :: [AlphaColour Double] -> EC l ()

-- | Set the contents of the shape source, for subsequent plots
setShapes :: [PointShape] -> EC l ()
