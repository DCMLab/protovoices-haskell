{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QualifiedDo #-}

module Main where

import ChartParser
import Common
import Display
import PVGrammar
import PVGrammar.Generate
import PVGrammar.Parse

import Musicology.Core hiding (Note)
import Musicology.Core.Slicing
import Musicology.MusicXML
import Musicology.Pitch.Spelled as MT

import Data.Maybe (mapMaybe)
import Data.Text.Lazy qualified as TL
import Data.Text.Lazy.IO qualified as TL

-- better do syntax
import Language.Haskell.DoNotation qualified as Do

-- | The example derivation shown in Figure 4, specified manually.
deriv321sus :: [PVLeftmost (Pitch MT.SIC)]
deriv321sus = buildDerivation $ Do.do
  split $ mkSplit $ do
    splitRegular Start Stop "C.rootC" RootNote False False
    splitRegular Start Stop "E.rootE" RootNote False False
  spread $ mkSpread $ do
    spreadNote "C.rootC" (ToBoth "Cl" "Cr") True
    spreadNote "E.rootE" (ToLeft "El") False
    addPassing "E.El" "C.Cr"
  freeze $ mkFreeze []
  split $ mkSplit $ do
    splitRegular "C.Cl" "C.Cr" "B.Bnb" FullNeighbor True False
    splitPassing "E.El" "C.Cr" "D.Dpass" PassingMid True False
  split $ mkSplit $ do
    splitRegular "E.El" "D.Dpass" "D.Dsus" LeftRepeatOfRight False True
    splitRegular "C.Cl" "B.Bnb" "C.Csus" RightRepeatOfLeft True False
  freeze $ mkFreeze [("C.Cl", "C.Csus")]
  freeze $ mkFreeze [("D.Dsus", "D.Dpass")]
  freeze $ mkFreeze []
  freeze $ mkFreeze []

{- | The musical surface from Figure 4 as a sequence of slices and transitions.
 Can be used as an input for parsing.
-}
path321sus :: Path [Note SPC] [Edge SPC]
path321sus =
  Path ["E.e0", "C.c0"] [("C.c0", "C.c1")] $
    Path ["D.d1", "C.c1"] [("D.d1", "D.d2")] $
      Path ["D.d2", "B.b2"] [] $
        PathEnd ["C.c3"]

{- | The main function that produces the results used in the paper and demonstrates the parser:
 * a diagram of the (manually specified) derivation of the suspension example
   (similar to what is shown in Figure 4)
   rendered to 321sus.{tex,pdf}
 * the number of derivations of the suspension example (Figure 4)
 * the number of derivations of the beginning of the Bach example (Figure 1)
 * an abritrary derivation of the suspension examle generated by the parser
   rendered to 321sus-parsed.{tex,pdf}
-}
main :: IO ()
main = do
  plotDeriv "321sus.tex" deriv321sus

  putStrLn "counting 321sus..."
  count321sus <- parseSilent pvCountNoRepSplitRightBranchSplitFirst path321sus
  count321sus' <- parseSilent pvCountUnrestricted path321sus

  putStrLn "parsing 321sus"
  parses321sus <- parseSilent pvDerivRightBranch path321sus
  let Just parse321 = firstDerivation parses321sus
  plotDeriv "321sus-parsed.tex" parse321

  putStrLn "counting Bach..."
  bachSlices <- slicesFromFile "testdata/allemande.musicxml"
  bachCount <- parseSize pvCountNoRepSplitRightBranchSplitFirst $ slicesToPath $ take 9 bachSlices
  bachCount' <- parseSize pvCountUnrestricted $ slicesToPath $ take 9 bachSlices

  putStrLn "Results:"
  putStrLn $ "number of derivations (321sus): " <> show count321sus
  putStrLn $ "number of derivations (bach): " <> show bachCount
  putStrLn $ "number of derivations (321sus, no restrictions): " <> show count321sus'
  putStrLn $ "number of derivations (bach, no restrictions): " <> show bachCount'
  putStrLn "derivation of 321sus:"
  mapM_ print parse321

-- helper functions
-- ----------------

plotDeriv fn deriv = do
  case replayDerivation derivationPlayerPV deriv of
    (Left err) -> putStrLn err
    (Right g) -> viewGraph fn g
