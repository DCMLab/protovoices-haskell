-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/DCMLab/protovoices-haskell#readme</a>
@package protovoices
@version 0.1.0.0


-- | Common types and functionality that are used throughout the model.
module Common

-- | A Path is a datastructure that represents a sequence of alternating
--   objects, <i>arounds</i> and <i>betweens</i>, starting and ending with
--   the same type. An example would be a path in a graph, starting and
--   ending with a node with edges in-between.
data Path around between
Path :: !around -> !between -> !Path around between -> Path around between
PathEnd :: !around -> Path around between

-- | Returns the number of <i>arounds</i> in the path.
pathLen :: Path a b -> Int

-- | Returns the first <i>around</i> in the path.
pathHead :: Path a b -> a

-- | Replaces the first <i>around</i> in the path.
pathSetHead :: Path a b -> a -> Path a b

-- | Maps a function over every <i>around</i> in the path.
mapArounds :: (a -> a') -> Path a b -> Path a' b

-- | Maps a function over every <i>around</i> in the path together with its
--   index.
mapAroundsWithIndex :: Int -> (Int -> a -> a') -> Path a b -> Path a' b

-- | Maps a function over every <i>between</i> and its adjacent
--   <i>arounds</i> in the path.
mapBetweens :: (a -> b -> a -> c) -> Path a b -> [c]

-- | Reverses the path.
reversePath :: Path a b -> Path a b

-- | Returns the list of <i>arounds</i> in the path.
pathArounds :: Path a b -> [a]

-- | Returns the list of <i>betweens</i> in the path).
pathBetweens :: Path a b -> [b]

-- | Takes at most <tt>n</tt> '(a,b')' pairs from the path and returns it
--   as a list, applying a function over the <i>betweens</i>. The last
--   <tt>a</tt> in the path (if taken) is paired with the provided
--   <tt>finalb</tt>. The function <tt>f</tt> is used to be able to map
--   <i>betweens</i> to a type with a default value.
pathTake :: Int -> (b -> b') -> b' -> Path a b -> [(a, b')]

-- | A container type that augements the type <tt>a</tt> with symbols for
--   beginning (<a>Start</a>, ⋊) and end (<a>Stop</a>, ⋉). Every other
--   value is wrapped in an <tt>Inner</tt> constructor.
data StartStop a
Start :: StartStop a
Inner :: !a -> StartStop a
Stop :: StartStop a

-- | From a list of <tt>StartStop</tt>s returns only the elements that are
--   not <tt>:⋊</tt> or <tt>:⋉</tt>, unwrapped to their original type.
onlyInner :: [StartStop a] -> [a]

-- | Returns the content of an <a>Inner</a>, or <a>Nothing</a>.
getInner :: StartStop a -> Maybe a

-- | Returns the content of an <a>Inner</a>, or a <a>Left</a> with an error
--   message.
getInnerE :: StartStop a -> Either String a

-- | Returns <a>True</a> iff the argument is an <a>Inner</a>.
isInner :: StartStop a -> Bool

-- | Returns <a>True</a> iff the argument is <a>Start</a>.
isStart :: StartStop a -> Bool

-- | Returns <a>True</a> iff the argument is <a>Stop</a>.
isStop :: StartStop a -> Bool

-- | Turns a pair within a <a>StartStop</a> into a pair of
--   <a>StartStop</a>s
distStartStop :: StartStop (a, b) -> (StartStop a, StartStop b)

-- | A flag that indicates where a split has been performed, on the left
--   transition, the right transition, or the only transition
data SplitType
LeftOfTwo :: SplitType
RightOfTwo :: SplitType
SingleOfOne :: SplitType

-- | An evaluator for unspreads. Takes the two child slices and the middle
--   transition. Returns the parent slice and the spread operation, if
--   possible.
type UnspreadMiddle tr slc h v = (slc, tr, slc) -> [(slc, h, v)]

-- | An evaluator returning the possible left parent edges of an unspread.
--   The first argument is a pair of left child transition and left child
--   slice. The second argument is the parent slice.
type UnspreadLeft tr slc h = (tr, slc) -> slc -> h -> [tr]

-- | An evaluator returning the possible right parent edges of an unspread.
--   The first argument is a pair of right child slice and right child
--   transition. The second argument is the parent slice.
type UnspreadRight tr slc h = (slc, tr) -> slc -> h -> [tr]

-- | An evaluator for unsplits. Returns possible unsplits of a given pair
--   of transitions.
type Unsplit tr slc v = StartStop slc -> tr -> slc -> tr -> StartStop slc -> SplitType -> [(tr, v)]

-- | A combined evaluator for unsplits, unspreads, and unfreezes.
--   Additionally, contains a function for mapping terminal slices to
--   derivation slices.
data Eval tr tr' slc slc' h v
Eval :: !UnspreadMiddle tr slc h v -> !UnspreadLeft tr slc h -> !UnspreadRight tr slc h -> !Unsplit tr slc v -> !StartStop slc -> Maybe tr' -> StartStop slc -> IsLast -> [(tr, v)] -> !slc' -> slc -> Eval tr tr' slc slc' h v
[evalUnspreadMiddle] :: Eval tr tr' slc slc' h v -> !UnspreadMiddle tr slc h v
[evalUnspreadLeft] :: Eval tr tr' slc slc' h v -> !UnspreadLeft tr slc h
[evalUnspreadRight] :: Eval tr tr' slc slc' h v -> !UnspreadRight tr slc h
[evalUnsplit] :: Eval tr tr' slc slc' h v -> !Unsplit tr slc v
[evalUnfreeze] :: Eval tr tr' slc slc' h v -> !StartStop slc -> Maybe tr' -> StartStop slc -> IsLast -> [(tr, v)]
[evalSlice] :: Eval tr tr' slc slc' h v -> !slc' -> slc

-- | A flag indicating whether an operation is performed on the last
--   transition.
type IsLast = Bool

-- | Maps a function over all scores produced by the evaluator.
mapEvalScore :: (v -> w) -> Eval tr tr' slc slc' h v -> Eval tr tr' slc slc' h w

-- | Combine two evaluators into a product evaluator. Each evaluation
--   function returns the product of the two component evaluators' results.
productEval :: Eval tr1 tr' slc1 slc' h1 v1 -> Eval tr2 tr' slc2 slc' h2 v2 -> Eval (tr1, tr2) tr' (slc1, slc2) slc' (h1, h2) (v1, v2)

-- | A flag that is used to restrict spread operations to right branching.
data RightBranchSpread
RBBranches :: RightBranchSpread
RBClear :: RightBranchSpread

-- | An evaluator that doesn't parse the input but restricts spread
--   operations to right branching. Legal combinations will just return a
--   singleton <tt>()</tt> while illegal combinations return nothing.
--   Combine this with any evaluator as a product (using <a>productEval</a>
--   or <a>rightBranchSpread</a>) to make the evaluator right-branching.
evalRightBranchSpread :: Eval RightBranchSpread tr' () slc' () ()

-- | Restrict any evaluator to right-branching spreads.
rightBranchSpread :: Eval tr tr' slc slc' h w -> Eval (RightBranchSpread, tr) tr' ((), slc) slc' ((), h) w

-- | A flag for indicating whether a transition is the result of a split or
--   not. This is used for restricting the order of splits and spreads.
data Merged
Merged :: Merged
NotMerged :: Merged

-- | An evaluator that doesn't parse the input but restricts the order of
--   operations to always have splits before spreads on the left and right
--   transitions at a spread. Legal combinations will just return a
--   singleton <tt>()</tt> while illegal combinations return nothing.
--   Combine this with any evaluator as a product (using <a>productEval</a>
--   or <a>splitFirst</a>) to make the evaluator order-restricted.
evalSplitBeforeSpread :: Eval Merged tr' () slc' () ()

-- | Restrict any evaluator to split-before-spread order.
splitFirst :: Eval tr tr' slc slc' h w -> Eval (Merged, tr) tr' ((), slc) slc' ((), h) w

-- | A combined datatype for all leftmost-derivation operations.
data Leftmost s f h
LMSingle :: !LeftmostSingle s f -> Leftmost s f h
LMDouble :: !LeftmostDouble s f h -> Leftmost s f h
pattern LMFreezeLeft :: f -> Leftmost s f h
pattern LMFreezeOnly :: f -> Leftmost s f h
pattern LMSplitLeft :: s -> Leftmost s f h
pattern LMSplitOnly :: s -> Leftmost s f h
pattern LMSplitRight :: s -> Leftmost s f h
pattern LMSpread :: h -> Leftmost s f h

-- | Generative operations on a single transition (split or freeze).
data LeftmostSingle s f
LMSingleSplit :: !s -> LeftmostSingle s f
LMSingleFreeze :: !f -> LeftmostSingle s f

-- | Generative operations on two transitions (split left, freeze left,
--   split right, or spread)
data LeftmostDouble s f h
LMDoubleSplitLeft :: !s -> LeftmostDouble s f h
LMDoubleFreezeLeft :: !f -> LeftmostDouble s f h
LMDoubleSplitRight :: !s -> LeftmostDouble s f h
LMDoubleSpread :: !h -> LeftmostDouble s f h

-- | Encodes an analysis of a piece, consisting of a "top" (the starting
--   point of the derivation, i.e., the smallest reduction in the analysis)
--   and a derivation of the piece's surface from the top.
--   
--   Use this type's <a>FromJSON</a> instance to load an analysis exported
--   by the protovoice annotation tool.
data Analysis s f h tr slc
Analysis :: [Leftmost s f h] -> Path tr slc -> Analysis s f h tr slc

-- | The derivation steps.
[anaDerivation] :: Analysis s f h tr slc -> [Leftmost s f h]

-- | The starting configuration of the derivation. Starts with the first
--   transition, <a>Start</a> and <a>Stop</a> are implied.
[anaTop] :: Analysis s f h tr slc -> Path tr slc

-- | Prints the steps and intermediate configurations of a derivation.
debugAnalysis :: forall tr slc s f h. (Show tr, Show slc, Show s, Show h) => (s -> tr -> Either String (tr, slc, tr)) -> (f -> tr -> Either String tr) -> (h -> tr -> slc -> tr -> Either String (tr, slc, tr, slc, tr)) -> Analysis s f h tr slc -> IO (Either String ())

-- | Create a leftmost evaluator from position-independent evaluation
--   functions that just return spread, split, and freeze operations by
--   wrapping those into the appropriate <a>Leftmost</a> constructors.
mkLeftmostEval :: forall tr tr' slc slc' s f h. UnspreadMiddle tr slc h h -> UnspreadLeft tr slc h -> UnspreadRight tr slc h -> (StartStop slc -> tr -> slc -> tr -> StartStop slc -> [(tr, s)]) -> (StartStop slc -> Maybe tr' -> StartStop slc -> [(tr, f)]) -> (slc' -> slc) -> Eval tr tr' slc slc' h (Leftmost s f h)

-- | A wrapper around leftmost derivations that tracks information about
--   the derivation state in the type. Number of open transitions:
--   <tt>openTrans</tt>. Whether a right split has been performed at the
--   current point: <tt>afterRightSplit</tt>.
newtype PartialDerivation s f h (openTrans :: Nat) (afterRightSplit :: Bool)
PD :: [Leftmost s f h] -> PartialDerivation s f h (openTrans :: Nat) (afterRightSplit :: Bool)
[runPD] :: PartialDerivation s f h (openTrans :: Nat) (afterRightSplit :: Bool) -> [Leftmost s f h]

-- | A type-level wrapper for partial derivation info. Encodes the number
--   of open transitions and whether the last operation was a right split.
data DerivationInfo (a :: Nat) (b :: Bool)

-- | An "indexed" version of a writer monad, i.e. one where the monad type
--   between two steps can change. This can be used for tracking the number
--   of open transitions in a derivation on the type level while still
--   providing an monadic interface for constructing a derivation.
data IndexedWriter w (i :: k) (j :: k1) a

-- | <a>tell</a> for <a>IndexedWriter</a>.
itell :: forall {k1} {k2} w (i :: k1) (j :: k2). Monoid w => w -> IndexedWriter w i j ()

-- | The type of a monadic derivation action that modifies the derivation
--   state (number of open transitions, after right split).
type DerivationAction s f h (n :: Nat) (n' :: Nat) (afterRight :: Bool) (afterRight' :: Bool) = IndexedWriter [Leftmost s f h] DerivationInfo n afterRight DerivationInfo n' afterRight' ()

-- | Turn a monadically constructed derivation into a proper left-most
--   derivation. This function assumes the derivation to start with a
--   single transition.
buildDerivation :: forall s f h (n :: Nat) (snd :: Bool). DerivationAction s f h 1 n 'False snd -> [Leftmost s f h]

-- | Turn a monadically constructed partial derivation into a left-most
--   derivation. This function does not restrict the number of transitions
--   in the starting configuration.
buildPartialDerivation :: forall (n :: Nat) (n' :: Nat) (snd :: Bool) s f h. DerivationAction s f h n n' 'False snd -> [Leftmost s f h]

-- | Turn a split operation into a monadic (left or single) split action.
split :: forall (n :: Nat) s f h. (KnownNat n, 1 <= n) => s -> DerivationAction s f h n (n + 1) 'False 'False

-- | Turn a freeze operation into a monadic (left or single) freeze action.
freeze :: forall (n :: Nat) s h f. (KnownNat n, 1 <= n) => f -> DerivationAction s f h n (n - 1) 'False 'False

-- | Turn a split operation into a monadic right-split action.
splitRight :: forall (n :: Natural) s f h (snd :: Bool). 2 <= n => s -> DerivationAction s f h n (n + 1) snd 'True

-- | Turn a spread operation into a monadic spread action.
spread :: forall (n :: Natural) h s f (snd :: Bool). 2 <= n => h -> DerivationAction s f h n (n + 1) snd 'False

-- | The derivations semiring. Similar to a free semiring, encodes
--   sequences, alternatives, and neutral values directly. However,
--   semiring equivalences are not idendified by default.
data Derivations a

-- | a single operation
Do :: !a -> Derivations a

-- | combines alternative derivations
Or :: !Derivations a -> !Derivations a -> Derivations a

-- | combines sequential derivations
Then :: !Derivations a -> !Derivations a -> Derivations a

-- | the neutral element to <a>Then</a>
NoOp :: Derivations a

-- | the neutral element to <a>Or</a>
Cannot :: Derivations a

-- | Map the <a>Derivations</a> semiring to another semiring.
mapDerivations :: Semiring r => (a -> r) -> Derivations a -> r

-- | Flatten the prefix-tree structure of <a>Derivations</a> into a simple
--   set of derivations.
flattenDerivations :: Ord a => Derivations a -> Set [a]

-- | Flatten the prefix-tree structure of <a>Derivations</a> into a simple
--   list of (potentially redundant) derivations.
flattenDerivationsRed :: Ord a => Derivations a -> [[a]]

-- | Obtain the first derivation from a <a>Derivations</a> tree.
firstDerivation :: Ord a => Derivations a -> Maybe [a]

-- | Compute the cartesian product for a list of lists
cartProd :: [[a]] -> [[a]]

-- | <a>traverse</a> on a <tt>HashSet</tt>
traverseSet :: (Applicative f, Eq n', Hashable n') => (n -> f n') -> HashSet n -> f (HashSet n')

-- | Aeson options for parsing "variant" types (generated in PureScript)
variantDefaults :: (String -> String) -> Options

-- | Lowercase the first character in a string.
firstToLower :: String -> String

-- | The global trace level. Only trace messages &gt;= this level are
--   shown.
traceLevel :: Int

-- | A helper for conditionally tracing a message.
traceIf :: Int -> [Char] -> Bool -> Bool

-- | Convert special characters to TeX commands.
showTex :: Show a => a -> String

-- | Convert special characters to TeX commands (using <a>Text</a>)
showTexT :: Show a => a -> Text
instance Data.Bifunctor.Bifunctor Common.Path
instance (GHC.Classes.Eq s, GHC.Classes.Eq f, GHC.Classes.Eq h, GHC.Classes.Eq slc, GHC.Classes.Eq tr) => GHC.Classes.Eq (Common.Analysis s f h tr slc)
instance GHC.Classes.Eq Common.DerivOp
instance GHC.Classes.Eq a => GHC.Classes.Eq (Common.Derivations a)
instance (GHC.Classes.Eq s, GHC.Classes.Eq f, GHC.Classes.Eq h) => GHC.Classes.Eq (Common.Leftmost s f h)
instance (GHC.Classes.Eq f, GHC.Classes.Eq s, GHC.Classes.Eq h) => GHC.Classes.Eq (Common.LeftmostDouble s f h)
instance (GHC.Classes.Eq s, GHC.Classes.Eq f) => GHC.Classes.Eq (Common.LeftmostSingle s f)
instance GHC.Classes.Eq Common.Merged
instance (GHC.Classes.Eq between, GHC.Classes.Eq around) => GHC.Classes.Eq (Common.Path around between)
instance GHC.Classes.Eq Common.RightBranchSpread
instance GHC.Classes.Eq a => GHC.Classes.Eq (Common.StartStop a)
instance GHC.Internal.Data.Foldable.Foldable (Common.LeftmostSingle s)
instance GHC.Internal.Data.Foldable.Foldable Common.StartStop
instance (Data.Aeson.Types.FromJSON.FromJSON s, Data.Aeson.Types.FromJSON.FromJSON f, Data.Aeson.Types.FromJSON.FromJSON h, Data.Aeson.Types.FromJSON.FromJSON tr, Data.Aeson.Types.FromJSON.FromJSON slc) => Data.Aeson.Types.FromJSON.FromJSON (Common.Analysis s f h tr slc)
instance (Data.Aeson.Types.FromJSON.FromJSON s, Data.Aeson.Types.FromJSON.FromJSON f, Data.Aeson.Types.FromJSON.FromJSON h) => Data.Aeson.Types.FromJSON.FromJSON (Common.Leftmost s f h)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Common.StartStop a)
instance GHC.Internal.Base.Functor (Common.LeftmostSingle s)
instance GHC.Internal.Base.Functor (Common.Path around)
instance GHC.Internal.Base.Functor Common.StartStop
instance GHC.Internal.Generics.Generic (Common.Analysis s f h tr slc)
instance GHC.Internal.Generics.Generic (Common.Derivations a)
instance GHC.Internal.Generics.Generic (Common.Leftmost s f h)
instance GHC.Internal.Generics.Generic (Common.LeftmostDouble s f h)
instance GHC.Internal.Generics.Generic (Common.LeftmostSingle s f)
instance GHC.Internal.Generics.Generic Common.Merged
instance GHC.Internal.Generics.Generic (Common.Path around between)
instance GHC.Internal.Generics.Generic Common.RightBranchSpread
instance GHC.Internal.Generics.Generic (Common.StartStop a)
instance Data.Hashable.Class.Hashable Common.Merged
instance Data.Hashable.Class.Hashable Common.RightBranchSpread
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Common.StartStop a)
instance GHC.Internal.Data.String.IsString a => GHC.Internal.Data.String.IsString (Common.StartStop a)
instance GHC.Internal.Base.Monoid w => Data.Functor.Indexed.IxApplicative (Common.IndexedWriter w)
instance Data.Functor.Indexed.IxFunctor (Common.IndexedWriter w)
instance GHC.Internal.Base.Monoid w => Control.Monad.Indexed.IxMonad (Common.IndexedWriter w)
instance GHC.Internal.Base.Monoid w => Data.Functor.Indexed.IxPointed (Common.IndexedWriter w)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Common.Derivations a)
instance (Control.DeepSeq.NFData s, Control.DeepSeq.NFData f, Control.DeepSeq.NFData h) => Control.DeepSeq.NFData (Common.Leftmost s f h)
instance (Control.DeepSeq.NFData s, Control.DeepSeq.NFData f, Control.DeepSeq.NFData h) => Control.DeepSeq.NFData (Common.LeftmostDouble s f h)
instance (Control.DeepSeq.NFData s, Control.DeepSeq.NFData f) => Control.DeepSeq.NFData (Common.LeftmostSingle s f)
instance Control.DeepSeq.NFData Common.Merged
instance Control.DeepSeq.NFData Common.RightBranchSpread
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Common.StartStop a)
instance Musicology.Pitch.Class.Notation a => Musicology.Pitch.Class.Notation (Common.StartStop a)
instance (GHC.Classes.Ord s, GHC.Classes.Ord f, GHC.Classes.Ord h, GHC.Classes.Ord slc, GHC.Classes.Ord tr) => GHC.Classes.Ord (Common.Analysis s f h tr slc)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Common.Derivations a)
instance (GHC.Classes.Ord s, GHC.Classes.Ord f, GHC.Classes.Ord h) => GHC.Classes.Ord (Common.Leftmost s f h)
instance (GHC.Classes.Ord f, GHC.Classes.Ord s, GHC.Classes.Ord h) => GHC.Classes.Ord (Common.LeftmostDouble s f h)
instance (GHC.Classes.Ord s, GHC.Classes.Ord f) => GHC.Classes.Ord (Common.LeftmostSingle s f)
instance GHC.Classes.Ord Common.Merged
instance (GHC.Classes.Ord between, GHC.Classes.Ord around) => GHC.Classes.Ord (Common.Path around between)
instance GHC.Classes.Ord Common.RightBranchSpread
instance GHC.Classes.Ord a => GHC.Classes.Ord (Common.StartStop a)
instance Data.Semiring.Semiring (Common.Derivations a)
instance (GHC.Internal.Show.Show s, GHC.Internal.Show.Show f, GHC.Internal.Show.Show h, GHC.Internal.Show.Show tr, GHC.Internal.Show.Show slc) => GHC.Internal.Show.Show (Common.Analysis s f h tr slc)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Common.Derivations a)
instance (GHC.Internal.Show.Show s, GHC.Internal.Show.Show f, GHC.Internal.Show.Show h) => GHC.Internal.Show.Show (Common.Leftmost s f h)
instance (GHC.Internal.Show.Show f, GHC.Internal.Show.Show s, GHC.Internal.Show.Show h) => GHC.Internal.Show.Show (Common.LeftmostDouble s f h)
instance (GHC.Internal.Show.Show s, GHC.Internal.Show.Show f) => GHC.Internal.Show.Show (Common.LeftmostSingle s f)
instance GHC.Internal.Show.Show Common.Merged
instance (GHC.Internal.Show.Show a, GHC.Internal.Show.Show b) => GHC.Internal.Show.Show (Common.Path a b)
instance GHC.Internal.Show.Show Common.RightBranchSpread
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Common.StartStop a)
instance (Data.Aeson.Types.ToJSON.ToJSON s, Data.Aeson.Types.ToJSON.ToJSON f, Data.Aeson.Types.ToJSON.ToJSON h, Data.Aeson.Types.ToJSON.ToJSON tr, Data.Aeson.Types.ToJSON.ToJSON slc) => Data.Aeson.Types.ToJSON.ToJSON (Common.Analysis s f h tr slc)
instance (Data.Aeson.Types.ToJSON.ToJSON s, Data.Aeson.Types.ToJSON.ToJSON f, Data.Aeson.Types.ToJSON.ToJSON h) => Data.Aeson.Types.ToJSON.ToJSON (Common.Leftmost s f h)
instance (Data.Aeson.Types.ToJSON.ToJSON s, Data.Aeson.Types.ToJSON.ToJSON f, Data.Aeson.Types.ToJSON.ToJSON h) => Data.Aeson.Types.ToJSON.ToJSON (Common.LeftmostDouble s f h)
instance (Data.Aeson.Types.ToJSON.ToJSON s, Data.Aeson.Types.ToJSON.ToJSON f) => Data.Aeson.Types.ToJSON.ToJSON (Common.LeftmostSingle s f)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Common.StartStop a)
instance GHC.Internal.Data.Traversable.Traversable (Common.LeftmostSingle s)
instance GHC.Internal.Data.Traversable.Traversable Common.StartStop


-- | This module contains functions for visualizing derivations using LaTeX
--   and TikZ. These functions are generic over slice and transition
--   contents and are thus somewhat limited. For protovoice derivations, an
--   alternative to plotting a derivation would be to export an
--   <a>Analysis</a> to JSON and view it interactively in the <a>protovoice
--   annotation tool</a> (not implemented yet).
--   
--   Plotting happens in two steps. First, a the derivation is "replayed"
--   using a (generic or grammar-specific) "player" to construct a
--   <a>DerivationGraph</a>, which contains all graphical objects and their
--   positions explicitly. The <a>DerivationGraph</a> can then be plotted
--   using different backends (currently only TikZ, but a diagrams/SVG
--   backed would be useful too).
module Display

-- | A derivation graph. Contains the graphical objects of a derivation
--   plot as well as intermediate information that is used during a replay.
data DerivationGraph slc tr
DGraph :: !Int -> !Set (DerivSlice slc) -> !Set (DerivTrans slc tr) -> !Set (DerivSlice slc, DerivSlice slc) -> ![DerivTrans slc tr] -> ![DerivTrans slc tr] -> ![DerivTrans slc tr] -> DerivationGraph slc tr

-- | a counter for generating new IDs (used during replay)
[dgNextId] :: DerivationGraph slc tr -> !Int

-- | the positioned slices of the derivation graph
[dgSlices] :: DerivationGraph slc tr -> !Set (DerivSlice slc)

-- | the positioned transitionn in the derivation graph
[dgTransitions] :: DerivationGraph slc tr -> !Set (DerivTrans slc tr)

-- | the "horizontalization" edges (connecting the parent slice of a spread
--   to its children)
[dgHoriEdges] :: DerivationGraph slc tr -> !Set (DerivSlice slc, DerivSlice slc)

-- | the open transitions of the current surface
[dgOpen] :: DerivationGraph slc tr -> ![DerivTrans slc tr]

-- | the frozen transitions of the current surface in reverse order
[dgFrozen] :: DerivationGraph slc tr -> ![DerivTrans slc tr]

-- | the root transitions
[dgRoot] :: DerivationGraph slc tr -> ![DerivTrans slc tr]

-- | A slice together with a depth and an ID
data DerivSlice slc
DerivSlice :: !Int -> !Int -> !StartStop slc -> DerivSlice slc
[dslDepth] :: DerivSlice slc -> !Int
[dslId] :: DerivSlice slc -> !Int
[dslContent] :: DerivSlice slc -> !StartStop slc

-- | A transition between two <a>DerivSlice</a>s.
type DerivTrans slc tr = (DerivSlice slc, tr, DerivSlice slc)

-- | Replay a derivation from <tt>⋊——⋉</tt>.
replayDerivation :: (Foldable t, Ord slc, Ord tr) => DerivationPlayer s f h slc tr -> t (Leftmost s f h) -> Either String (DerivationGraph slc tr)

-- | Replay a derivation from <tt>n</tt> top-level transitions.
replayDerivation' :: (Foldable t, Ord slc, Ord tr) => Path tr slc -> DerivationPlayer s f h slc tr -> t (Leftmost s f h) -> Either String (DerivationGraph slc tr)

-- | Replay a derivation from <tt>⋊——⋉</tt> and ensure that the dervation
--   is complete (freezing all transitions). Return an error message if
--   not.
replayDerivationFull :: (Foldable t, Ord slc, Ord tr) => DerivationPlayer s f h slc tr -> t (Leftmost s f h) -> Either String (DerivationGraph slc tr)

-- | Replays a derivation from <tt>⋊——⋉</tt> and returns every intermediate
--   derivation graph.
unfoldDerivation :: (Ord slc, Ord tr) => DerivationPlayer s f h slc tr -> [Leftmost s f h] -> [Either String (DerivationGraph slc tr)]

-- | Replays a derivation from <tt>n</tt> top-level transitions and returns
--   every intermediate derivation graph.
unfoldDerivation' :: (Ord slc, Ord tr) => Path tr slc -> DerivationPlayer s f h slc tr -> [Leftmost s f h] -> [Either String (DerivationGraph slc tr)]

-- | A derivation player. Contains functions for replaying derivations of a
--   particular grammar, i.e. for deriving child elements from parent
--   elements.
data DerivationPlayer s f h slc tr
DerivationPlayer :: !tr -> !s -> tr -> Either String (tr, slc, tr) -> !f -> tr -> Either String tr -> !h -> tr -> slc -> tr -> Either String (tr, slc, tr, slc, tr) -> DerivationPlayer s f h slc tr

-- | the grammars default starting transition for <tt>⋊——⋉</tt>
[dpTopTrans] :: DerivationPlayer s f h slc tr -> !tr

-- | replay a split operation
[dpSplit] :: DerivationPlayer s f h slc tr -> !s -> tr -> Either String (tr, slc, tr)

-- | replay a freeze operation
[dpFreeze] :: DerivationPlayer s f h slc tr -> !f -> tr -> Either String tr

-- | replay a spread operation
[dpSpread] :: DerivationPlayer s f h slc tr -> !h -> tr -> slc -> tr -> Either String (tr, slc, tr, slc, tr)

-- | A derivation player that uses <tt>()</tt> for slice and transition
--   contents. The actual derivation operations are ignored, so only the
--   outer structure is produced.
derivationPlayerUnit :: DerivationPlayer s f h () ()

-- | A derivation player that uses <a>Empty</a> for slice and transition
--   content. The actual derivation operations are ignored, so only the
--   outer structure is produced.
derivationPlayerEmpty :: DerivationPlayer s f h Empty Empty

-- | A helper type that is like <tt>()</tt> but has a <a>Show</a> instance
--   that returns the empty string.
data Empty

-- | Convert a derivation graph into a series of TikZ commands.
tikzDerivationGraph :: (Eq slc, Eq tr) => (slc -> Text) -> (tr -> Text) -> DerivationGraph slc tr -> Text

-- | Wraps TikZ commands in a <tt>tikzpicture</tt> environment.
tikzPic :: (Semigroup a, IsString a) => a -> a

-- | Wraps latex code (e.g. a <tt>tikzpicture</tt>) in a complete
--   standalone document. This environment includes default styles for
--   slices, transitions, and hori edges.
tikzStandalone :: (Semigroup a, IsString a) => Bool -> a -> a

-- | Write a single derivation graph to a <tt>tex</tt> file.
writeGraph :: (Show slc, Eq slc, Eq tr, Show tr) => FilePath -> DerivationGraph slc tr -> IO ()

-- | Write a several derivation graphs to a <tt>tex</tt> file.
writeGraphs :: (Show tr, Show slc, Eq slc, Eq tr) => FilePath -> [DerivationGraph slc tr] -> IO ()

-- | Write a single derivation graph to a <tt>tex</tt> file and compile the
--   file using <tt>pdflatex</tt>.
viewGraph :: (Eq slc, Eq tr, Show slc, Show tr) => FilePath -> DerivationGraph slc tr -> IO ()

-- | Write a several derivation graphs to a <tt>tex</tt> file and compile
--   the file using <tt>pdflatex</tt>.
viewGraphs :: (Show tr, Show slc, Eq slc, Eq tr) => FilePath -> [DerivationGraph slc tr] -> IO ()
instance GHC.Classes.Eq slc => GHC.Classes.Eq (Display.DerivSlice slc)
instance (GHC.Classes.Eq slc, GHC.Classes.Eq tr) => GHC.Classes.Eq (Display.DerivationGraph slc tr)
instance GHC.Classes.Eq Display.Empty
instance GHC.Classes.Ord slc => GHC.Classes.Ord (Display.DerivSlice slc)
instance (GHC.Classes.Ord slc, GHC.Classes.Ord tr) => GHC.Classes.Ord (Display.DerivationGraph slc tr)
instance GHC.Classes.Ord Display.Empty
instance GHC.Internal.Show.Show slc => GHC.Internal.Show.Show (Display.DerivSlice slc)
instance (GHC.Internal.Show.Show slc, GHC.Internal.Show.Show tr) => GHC.Internal.Show.Show (Display.DerivationGraph slc tr)
instance GHC.Internal.Show.Show Display.Empty


-- | This module contains a simple greedy parser for path grammars. The
--   grammar is provided by an evaluator (<a>Eval</a>). In addition, the
--   parser takes a policy function that picks a reduction option in each
--   step.
module GreedyParser

-- | The state of the greedy parse between steps. Generally, the current
--   reduction consists of frozen transitions between the ⋊ and the current
--   location and open transitions between the current location and ⋉.
--   
--   <pre>
--   ⋊==[1]==[2]==[3]——[4]——[5]——⋉
--     └ frozen  ┘  | └   open  ┘
--               midSlice (current position)
--   
--   frozen:   ==[2]==[1]==
--   midSlice: [3]
--   open:     ——[4]——[5]——
--   </pre>
--   
--   This is the <a>GSSemiOpen</a> case: The slice at the current pointer
--   (<tt>[3]</tt>) is represented as an individual slice
--   (<tt>midSlice</tt>). The frozen part is represented by a <a>Path</a>
--   of frozen transitions (<tt>tr'</tt>) and slices (<tt>slc</tt>). <b>in
--   reverse direction</b>, i.e. from <tt>midslice</tt> back to ⋊
--   (excluding ⋊). The open part is a <a>Path</a> of open transitions
--   (<tt>tr</tt>) and slices (<tt>slc</tt>) in forward direction from
--   <tt>midSlice</tt> up to ⋉.
--   
--   There are two special cases. All transitions can be frozen
--   (<a>GSFrozen</a>), in which case state only contains the backward
--   <a>Path</a> of frozen transitions (excluding ⋊ and ⋉):
--   
--   <pre>
--   ⋊==[1]==[2]==[3]==⋉
--                      └ current position
--   represented as: ==[3]==[2]==[1]==
--   </pre>
--   
--   Or all transitions can be open (<a>GSOpen</a>), in which case the
--   state is just the forward path of open transitions:
--   
--   <pre>
--   ⋊——[1]——[2]——[3]——⋉
--   └ current position
--   represented as: ——[1]——[2]——[3]——
--   </pre>
--   
--   The open and semiopen case additionally have a list of operations in
--   generative order, and a flag that indicates whether the previous step
--   was a left operation, which would prevent continuing with a right
--   unsplit.
data GreedyState tr tr' slc op
GSFrozen :: !Path (Maybe tr') slc -> GreedyState tr tr' slc op
GSSemiOpen :: !Path (Maybe tr') slc -> !slc -> !Path tr slc -> ![op] -> GreedyState tr tr' slc op

-- | frozen transitions and slices from current point leftward
[_gsFrozen] :: GreedyState tr tr' slc op -> !Path (Maybe tr') slc

-- | the slice at the current posision between gsFrozen and gsOpen
[_gsMidSlice] :: GreedyState tr tr' slc op -> !slc

-- | non-frozen transitions and slices from current point rightward
[_gsOpen] :: GreedyState tr tr' slc op -> !Path tr slc

-- | derivation from current reduction to original surface
[_gsDeriv] :: GreedyState tr tr' slc op -> ![op]
GSOpen :: !Path tr slc -> ![op] -> GreedyState tr tr' slc op

-- | Helper function for showing the frozen part of a piece.
showFrozen :: (Show slc, Show tr') => Path tr' slc -> String

-- | Helper function for showing the open part of a piece.
showOpen :: (Show slc, Show tr) => Path tr slc -> String
showOps :: Show o => [o] -> String
gsOps :: GreedyState tr tr' slc op -> [op]

-- | Single parent of a parsing action
data SingleParent slc tr
SingleParent :: !StartStop slc -> !tr -> !StartStop slc -> SingleParent slc tr

-- | A parsing action (reduction step) with a single parent transition.
--   Combines the parent elements with a single-transition derivation
--   operation.
data ActionSingle slc tr s f
ActionSingle :: SingleParent slc tr -> LeftmostSingle s f -> ActionSingle slc tr s f

-- | Single parent of a parsing action
data DoubleParent slc tr
DoubleParent :: !StartStop slc -> !tr -> !slc -> !tr -> !StartStop slc -> DoubleParent slc tr

-- | A parsing action (reduction step) with two parent transitions.
--   Combines the parent elements with a double-transition derivation
--   operation.
data ActionDouble slc tr s f h
ActionDouble :: DoubleParent slc tr -> LeftmostDouble s f h -> ActionDouble slc tr s f h

-- | An alias that combines <a>ActionSingle</a> and <a>ActionDouble</a>,
--   representing all possible reduction steps.
type Action slc tr s f h = Either ActionSingle slc tr s f ActionDouble slc tr s f h

-- | A helper function that checks whether an action: - - is a double
--   action and goes left ('Just True') - - is a double action and goes
--   right ('Just False') - - is a single action (<a>Nothing</a>, doesn't
--   have to choose). - (See <a>opGoesLeft</a>.)
actionGoesLeft :: Action slc tr s f h -> Maybe Bool

-- | A helper function that checks whether a derivation operation: - - is a
--   double op and goes left ('Just True') - - is a double op and goes
--   right ('Just False') - - is a single op (<a>Nothing</a>, doesn't have
--   to choose). - (See <a>actionGoesLeft</a>.)
opGoesLeft :: Leftmost s f h -> Maybe Bool

-- | Parse a piece in a greedy fashion. At each step, a policy chooses from
--   the possible reduction actions, the reduction is applied, and parsing
--   continues until the piece is fully reduced or no more reduction
--   operations are available. Returns the full derivation from the top
--   (<tt>⋊——⋉</tt>) or an error message.
parseGreedy :: forall (m :: Type -> Type) tr tr' slc slc' s f h. (Monad m, MonadIO m, Show tr', Show slc, Show tr, Show s, Show f, Show h) => Eval tr tr' slc slc' h (Leftmost s f h) -> ([Action slc tr s f h] -> ExceptT String m (Action slc tr s f h)) -> Path slc' tr' -> ExceptT String m (Analysis s f h tr slc)

-- | Initializes a parse state. Takes an evaluator and a (frozen) input
--   path. Returns the parsing state that corresponds to the unparsed
--   input.
initParseState :: Eval tr tr' slc slc' h v -> Path slc' tr' -> GreedyState tr tr' slc op

-- | A single greedy parse step. Enumerates a list of possible actions in
--   the current state and applies a policy function to select an action.
--   The resulting state is returned, wrapped in a monad transformer stack
--   containing <a>String</a> exceptions and the monad of the policy.
parseStep :: forall (m :: Type -> Type) tr tr' slc slc' s f h. Monad m => Eval tr tr' slc slc' h (Leftmost s f h) -> ([Action slc tr s f h] -> ExceptT String m (Action slc tr s f h)) -> GreedyState tr tr' slc (Leftmost s f h) -> ExceptT String m (Either (GreedyState tr tr' slc (Leftmost s f h)) (tr, [Leftmost s f h]))

-- | Enumerates the list of possible actions in the current state
getActions :: forall {k} (m :: k) tr tr' slc slc' s f h. Eval tr tr' slc slc' h (Leftmost s f h) -> GreedyState tr tr' slc (Leftmost s f h) -> [Action slc tr s f h]
lastWasLeft :: [Leftmost s f h] -> Bool
collectAllThawLeft :: Eval tr tr' slc slc' h (Leftmost s f h) -> Path (Maybe tr') slc -> slc -> tr -> StartStop slc -> [ActionDouble slc tr s f h]
collectThawSingle :: Eval tr tr' slc slc' h (Leftmost s f h) -> StartStop slc -> Maybe tr' -> StartStop slc -> [ActionSingle slc tr s f]
collectThawLeft :: Eval tr tr' slc slc' h (Leftmost s f h) -> StartStop slc -> Maybe tr' -> slc -> tr -> StartStop slc -> [ActionDouble slc tr s f h]
collectUnsplitSingle :: Eval tr tr' slc slc' h (Leftmost s f h) -> StartStop slc -> tr -> slc -> tr -> StartStop slc -> [ActionSingle slc tr s f]
collectUnsplitLeft :: Eval tr tr' slc slc' h (Leftmost s f h) -> StartStop slc -> tr -> slc -> tr -> slc -> tr -> StartStop slc -> [ActionDouble slc tr s f h]
collectUnsplitRight :: Eval tr tr' slc slc' h (Leftmost s f h) -> StartStop slc -> tr -> slc -> tr -> slc -> tr -> StartStop slc -> Bool -> [ActionDouble slc tr s f h]
collectUnspreads :: Eval tr tr' slc slc' h (Leftmost s f h) -> StartStop slc -> tr -> slc -> tr -> slc -> tr -> StartStop slc -> [ActionDouble slc tr s f h]
collectDoubles :: Eval tr tr' slc slc' h (Leftmost s f h) -> StartStop slc -> tr -> slc -> tr -> slc -> Path tr slc -> Bool -> [ActionDouble slc tr s f h]

-- | A policy that picks the next action at random. Must be partially
--   applied with a random generator before passing to <a>parseGreedy</a>.
pickRandom :: forall g (m :: Type -> Type) slc. StatefulGen g m => g -> [slc] -> ExceptT String m slc

-- | Apply an action to a parsing state.
applyAction :: forall {k1} {k2} (m :: k1) tr tr' slc (slc' :: k2) s f h. GreedyState tr tr' slc (Leftmost s f h) -> Action slc tr s f h -> Either String (Either (GreedyState tr tr' slc (Leftmost s f h)) (tr, [Leftmost s f h]))

-- | Parse a piece randomly using a fresh random number generator.
parseRandom :: (Show tr', Show slc, Show tr, Show s, Show f, Show h) => Eval tr tr' slc slc' h (Leftmost s f h) -> Path slc' tr' -> ExceptT String IO (Analysis s f h tr slc)

-- | Parse a piece randomly using an existing random number generator.
parseRandom' :: (Show tr', Show slc, Show tr, Show s, Show f, Show h, StatefulGen g IO) => g -> Eval tr tr' slc slc' h (Leftmost s f h) -> Path slc' tr' -> ExceptT String IO (Analysis s f h tr slc)
instance (GHC.Internal.Show.Show slc, GHC.Internal.Show.Show tr, GHC.Internal.Show.Show f, GHC.Internal.Show.Show s, GHC.Internal.Show.Show h) => GHC.Internal.Show.Show (GreedyParser.ActionDouble slc tr s f h)
instance (GHC.Internal.Show.Show slc, GHC.Internal.Show.Show tr, GHC.Internal.Show.Show s, GHC.Internal.Show.Show f) => GHC.Internal.Show.Show (GreedyParser.ActionSingle slc tr s f)
instance (GHC.Internal.Show.Show slc, GHC.Internal.Show.Show tr) => GHC.Internal.Show.Show (GreedyParser.DoubleParent slc tr)
instance (GHC.Internal.Show.Show tr, GHC.Internal.Show.Show tr', GHC.Internal.Show.Show slc, GHC.Internal.Show.Show o) => GHC.Internal.Show.Show (GreedyParser.GreedyState tr tr' slc o)
instance (GHC.Internal.Show.Show slc, GHC.Internal.Show.Show tr) => GHC.Internal.Show.Show (GreedyParser.SingleParent slc tr)


-- | A simple implementation of multisets as hash maps to counts. Supports
--   just what is needed for protovoice slices.
module Internal.MultiSet

-- | A hash multiset. A unordered collection of items that can occur
--   several times.
newtype MultiSet a
MS :: HashMap a Int -> MultiSet a
[unMS] :: MultiSet a -> HashMap a Int
toList :: MultiSet a -> [a]
all :: (a -> Bool) -> MultiSet a -> Bool
toOccurList :: MultiSet k -> [(k, Int)]
distinctElems :: MultiSet k -> [k]
union :: (Eq a, Hashable a) => MultiSet a -> MultiSet a -> MultiSet a
unions :: (Foldable t, Eq a0, Hashable a0) => t (MultiSet a0) -> MultiSet a0
maxUnion :: (Eq a, Hashable a) => MultiSet a -> MultiSet a -> MultiSet a
deleteN :: Int -> Int -> Maybe Int
(\\) :: (Eq a, Hashable a) => MultiSet a -> MultiSet a -> MultiSet a
toSet :: MultiSet k -> HashSet k
size :: MultiSet a -> Int
cardinality :: MultiSet a -> Int
map :: (Eq b, Hashable b) => (a -> b) -> MultiSet a -> MultiSet b
traverse :: (Eq b, Hashable b, Applicative f) => (a -> f b) -> MultiSet a -> f (MultiSet b)
filter :: (a -> Bool) -> MultiSet a -> MultiSet a
fromList :: (Foldable t, Eq a, Hashable a) => t a -> MultiSet a
fromSet :: (Foldable t, Eq a, Hashable a) => t a -> MultiSet a
null :: MultiSet k -> Bool
delete :: (Eq a, Hashable a) => a -> MultiSet a -> MultiSet a
empty :: MultiSet a
foldM :: Monad m => (b -> a -> m b) -> b -> MultiSet a -> m b
insertMany :: (Eq a, Hashable a) => a -> Int -> MultiSet a -> MultiSet a
insert :: (Eq a, Hashable a) => a -> MultiSet a -> MultiSet a
singleton :: Hashable a => a -> MultiSet a
member :: (Eq k, Hashable k) => k -> MultiSet k -> Bool
lookup :: (Eq k, Hashable k) => k -> MultiSet k -> Int
(!) :: (Eq k, Hashable k) => MultiSet k -> k -> Int
instance GHC.Classes.Eq a => GHC.Classes.Eq (Internal.MultiSet.MultiSet a)
instance GHC.Internal.Generics.Generic (Internal.MultiSet.MultiSet a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Internal.MultiSet.MultiSet a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Internal.MultiSet.MultiSet a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Internal.MultiSet.MultiSet a)
instance (GHC.Classes.Eq a, Data.Hashable.Class.Hashable a) => GHC.Internal.Base.Semigroup (Internal.MultiSet.MultiSet a)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Internal.MultiSet.MultiSet a)


-- | This module contains common datatypes and functions specific to the
--   protovoice grammar. In a protovoice derivations, slices are multisets
--   of notes while transitions contain connections between these notes.
--   
--   Code that is specific to parsing can be found in
--   <a>PVGrammar.Parse</a>, while generative code is located in
--   <a>PVGrammar.Generate</a>.
module PVGrammar

-- | A note with a pitch and an ID.
data Note n
Note :: n -> String -> Note n
[notePitch] :: Note n -> n
[noteId] :: Note n -> String

-- | The content type of slices in the protovoice model. Contains a set of
--   notes (pitch x id), representing the notes in a slice.
newtype Notes n
Notes :: HashSet (Note n) -> Notes n

-- | Return the notes or start/stop symbols inside a slice. This is useful
--   to get all objects that an <a>Edge</a> can connect to.
innerNotes :: StartStop (Notes n) -> [StartStop (Note n)]

-- | The content type of transitions in the protovoice model. Contains a
--   multiset of regular edges and a multiset of passing edges. The
--   represented edges are those that are definitely used later on. Edges
--   that are not used are dropped before creating a child transition. A
--   transition that contains passing edges cannot be frozen.
data Edges n
Edges :: !HashSet (Edge n) -> !MultiSet (InnerEdge n) -> Edges n

-- | regular edges
[edgesReg] :: Edges n -> !HashSet (Edge n)

-- | passing edges
[edgesPass] :: Edges n -> !MultiSet (InnerEdge n)

-- | The starting transition of a derivation (<tt>⋊——⋉</tt>).
topEdges :: Hashable n => Edges n

-- | A proto-voice edge between two nodes (i.e. notes or start/stop
--   symbols).
type Edge n = (StartStop Note n, StartStop Note n)

-- | A proto-voice edge between two notes (excluding start/stop symbols).
type InnerEdge n = (Note n, Note n)

-- | Represents a freeze operation. Since this just ties all remaining
--   edges (which must all be repetitions) no decisions have to be encoded.
newtype Freeze n
FreezeOp :: HashSet (Edge n) -> Freeze n
[freezeTies] :: Freeze n -> HashSet (Edge n)

-- | Encodes the decisions made in a split operation. Contains a list of
--   elaborations for every parent edge and note. Each elaboration contains
--   the child pitch, and the corresponding ornament. For every produced
--   edge, a decisions is made whether to keep it or not.
data Split n
SplitOp :: !Map (Edge n) [(Note n, DoubleOrnament)] -> !Map (InnerEdge n) [(Note n, PassingOrnament)] -> !Map (Note n) [(Note n, RightOrnament)] -> !Map (Note n) [(Note n, LeftOrnament)] -> !HashSet (Edge n) -> !HashSet (Edge n) -> !MultiSet (InnerEdge n) -> !MultiSet (InnerEdge n) -> Split n

-- | Maps every regular edge to a list of ornamentations.
[splitReg] :: Split n -> !Map (Edge n) [(Note n, DoubleOrnament)]

-- | Maps every passing edge to a passing tone. Since every passing edge is
--   elaborated exactly once but there can be several instances of the same
--   edge in a transition, the "same" edge can be elaborated with several
--   passing notes, one for each instance of the edge.
[splitPass] :: Split n -> !Map (InnerEdge n) [(Note n, PassingOrnament)]

-- | Maps notes from the left parent slice to lists of ornamentations.
[fromLeft] :: Split n -> !Map (Note n) [(Note n, RightOrnament)]

-- | Maps notes from the right parent slice to lists of ornamentations.
[fromRight] :: Split n -> !Map (Note n) [(Note n, LeftOrnament)]

-- | The set of regular edges to keep in the left child transition.
[keepLeft] :: Split n -> !HashSet (Edge n)

-- | The set of regular edges to keep in the right child transition.
[keepRight] :: Split n -> !HashSet (Edge n)

-- | Contains the new passing edges introduced in the left child transition
--   (excluding those passed down from the parent transition).
[passLeft] :: Split n -> !MultiSet (InnerEdge n)

-- | Contains the new passing edges introduced in the right child
--   transition (excluding those passed down from the parent transition).
[passRight] :: Split n -> !MultiSet (InnerEdge n)

-- | Two-sided ornament types (two parents).
data DoubleOrnament

-- | a full neighbor note
FullNeighbor :: DoubleOrnament

-- | a repetition of both parents (which have the same pitch)
FullRepeat :: DoubleOrnament

-- | a repetition of the right parent
LeftRepeatOfRight :: DoubleOrnament

-- | a repetitions of the left parent
RightRepeatOfLeft :: DoubleOrnament

-- | a note inserted at the top of the piece (between ⋊ and ⋉)
RootNote :: DoubleOrnament

-- | Returns <a>True</a> if the child repeats the left parent
isRepetitionOnLeft :: DoubleOrnament -> Bool

-- | Returns <a>True</a> if the child repeats the right parent
isRepetitionOnRight :: DoubleOrnament -> Bool

-- | Types of passing notes (two parents).
data PassingOrnament

-- | a connecting passing note (step to both parents)
PassingMid :: PassingOrnament

-- | a step from the left parent
PassingLeft :: PassingOrnament

-- | a step from the right parent
PassingRight :: PassingOrnament

-- | Types of single-sided ornaments left of the parent
--   (<tt>child-parent</tt>)
--   
--   <pre>
--   [ ] [p]
--       /
--     [c]
--   </pre>
data LeftOrnament

-- | an incomplete left neighbor
LeftNeighbor :: LeftOrnament

-- | an incomplete left repetition
LeftRepeat :: LeftOrnament

-- | Types of single-sided ornaments right of the parent
--   (<tt>parent--child</tt>).
--   
--   <pre>
--   [p] [ ]
--     \
--     [c]
--   </pre>
data RightOrnament

-- | an incomplete right neighbor
RightNeighbor :: RightOrnament

-- | an incomplete right repetition
RightRepeat :: RightOrnament

-- | Represents a spread operation. Records for every pitch how it is
--   distributed (see <tt>SpreadDirection</tt>). The resulting edges
--   (repetitions and passing edges) are represented in a child transition.
data Spread n
SpreadOp :: !HashMap (Note n) (SpreadChildren n) -> !Edges n -> Spread n

-- | Represents the children of a note that is spread out.
--   
--   A note can be distributed to either or both sub-slice.
data SpreadChildren n

-- | a single child in the left slice
SpreadLeftChild :: !Note n -> SpreadChildren n

-- | a single child in the right slice
SpreadRightChild :: !Note n -> SpreadChildren n

-- | two children, on in each slice
SpreadBothChildren :: !Note n -> !Note n -> SpreadChildren n

-- | Returns the left child of a spread note, if it exists
leftSpreadChild :: SpreadChildren n -> Maybe (Note n)

-- | Returns the right child of a spread note, if it exists
rightSpreadChild :: SpreadChildren n -> Maybe (Note n)

-- | <a>Leftmost</a> specialized to the split, freeze, and spread
--   operations of the grammar.
type PVLeftmost n = Leftmost Split n Freeze n Spread n

-- | An <a>Analysis</a> specialized to PV types.
type PVAnalysis n = Analysis Split n Freeze n Spread n Edges n Notes n

-- | Apply an applicative action to all pitches in an analysis.
analysisTraversePitch :: (Applicative f, Eq n', Hashable n', Ord n') => (n -> f n') -> PVAnalysis n -> f (PVAnalysis n')

-- | Map a function over all pitches in an analysis.
analysisMapPitch :: (Eq n', Hashable n', Ord n') => (n -> n') -> PVAnalysis n -> PVAnalysis n'

-- | Loads an analysis from a JSON file (as exported by the annotation
--   tool).
loadAnalysis :: FilePath -> IO (Either String (PVAnalysis SPitch))

-- | Loads an analysis from a JSON file (as exported by the annotation
--   tool). Converts all pitches to pitch classes.
loadAnalysis' :: FilePath -> IO (Either String (PVAnalysis SPC))

-- | Loads a MusicXML file and returns a list of salami slices. Each note
--   is expressed as a pitch and a flag that indicates whether the note
--   continues in the next slice.
slicesFromFile :: FilePath -> IO [[(Note SPitch, RightTied)]]

-- | Converts salami slices (as returned by <a>slicesFromFile</a>) to a
--   path as expected by parsers.
slicesToPath :: (Interval i, Ord i, Eq i) => [[(Note (Pitch i), RightTied)]] -> Path [Note (Pitch i)] [Edge (Pitch i)]

-- | Loads a MusicXML File and returns a surface path as input to parsers.
loadSurface :: FilePath -> IO (Path [Note SPitch] [Edge SPitch])

-- | Loads a MusicXML File and returns a surface path of the given range of
--   slices.
loadSurface' :: FilePath -> Int -> Int -> IO (Path [Note SPitch] [Edge SPitch])
instance GHC.Classes.Eq PVGrammar.DoubleOrnament
instance GHC.Classes.Eq n => GHC.Classes.Eq (PVGrammar.Edges n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (PVGrammar.Freeze n)
instance GHC.Classes.Eq PVGrammar.LeftOrnament
instance GHC.Classes.Eq n => GHC.Classes.Eq (PVGrammar.Note n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (PVGrammar.Notes n)
instance GHC.Classes.Eq PVGrammar.PassingOrnament
instance GHC.Classes.Eq PVGrammar.RightOrnament
instance GHC.Classes.Eq n => GHC.Classes.Eq (PVGrammar.Split n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (PVGrammar.Spread n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (PVGrammar.SpreadChildren n)
instance GHC.Internal.Data.Foldable.Foldable PVGrammar.Note
instance GHC.Internal.Data.Foldable.Foldable PVGrammar.SpreadChildren
instance Data.Aeson.Types.FromJSON.FromJSON PVGrammar.DoubleOrnament
instance (GHC.Classes.Eq n, Data.Hashable.Class.Hashable n, Musicology.Pitch.Class.Notation n) => Data.Aeson.Types.FromJSON.FromJSON (PVGrammar.Edges n)
instance (Musicology.Pitch.Class.Notation n, Data.Hashable.Class.Hashable n) => Data.Aeson.Types.FromJSON.FromJSON (PVGrammar.Freeze n)
instance Data.Aeson.Types.FromJSON.FromJSON PVGrammar.LeftOrnament
instance Musicology.Pitch.Class.Notation n => Data.Aeson.Types.FromJSON.FromJSON (PVGrammar.Note n)
instance (Musicology.Pitch.Class.Notation n, GHC.Classes.Eq n, Data.Hashable.Class.Hashable n) => Data.Aeson.Types.FromJSON.FromJSON (PVGrammar.Notes n)
instance Data.Aeson.Types.FromJSON.FromJSON PVGrammar.PassingOrnament
instance Data.Aeson.Types.FromJSON.FromJSON PVGrammar.RightOrnament
instance (Musicology.Pitch.Class.Notation n, GHC.Classes.Ord n, Data.Hashable.Class.Hashable n) => Data.Aeson.Types.FromJSON.FromJSON (PVGrammar.Split n)
instance (Musicology.Pitch.Class.Notation n, GHC.Classes.Eq n, Data.Hashable.Class.Hashable n) => Data.Aeson.Types.FromJSON.FromJSON (PVGrammar.Spread n)
instance Musicology.Pitch.Class.Notation n => Data.Aeson.Types.FromJSON.FromJSON (PVGrammar.SpreadChildren n)
instance GHC.Internal.Base.Functor PVGrammar.Note
instance GHC.Internal.Base.Functor PVGrammar.SpreadChildren
instance GHC.Internal.Generics.Generic PVGrammar.DoubleOrnament
instance GHC.Internal.Generics.Generic (PVGrammar.Edges n)
instance GHC.Internal.Generics.Generic (PVGrammar.Freeze n)
instance GHC.Internal.Generics.Generic PVGrammar.LeftOrnament
instance GHC.Internal.Generics.Generic (PVGrammar.Note n)
instance GHC.Internal.Generics.Generic (PVGrammar.Notes n)
instance GHC.Internal.Generics.Generic PVGrammar.PassingOrnament
instance GHC.Internal.Generics.Generic PVGrammar.RightOrnament
instance GHC.Internal.Generics.Generic (PVGrammar.Split n)
instance GHC.Internal.Generics.Generic (PVGrammar.Spread n)
instance GHC.Internal.Generics.Generic (PVGrammar.SpreadChildren n)
instance Data.Hashable.Class.Hashable n => Data.Hashable.Class.Hashable (PVGrammar.Edges n)
instance Data.Hashable.Class.Hashable n => Data.Hashable.Class.Hashable (PVGrammar.Note n)
instance Data.Hashable.Class.Hashable n => Data.Hashable.Class.Hashable (PVGrammar.Notes n)
instance Data.Hashable.Class.Hashable n => Data.Hashable.Class.Hashable (PVGrammar.Spread n)
instance Data.Hashable.Class.Hashable n => Data.Hashable.Class.Hashable (PVGrammar.SpreadChildren n)
instance Musicology.Pitch.Class.Notation n => GHC.Internal.Data.String.IsString (PVGrammar.Note n)
instance (Data.Hashable.Class.Hashable n, GHC.Classes.Eq n) => GHC.Internal.Base.Monoid (PVGrammar.Edges n)
instance (GHC.Classes.Ord n, Data.Hashable.Class.Hashable n) => GHC.Internal.Base.Monoid (PVGrammar.Split n)
instance Control.DeepSeq.NFData PVGrammar.DoubleOrnament
instance Control.DeepSeq.NFData n => Control.DeepSeq.NFData (PVGrammar.Edges n)
instance Control.DeepSeq.NFData n => Control.DeepSeq.NFData (PVGrammar.Freeze n)
instance Control.DeepSeq.NFData PVGrammar.LeftOrnament
instance Control.DeepSeq.NFData n => Control.DeepSeq.NFData (PVGrammar.Note n)
instance Control.DeepSeq.NFData n => Control.DeepSeq.NFData (PVGrammar.Notes n)
instance Control.DeepSeq.NFData PVGrammar.PassingOrnament
instance Control.DeepSeq.NFData PVGrammar.RightOrnament
instance Control.DeepSeq.NFData n => Control.DeepSeq.NFData (PVGrammar.Split n)
instance Control.DeepSeq.NFData n => Control.DeepSeq.NFData (PVGrammar.Spread n)
instance Control.DeepSeq.NFData n => Control.DeepSeq.NFData (PVGrammar.SpreadChildren n)
instance GHC.Classes.Ord PVGrammar.DoubleOrnament
instance GHC.Classes.Ord n => GHC.Classes.Ord (PVGrammar.Edges n)
instance GHC.Classes.Ord n => GHC.Classes.Ord (PVGrammar.Freeze n)
instance GHC.Classes.Ord PVGrammar.LeftOrnament
instance GHC.Classes.Ord n => GHC.Classes.Ord (PVGrammar.Note n)
instance GHC.Classes.Ord n => GHC.Classes.Ord (PVGrammar.Notes n)
instance GHC.Classes.Ord PVGrammar.PassingOrnament
instance GHC.Classes.Ord PVGrammar.RightOrnament
instance GHC.Classes.Ord n => GHC.Classes.Ord (PVGrammar.Split n)
instance GHC.Classes.Ord n => GHC.Classes.Ord (PVGrammar.Spread n)
instance GHC.Classes.Ord n => GHC.Classes.Ord (PVGrammar.SpreadChildren n)
instance (Data.Hashable.Class.Hashable n, GHC.Classes.Eq n) => GHC.Internal.Base.Semigroup (PVGrammar.Edges n)
instance (GHC.Classes.Ord n, Data.Hashable.Class.Hashable n) => GHC.Internal.Base.Semigroup (PVGrammar.Split n)
instance GHC.Internal.Show.Show PVGrammar.DoubleOrnament
instance Musicology.Pitch.Class.Notation n => GHC.Internal.Show.Show (PVGrammar.Edges n)
instance Musicology.Pitch.Class.Notation n => GHC.Internal.Show.Show (PVGrammar.Freeze n)
instance GHC.Internal.Show.Show PVGrammar.LeftOrnament
instance Musicology.Pitch.Class.Notation n => GHC.Internal.Show.Show (PVGrammar.Note n)
instance Musicology.Pitch.Class.Notation n => GHC.Internal.Show.Show (PVGrammar.Notes n)
instance GHC.Internal.Show.Show PVGrammar.PassingOrnament
instance GHC.Internal.Show.Show PVGrammar.RightOrnament
instance Musicology.Pitch.Class.Notation n => GHC.Internal.Show.Show (PVGrammar.Split n)
instance Musicology.Pitch.Class.Notation n => GHC.Internal.Show.Show (PVGrammar.Spread n)
instance Musicology.Pitch.Class.Notation n => GHC.Internal.Show.Show (PVGrammar.SpreadChildren n)
instance Data.Aeson.Types.ToJSON.ToJSON PVGrammar.DoubleOrnament
instance Musicology.Pitch.Class.Notation n => Data.Aeson.Types.ToJSON.ToJSON (PVGrammar.Edges n)
instance Musicology.Pitch.Class.Notation n => Data.Aeson.Types.ToJSON.ToJSON (PVGrammar.Freeze n)
instance Data.Aeson.Types.ToJSON.ToJSON PVGrammar.LeftOrnament
instance Musicology.Pitch.Class.Notation n => Data.Aeson.Types.ToJSON.ToJSON (PVGrammar.Note n)
instance Musicology.Pitch.Class.Notation n => Data.Aeson.Types.ToJSON.ToJSON (PVGrammar.Notes n)
instance Data.Aeson.Types.ToJSON.ToJSON PVGrammar.PassingOrnament
instance Data.Aeson.Types.ToJSON.ToJSON PVGrammar.RightOrnament
instance Musicology.Pitch.Class.Notation n => Data.Aeson.Types.ToJSON.ToJSON (PVGrammar.Split n)
instance Musicology.Pitch.Class.Notation n => Data.Aeson.Types.ToJSON.ToJSON (PVGrammar.Spread n)
instance Musicology.Pitch.Class.Notation n => Data.Aeson.Types.ToJSON.ToJSON (PVGrammar.SpreadChildren n)
instance GHC.Internal.Data.Traversable.Traversable PVGrammar.Note
instance GHC.Internal.Data.Traversable.Traversable PVGrammar.SpreadChildren


-- | This module contains functions for the generative aspects of
--   protovoice derivations:
--   
--   <ul>
--   <li>manually constructing protovoice operations (see <a>PVGrammar</a>)
--   using a monadic interface</li>
--   <li>applying ("replaying") these operations.</li>
--   </ul>
module PVGrammar.Generate

-- | Create a freeze operation. Can be used together with the <a>freeze</a>
--   action within a monadic derivation.
mkFreeze :: Hashable n => [InnerEdge n] -> Freeze n

-- | Create a split operation monadically
--   
--   <pre>
--   mkSplit $ do
--     ... -- internal split actions
--   </pre>
--   
--   Can be used together with the <a>split</a> action within a monadic
--   derivation.
mkSplit :: Writer (Split n) a -> Split n

-- | During a split, split an existing regular edge between two notes.
splitRegular :: (Ord n, Hashable n) => StartStop (Note n) -> StartStop (Note n) -> Note n -> DoubleOrnament -> Bool -> Bool -> Writer (Split n) ()

-- | During a split, split an existing passing edge, introducing a new
--   passing note.
splitPassing :: (Ord n, Hashable n) => Note n -> Note n -> Note n -> PassingOrnament -> Bool -> Bool -> Writer (Split n) ()

-- | During a split, add a new single-sided ornament to a left parent note.
addFromLeft :: (Ord n, Hashable n) => Note n -> Note n -> RightOrnament -> Bool -> Writer (Split n) ()

-- | During a split, add a new single-sided ornament to a right parent
--   note.
addFromRight :: (Ord n, Hashable n) => Note n -> Note n -> LeftOrnament -> Bool -> Writer (Split n) ()

-- | During a split, add a new passing edge between the left parent slice
--   and the child slice.
addPassingLeft :: (Ord n, Hashable n) => Note n -> Note n -> Writer (Split n) ()

-- | During a split, add a new passing edge between the child slice and the
--   right parent slice.
addPassingRight :: (Ord n, Hashable n) => Note n -> Note n -> Writer (Split n) ()

-- | Create a spread operation monadically
--   
--   <pre>
--   mkSpread $ do
--     ... -- internal spread actions
--   </pre>
--   
--   Can be used together with the <a>spread</a> action within a monadic
--   derivation.
mkSpread :: Writer (Endo (Spread n)) () -> Spread n

-- | A helper type to express the direction in which a note is spread + the
--   child(ren)'s new IDs.
data SpreadDir
ToLeft :: String -> SpreadDir
ToRight :: String -> SpreadDir
ToBoth :: String -> String -> SpreadDir

-- | During a spread, distribute one of the parent notes to the child
--   slices of a spread.
spreadNote :: (Ord n, Hashable n) => Note n -> SpreadDir -> Bool -> Writer (Endo (Spread n)) ()

-- | During a spread, add a new passing edge between the child slices of a
--   spread.
addPassing :: (Ord n, Hashable n) => Note n -> Note n -> Writer (Endo (Spread n)) ()

-- | During a spread, add a new repetition edge between two notes of the
--   same pitch class but from different octaves.
addOctaveRepetition :: (Ord n, Hashable n) => Note n -> Note n -> Writer (Endo (Spread n)) ()

-- | A derivation player for protovoices. The default version of the PV
--   player drops all edges that are not used later on when generating
--   child transitions. This behaviour matches the intermediate
--   representation of the parsers, which only track edges that are
--   necessary to explain the downstream notes. If you want to generate all
--   edges (i.e., all functional relations between notes) use
--   <a>derivationPlayerPVAllEdges</a>.
derivationPlayerPV :: (Eq n, Ord n, Notation n, Hashable n, Eq (IntervalOf n), HasPitch n) => DerivationPlayer (Split n) (Freeze n) (Spread n) (Notes n) (Edges n)

-- | A derivation player for protovoices that produces all edges that
--   express a functional relation between two notes. For a version that
--   only produces "necessary" edges, use <a>derivationPlayerPV</a>.
derivationPlayerPVAllEdges :: (Eq n, Ord n, Notation n, Hashable n, Eq (IntervalOf n), HasPitch n) => DerivationPlayer (Split n) (Freeze n) (Spread n) (Notes n) (Edges n)

-- | Tries to apply a split operation to the parent transition.
applySplit :: (Ord n, Notation n, Hashable n) => Split n -> Edges n -> Either String (Edges n, Notes n, Edges n)

-- | A variant of <a>applySplit</a> that inserts all protovoice edges into
--   the child transitions, even those that are not "kept" (used for
--   further elaboration). This is useful when you want to see all
--   relations between notes in the piece.
applySplitAllEdges :: (Ord n, Notation n, Hashable n) => Split n -> Edges n -> Either String (Edges n, Notes n, Edges n)

-- | Tries to apply a freeze operation to a transition.
applyFreeze :: (Eq (IntervalOf n), HasPitch n) => Freeze n -> Edges n -> Either String (Edges n)

-- | Tries to apply a spread operation to the parent transitions and slice.
applySpread :: (Ord n, Notation n, Hashable n) => Spread n -> Edges n -> Notes n -> Edges n -> Either String (Edges n, Notes n, Edges n, Notes n, Edges n)

-- | Indicates whether a transition can be frozen (i.e., doesn't contain
--   non-"tie" edges).
freezable :: (Eq (IntervalOf n), HasPitch n) => Edges n -> Bool

-- | A specialized version of <a>debugAnalysis</a> for protovoice
--   derivations. Prints the steps and intermediate configurations of a
--   derivation.
debugPVAnalysis :: (Notation n, Ord n, Hashable n, HasPitch n, Eq (IntervalOf n)) => PVAnalysis n -> IO (Either String ())

-- | Compares the output of a derivation with the original piece (as
--   provided to the parser). Returns <a>True</a> if the output matches the
--   original and <a>False</a> if the output doesn't match or the
--   derivation is invalid.
checkDerivation :: (Ord n, Notation n, Hashable n, Eq (IntervalOf n), HasPitch n, Show n) => [Leftmost (Split n) (Freeze n) (Spread n)] -> Path [Note n] [Edge n] -> Bool


-- | This module contains code that is specific to parsing the protovoice
--   grammar. It implements a number of evaluators (<a>Eval</a>) that can
--   be used with the various parsers.
module PVGrammar.Parse

-- | A constraint alias for note types.
type IsPitch n = (HasPitch n, Diatonic ICOf IntervalOf n, Eq ICOf IntervalOf n, Eq IntervalOf n)

-- | The evaluator that represents the proto-voice grammar. As scores it
--   returns a representation of each operation. These scores do not form a
--   semiring, but can be embedded into different semirings using
--   <a>mapEvalScore</a>.
protoVoiceEvaluator :: (Foldable t, Foldable t2, Eq n, Ord n, IsPitch n, Notation n, Hashable n) => Eval (Edges n) (t (Edge n)) (Notes n) (t2 (Note n)) (Spread n) (PVLeftmost n)

-- | A restricted version of the PV evaluator that prohibits split
--   operations in which one of the parent slices is repeated entirely.
protoVoiceEvaluatorNoRepSplit :: (Foldable t, Foldable t2, Eq n, Ord n, IsPitch n, Notation n, Hashable n) => Eval (Edges n) (t (Edge n)) (Notes n) (t2 (Note n)) (Spread n) (PVLeftmost n)

-- | An evaluator for protovoices that produces values in the
--   <a>Derivations</a> semiring.
pvDerivUnrestricted :: (Foldable t, Foldable t2, Eq n, Ord n, IsPitch n, Notation n, Hashable n) => Eval (Edges n) (t (Edge n)) (Notes n) (t2 (Note n)) (Spread n) (Derivations (PVLeftmost n))

-- | An evaluator for protovoices that produces values in the
--   <a>Derivations</a> semiring.
--   
--   <ul>
--   <li>Enforces right-branching spreads (see
--   <a>rightBranchSpread</a>).</li>
--   </ul>
pvDerivRightBranch :: (Foldable t, Foldable t2, Eq n, Ord n, IsPitch n, Notation n, Hashable n) => Eval (Merged, (RightBranchSpread, Edges n)) (t (Edge n)) ((), ((), Notes n)) (t2 (Note n)) ((), ((), Spread n)) (Derivations (PVLeftmost n))

-- | An evaluator for protovoices that produces values in the counting
--   semiring.
pvCountUnrestricted :: (Foldable t, Foldable t2, Eq n, Ord n, IsPitch n, Notation n, Hashable n) => Eval (Edges n) (t (Edge n)) (Notes n) (t2 (Note n)) (Spread n) Int

-- | An evaluator for protovoices that produces values in the counting
--   semiring.
--   
--   <ul>
--   <li>Prohibits split operations in which one of the parent slices is
--   repeated entirely (see <a>protoVoiceEvaluatorNoRepSplit</a>).</li>
--   </ul>
pvCountNoRepSplit :: (Foldable t, Foldable t2, Eq n, Ord n, IsPitch n, Notation n, Hashable n) => Eval (Edges n) (t (Edge n)) (Notes n) (t2 (Note n)) (Spread n) Int

-- | An evaluator for protovoices that produces values in the counting
--   semiring.
--   
--   <ul>
--   <li>Prohibits split operations in which one of the parent slices is
--   repeated entirely (see <a>protoVoiceEvaluatorNoRepSplit</a>).</li>
--   <li>Enforces right-branching spreads (see
--   <a>rightBranchSpread</a>).</li>
--   </ul>
pvCountNoRepSplitRightBranch :: (Foldable t, Foldable t2, Eq n, Ord n, IsPitch n, Notation n, Hashable n) => Eval (RightBranchSpread, Edges n) (t (Edge n)) ((), Notes n) (t2 (Note n)) ((), Spread n) Int

-- | An evaluator for protovoices that produces values in the counting
--   semiring.
--   
--   <ul>
--   <li>Prohibits split operations in which one of the parent slices is
--   repeated entirely (see <a>protoVoiceEvaluatorNoRepSplit</a>).</li>
--   <li>Enforces right-branching spreads (see
--   <a>rightBranchSpread</a>).</li>
--   <li>Normalizes the order of adjacent split and spread operations to
--   split-before-spread (see <a>splitFirst</a>).</li>
--   </ul>
pvCountNoRepSplitRightBranchSplitFirst :: (Foldable t, Foldable t2, Eq n, Ord n, IsPitch n, Notation n, Hashable n) => Eval (Merged, (RightBranchSpread, Edges n)) (t (Edge n)) ((), ((), Notes n)) (t2 (Note n)) ((), ((), Spread n)) Int

-- | Unfreezes a single transition, which may be <a>Nothing</a>.
pvThaw :: (Foldable t, Ord n, Hashable n) => Maybe (t (Edge n)) -> Edges n
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (PVGrammar.Parse.EdgeEither a b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d) => GHC.Classes.Eq (PVGrammar.Parse.Elaboration a b c d)
instance GHC.Internal.Generics.Generic (PVGrammar.Parse.EdgeEither a b)
instance GHC.Internal.Generics.Generic (PVGrammar.Parse.Elaboration a b c d)
instance (Data.Hashable.Class.Hashable a, Data.Hashable.Class.Hashable b) => Data.Hashable.Class.Hashable (PVGrammar.Parse.EdgeEither a b)
instance (Data.Hashable.Class.Hashable a, Data.Hashable.Class.Hashable b, Data.Hashable.Class.Hashable c, Data.Hashable.Class.Hashable d) => Data.Hashable.Class.Hashable (PVGrammar.Parse.Elaboration a b c d)
instance (Control.DeepSeq.NFData a, Control.DeepSeq.NFData b) => Control.DeepSeq.NFData (PVGrammar.Parse.EdgeEither a b)
instance (Control.DeepSeq.NFData a, Control.DeepSeq.NFData b, Control.DeepSeq.NFData c, Control.DeepSeq.NFData d) => Control.DeepSeq.NFData (PVGrammar.Parse.Elaboration a b c d)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (PVGrammar.Parse.EdgeEither a b)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d) => GHC.Classes.Ord (PVGrammar.Parse.Elaboration a b c d)
instance (GHC.Internal.Show.Show a, GHC.Internal.Show.Show b) => GHC.Internal.Show.Show (PVGrammar.Parse.EdgeEither a b)
instance (GHC.Internal.Show.Show a, GHC.Internal.Show.Show b, GHC.Internal.Show.Show c, GHC.Internal.Show.Show d) => GHC.Internal.Show.Show (PVGrammar.Parse.Elaboration a b c d)


-- | This module contains a simple (and musically rather naive)
--   probabilistic model of protovoice derivations. This model can be used
--   to sample a derivation, evaluate a derivations probability, or infer
--   posterior distributions of the model parmeters from given derivations
--   (i.e., "learn" the model's probabilities).
--   
--   This model is a <i>locally conjugate</i> model: It samples a
--   derivation using a sequence of random decisions with certain
--   probabilities. These probabilities are generally unknown, so they are
--   themselves modeled as random variables with prior distributions. The
--   full model &lt;math&gt; thus splits into &lt;math&gt; the prior over
--   the probability variables &lt;math&gt; and the likelihood of the
--   derivation(s) given these probabilities &lt;math&gt; Given all prior
--   decisions, the likelihood of a decision &lt;math&gt; based on some
--   parameter &lt;math&gt; &lt;math&gt; is <a>conjugate</a> with the prior
--   of that parameter &lt;math&gt;, which means that the posterior of the
--   parameters given one (or several) derivation(s) &lt;math&gt; can be
--   computed analytically.
--   
--   The parameters &lt;math&gt; and their prior distributions are
--   represented by the higher-kinded type <a>PVParams</a>. Different
--   instantiations of this type (using <a>Hyper</a> or <a>Probs</a>)
--   results in concrete record types that represent prior or posterior
--   distributions or concrete values (probabilities) for the parameters.
--   <a>PVParams</a> also supports <a>jeffreysPrior</a> and
--   <a>uniformPrior</a> as default priors, as well as <a>sampleProbs</a>
--   for sampling from a prior (see <a>Inferenc.Conjugate</a>).
--   
--   The likelihood &lt;math&gt; of a derivation is represented by
--   <a>sampleDerivation</a>. It can be executed under different "modes"
--   (probability monads) for sampling, inference, or tracing (see
--   <a>Inference.Conjugate</a>). The decisions during the derivation are
--   represented by a <a>Trace</a> (here <tt>Trace PVParams</tt>). In order
--   to learn from a given derivation, the corresponding trace can be
--   obtained using <a>observeDerivation</a>. A combination of getting a
--   trace and learning from it is provided by <a>trainSinglePiece</a>.
module PVGrammar.Prob.Simple

-- | The combined parameters for inner and outer operations.
data PVParams (f :: Type -> Type)
PVParams :: PVParamsOuter f -> PVParamsInner f -> PVParams (f :: Type -> Type)
[_pOuter] :: PVParams (f :: Type -> Type) -> PVParamsOuter f
[_pInner] :: PVParams (f :: Type -> Type) -> PVParamsInner f

-- | Parameters for decisions about outer operations (split, spread,
--   freeze).
data PVParamsOuter (f :: Type -> Type)
PVParamsOuter :: f Beta -> f Beta -> f Beta -> f Beta -> PVParamsOuter (f :: Type -> Type)
[_pSingleFreeze] :: PVParamsOuter (f :: Type -> Type) -> f Beta
[_pDoubleLeft] :: PVParamsOuter (f :: Type -> Type) -> f Beta
[_pDoubleLeftFreeze] :: PVParamsOuter (f :: Type -> Type) -> f Beta
[_pDoubleRightSplit] :: PVParamsOuter (f :: Type -> Type) -> f Beta

-- | Parameters for decisions about inner operations (elaboration and
--   distribution within splits and spreads).
data PVParamsInner (f :: Type -> Type)
PVParamsInner :: f Beta -> f Beta -> f Beta -> f Beta -> f Beta -> f Beta -> f Beta -> f Beta -> f Beta -> f Beta -> f Beta -> f Beta -> f Beta -> f Beta -> f Beta -> f Beta -> f Beta -> f Beta -> f Beta -> f Beta -> f (Dirichlet 3) -> f Beta -> f Beta -> PVParamsInner (f :: Type -> Type)
[_pElaborateRegular] :: PVParamsInner (f :: Type -> Type) -> f Beta
[_pElaborateL] :: PVParamsInner (f :: Type -> Type) -> f Beta
[_pElaborateR] :: PVParamsInner (f :: Type -> Type) -> f Beta
[_pRootFifths] :: PVParamsInner (f :: Type -> Type) -> f Beta
[_pKeepL] :: PVParamsInner (f :: Type -> Type) -> f Beta
[_pKeepR] :: PVParamsInner (f :: Type -> Type) -> f Beta
[_pRepeatOverNeighbor] :: PVParamsInner (f :: Type -> Type) -> f Beta
[_pNBChromatic] :: PVParamsInner (f :: Type -> Type) -> f Beta
[_pNBAlt] :: PVParamsInner (f :: Type -> Type) -> f Beta
[_pRepeatLeftOverRight] :: PVParamsInner (f :: Type -> Type) -> f Beta
[_pRepeatAlter] :: PVParamsInner (f :: Type -> Type) -> f Beta
[_pRepeatAlterUp] :: PVParamsInner (f :: Type -> Type) -> f Beta
[_pRepeatAlterSemis] :: PVParamsInner (f :: Type -> Type) -> f Beta
[_pConnect] :: PVParamsInner (f :: Type -> Type) -> f Beta
[_pConnectChromaticLeftOverRight] :: PVParamsInner (f :: Type -> Type) -> f Beta
[_pPassUp] :: PVParamsInner (f :: Type -> Type) -> f Beta
[_pPassLeftOverRight] :: PVParamsInner (f :: Type -> Type) -> f Beta
[_pNewPassingLeft] :: PVParamsInner (f :: Type -> Type) -> f Beta
[_pNewPassingRight] :: PVParamsInner (f :: Type -> Type) -> f Beta
[_pNewPassingMid] :: PVParamsInner (f :: Type -> Type) -> f Beta
[_pNoteSpreadDirection] :: PVParamsInner (f :: Type -> Type) -> f (Dirichlet 3)
[_pNotesOnOtherSide] :: PVParamsInner (f :: Type -> Type) -> f Beta
[_pSpreadRepetitionEdge] :: PVParamsInner (f :: Type -> Type) -> f Beta
savePVHyper :: FilePath -> Hyper PVParams -> IO ()
loadPVHyper :: FilePath -> IO (Either String (Hyper PVParams))

-- | A probabilistic program that samples a derivation starting from a
--   given root path. Can be interpreted by the interpreter functions in
--   <a>Inference.Conjugate</a>.
sampleDerivation :: (SampleCtx m Bernoulli, SampleCtx m Geometric1, SampleCtx m Geometric0, SampleCtx m MagicalOctaves, SampleCtx m MagicalID, SampleCtx m (Categorical 3), RandomInterpreter m PVParams) => Path (Edges SPitch) (Notes SPitch) -> m (Either String [PVLeftmost SPitch])

-- | A shorthand for <a>sampleDerivation</a> starting from ⋊——⋉.
sampleDerivation' :: (SampleCtx m Bernoulli, SampleCtx m Geometric1, SampleCtx m Geometric0, SampleCtx m MagicalOctaves, SampleCtx m MagicalID, SampleCtx m (Categorical 3), RandomInterpreter m PVParams) => m (Either String [PVLeftmost SPitch])

-- | Walk through a derivation (starting at a given root path) and return
--   the corresponding <a>Trace</a> (if possible). The trace can be used
--   together with <a>sampleDerivation</a> for inference
--   (<a>getPosterior</a>) or for showing the trace (<a>printTrace</a>).
observeDerivation :: [PVLeftmost SPitch] -> Path (Edges SPitch) (Notes SPitch) -> Either String (Trace PVParams)

-- | A shorthand for <a>observeDerivation</a> starting from ⋊——⋉.
observeDerivation' :: [PVLeftmost SPitch] -> Either String (Trace PVParams)

-- | A helper function that tests whether <a>observeDerivation'</a>
--   followed by <a>sampleDerivation'</a> restores the original derivation.
--   Useful for testing the compatibility of the two functions.
roundtrip :: FilePath -> IO (Either String ())

-- | Helper function: Load a single derivation and infer the corresponding
--   posterior for a uniform prior.
trainSinglePiece :: FilePath -> IO (Maybe (PVParams HyperRep))

-- | Sample a single step in a bottom-up context. Only used for evaluating
--   the probability of a step, therefore returns <tt>()</tt>.
sampleSingleStepParsing :: (SampleCtx m Bernoulli, SampleCtx m Geometric1, SampleCtx m Geometric0, SampleCtx m MagicalOctaves, SampleCtx m MagicalID, RandomInterpreter m PVParams) => ContextSingle SPitch -> m ()

-- | Observerse a single step in a bottom-up context. Since double
--   operations don't know whether they have to make a "continueLeft"
--   decision when going bottom-up, this decision is moved to the previous
--   step, where the context is know. Therefore, if the following step
--   would have to make this decision, it is added here.
observeSingleStepParsing :: ContextSingle SPitch -> Maybe Bool -> LeftmostSingle (Split SPitch) (Freeze SPitch) -> Either String (Trace PVParams)
evalSingleStep :: Probs PVParams -> ContextSingle SPitch -> LeftmostSingle (Split SPitch) (Freeze SPitch) -> Maybe Bool -> Either String (Maybe ((), Double))

-- | Sample a double step in a bottom-up context. Only used for evaluating
--   the probability of a step, therefore takes the "resulting" op and
--   returns <tt>()</tt>.
sampleDoubleStepParsing :: (SampleCtx m Bernoulli, SampleCtx m Geometric1, SampleCtx m Geometric0, SampleCtx m MagicalOctaves, SampleCtx m MagicalID, SampleCtx m (Categorical 3), RandomInterpreter m PVParams) => ContextDouble SPitch -> LeftmostDouble (Split SPitch) (Freeze SPitch) (Spread SPitch) -> m ()

-- | Observerse a double step without knowing if it happened after a right
--   split (e.g., when parsing). The extra decision that is necessary if it
--   doesn't follow a right split is "moved" to the previous step.
--   Therefore, this step is rated as if it follows a right split (not
--   making the decision). In addition, if the following step would have to
--   make the extra decision, it is added here.
observeDoubleStepParsing :: ContextDouble SPitch -> Maybe Bool -> LeftmostDouble (Split SPitch) (Freeze SPitch) (Spread SPitch) -> Either String (Trace PVParams)
evalDoubleStep :: Probs PVParams -> ContextDouble SPitch -> LeftmostDouble (Split SPitch) (Freeze SPitch) (Spread SPitch) -> Maybe Bool -> Either String (Maybe ((), Double))
instance Inference.Conjugate.Distribution PVGrammar.Prob.Simple.MagicalID
instance Inference.Conjugate.Distribution PVGrammar.Prob.Simple.MagicalOctaves
instance GHC.Classes.Eq PVGrammar.Prob.Simple.MagicalID
instance GHC.Classes.Eq PVGrammar.Prob.Simple.MagicalOctaves
instance Data.Aeson.Types.FromJSON.FromJSON (Inference.Conjugate.HyperRep Inference.Conjugate.Beta)
instance Data.Aeson.Types.FromJSON.FromJSON (Inference.Conjugate.HyperRep (Inference.Conjugate.Dirichlet 3))
instance (Data.Aeson.Types.FromJSON.FromJSON (f Inference.Conjugate.Beta), Data.Aeson.Types.FromJSON.FromJSON (f (Inference.Conjugate.Dirichlet 3))) => Data.Aeson.Types.FromJSON.FromJSON (PVGrammar.Prob.Simple.PVParams f)
instance (Data.Aeson.Types.FromJSON.FromJSON (f Inference.Conjugate.Beta), Data.Aeson.Types.FromJSON.FromJSON (f (Inference.Conjugate.Dirichlet 3))) => Data.Aeson.Types.FromJSON.FromJSON (PVGrammar.Prob.Simple.PVParamsInner f)
instance Data.Aeson.Types.FromJSON.FromJSON (f Inference.Conjugate.Beta) => Data.Aeson.Types.FromJSON.FromJSON (PVGrammar.Prob.Simple.PVParamsOuter f)
instance GHC.Internal.Generics.Generic (Inference.Conjugate.HyperRep Inference.Conjugate.Beta)
instance GHC.Internal.Generics.Generic (Inference.Conjugate.HyperRep (Inference.Conjugate.Dirichlet 3))
instance GHC.Internal.Generics.Generic (PVGrammar.Prob.Simple.PVParams f)
instance GHC.Internal.Generics.Generic (PVGrammar.Prob.Simple.PVParamsInner f)
instance GHC.Internal.Generics.Generic (PVGrammar.Prob.Simple.PVParamsOuter f)
instance GHC.Classes.Ord PVGrammar.Prob.Simple.MagicalID
instance GHC.Classes.Ord PVGrammar.Prob.Simple.MagicalOctaves
instance GHC.Internal.Show.Show PVGrammar.Prob.Simple.MagicalID
instance GHC.Internal.Show.Show PVGrammar.Prob.Simple.MagicalOctaves
instance (GHC.Internal.Show.Show (f Inference.Conjugate.Beta), GHC.Internal.Show.Show (f (Inference.Conjugate.Dirichlet 3))) => GHC.Internal.Show.Show (PVGrammar.Prob.Simple.PVParams f)
instance (GHC.Internal.Show.Show (f Inference.Conjugate.Beta), GHC.Internal.Show.Show (f (Inference.Conjugate.Dirichlet 3))) => GHC.Internal.Show.Show (PVGrammar.Prob.Simple.PVParamsInner f)
instance GHC.Internal.Show.Show (f Inference.Conjugate.Beta) => GHC.Internal.Show.Show (PVGrammar.Prob.Simple.PVParamsOuter f)
instance Data.Aeson.Types.ToJSON.ToJSON (Inference.Conjugate.HyperRep Inference.Conjugate.Beta)
instance Data.Aeson.Types.ToJSON.ToJSON (Inference.Conjugate.HyperRep (Inference.Conjugate.Dirichlet 3))
instance (Data.Aeson.Types.ToJSON.ToJSON (f Inference.Conjugate.Beta), Data.Aeson.Types.ToJSON.ToJSON (f (Inference.Conjugate.Dirichlet 3))) => Data.Aeson.Types.ToJSON.ToJSON (PVGrammar.Prob.Simple.PVParams f)
instance (Data.Aeson.Types.ToJSON.ToJSON (f Inference.Conjugate.Beta), Data.Aeson.Types.ToJSON.ToJSON (f (Inference.Conjugate.Dirichlet 3))) => Data.Aeson.Types.ToJSON.ToJSON (PVGrammar.Prob.Simple.PVParamsInner f)
instance Data.Aeson.Types.ToJSON.ToJSON (f Inference.Conjugate.Beta) => Data.Aeson.Types.ToJSON.ToJSON (PVGrammar.Prob.Simple.PVParamsOuter f)


-- | <i>This module is deprecated, use <a>Scoring.FunTyped</a> instead.</i>
--   
--   Semiring scores with "holes". Holes are used to express "partially
--   applied" scores that occur when the score of a verticalization
--   (unspread) is distributed to two parent edges. The full score of the
--   operation is restored when the two parent edges are eventually
--   combined again.
--   
--   This module implements partial scores using lists, which is slow and
--   not very elegant. The grammar combinators are partial and will fail if
--   used incorrectly, indicating parser bugs.
module Scoring.Deprecated.Flat

-- | A partially applied score of type <tt>s</tt>. Comes in four variants,
--   depending on whether the score is fully applied or needs to be
--   combined on either or both sides. Values that need to be combined are
--   lists that represent scores with holes. Each variant carries IDs of
--   type <tt>i</tt> that determine which objects fit on either of its
--   sides. Only score objects with matching IDs can be combined.
--   
--   As a shorthand notation, we use <tt>a-b</tt> to indicate a value that
--   depends on <tt>a</tt> on its left and on <tt>b</tt> on its right. If
--   the value does not depend on anything on either side, we use
--   <tt>()</tt>, i.e. <tt>()-a</tt> stands for <tt>SLeft _ a</tt> and
--   <tt>()-()</tt> stands for <tt>SVal _</tt>.
data Score s i

-- | Carries a fully applied value
SVal :: !s -> Score s i

-- | The right part of a combination, expects an argument to its left.
--   Implemented as a list of right elements
SRight :: !LeftId i -> ![Holes s] -> Score s i

-- | The left part of a combination, expects an argument to its right.
--   Implemented as a list of right elements
SLeft :: ![Holes s] -> !RightId i -> Score s i

-- | A combination of <a>SLeft</a> and <a>SRight</a> that expects arguments
--   on both sides. Implemented as a list of right elements on the left and
--   a list of left elements to the right
SBoth :: !LeftId i -> ![(Holes s, Holes s)] -> !RightId i -> Score s i

-- | A type alias for the holes in a <a>Score</a>.
type Holes s = [s]

-- | Creates a simple value score of type ()-().
val :: s -> Score s i

-- | Newtype for the left ID of a partial score.
newtype LeftId i
LeftId :: i -> LeftId i

-- | Newtype for the right ID of a partial score.
newtype RightId i
RightId :: i -> RightId i

-- | Returns the ID on the left side of an <a>Score</a>, or <a>Nothing</a>
--   for <a>SVal</a> and <a>SLeft</a>.
--   
--   <pre>
--   a-b -&gt; a
--   </pre>
leftSide :: Score s i -> Maybe (LeftId i)

-- | Returns the ID on the right side of an <a>Score</a>, or <a>Nothing</a>
--   for <a>SVal</a> and <a>SRight</a>.
--   
--   <pre>
--   a-b -&gt; b
--   </pre>
rightSide :: Score s i -> Maybe (RightId i)

-- | Returns a string representation of a <a>Score</a> (more compact than
--   it's <a>Show</a> instance).
showScore :: (Show s, Show i) => Score s i -> String

-- | Combines two partially applied <a>Score</a>s by applying them to each
--   other and/or multiplying the underlying semiring values. Shapes and
--   IDs at the adjacent sides must match, otherwise <a>Nothing</a> is
--   returned.
--   
--   <pre>
--   a-b × b-c -&gt; a-c
--   </pre>
times :: (Semiring s, Eq i, Show i) => Score s i -> Score s i -> Maybe (Score s i)

-- | Adds two partially applied <a>Score</a>s by adding their underlying
--   (or resulting) semiring values. This operation is only admitted if the
--   two scores are of the same shape and have matching IDs. Otherwise,
--   <a>Nothing</a> is returned.
--   
--   <pre>
--   a-b + a-b -&gt; a-b
--   </pre>
plus :: (Semiring s, Eq i) => Score s i -> Score s i -> Maybe (Score s i)

-- | Combines the <a>Score</a>s of two edges with a <tt>split</tt>
--   operation into the score of the parent edge. This is expected to be
--   called on compatible scores and will throw an error otherwise to
--   indicate parser bugs.
--   
--   <pre>
--   a-b   b-c
--   --------- unsplit
--      a-c
--   </pre>
unsplitScores :: (Semiring s, Eq i, Show i, Show s) => s -> Score s i -> Score s i -> Score s i

-- | Creates the <a>Score</a> of a left parent edge from a left child edge
--   of an <tt>unspread</tt>. Will throw an error if called on invalid
--   input to indicate parser bugs.
unspreadScoresLeft :: (Eq i, Show i, Semiring s, Show s) => i -> Score s i -> Score s i

-- | Creates the <a>Score</a> of a right parent edge from the middle and
--   right child edges of an <tt>unspread</tt> and a <tt>spread</tt>
--   operation.
unspreadScoresRight :: (Eq i, Semiring s, Show i, Show s) => i -> s -> Score s i -> Score s i -> Score s i

-- | Adds two <a>Score</a>s that are alternative derivations of the same
--   transition. This is expected to be called on compatible scores and
--   will throw an error otherwise to indicate parser bugs.
--   
--   <pre>
--   a-b   a-b
--   --------- add
--      a-b
--   </pre>
addScores :: (Semiring s, Eq i) => Score s i -> Score s i -> Score s i

-- | Extracts the value from a fully applied <a>Score</a>. This function is
--   intended to be used to extract the final score of the parser. If the
--   score is not fully applied, throws an exception to indicate parser
--   bugs.
getScoreVal :: Score s i -> s
instance GHC.Classes.Eq i => GHC.Classes.Eq (Scoring.Deprecated.Flat.LeftId i)
instance GHC.Classes.Eq i => GHC.Classes.Eq (Scoring.Deprecated.Flat.RightId i)
instance GHC.Internal.Generics.Generic (Scoring.Deprecated.Flat.LeftId i)
instance GHC.Internal.Generics.Generic (Scoring.Deprecated.Flat.RightId i)
instance GHC.Internal.Generics.Generic (Scoring.Deprecated.Flat.Score s i)
instance Data.Hashable.Class.Hashable i => Data.Hashable.Class.Hashable (Scoring.Deprecated.Flat.LeftId i)
instance Data.Hashable.Class.Hashable i => Data.Hashable.Class.Hashable (Scoring.Deprecated.Flat.RightId i)
instance Control.DeepSeq.NFData i => Control.DeepSeq.NFData (Scoring.Deprecated.Flat.LeftId i)
instance Control.DeepSeq.NFData i => Control.DeepSeq.NFData (Scoring.Deprecated.Flat.RightId i)
instance (Control.DeepSeq.NFData s, Control.DeepSeq.NFData i) => Control.DeepSeq.NFData (Scoring.Deprecated.Flat.Score s i)
instance GHC.Classes.Ord i => GHC.Classes.Ord (Scoring.Deprecated.Flat.LeftId i)
instance GHC.Classes.Ord i => GHC.Classes.Ord (Scoring.Deprecated.Flat.RightId i)
instance GHC.Internal.Show.Show i => GHC.Internal.Show.Show (Scoring.Deprecated.Flat.LeftId i)
instance GHC.Internal.Show.Show i => GHC.Internal.Show.Show (Scoring.Deprecated.Flat.RightId i)
instance (GHC.Internal.Show.Show i, GHC.Internal.Show.Show s) => GHC.Internal.Show.Show (Scoring.Deprecated.Flat.Score s i)


-- | Semiring scores with "holes". Holes are used to express "partially
--   applied" scores that occur when the score of a verticalization
--   (unspread) is distributed to the two parent edges. The full score of
--   the operation is restored when the two parent edges are eventually
--   combined again.
--   
--   This module implements partial scores as typesafe functions with
--   phantom types that indicate the number of holes on each side. The
--   grammatical combinators use an existential type <a>Score</a> that
--   reifies the phantom types as singletons, which allows different scores
--   to be easily stored together and is compatible with the <a>Score</a>
--   types from the other Scoring* modules. Thus, the grammatical
--   combinators are partial and fail when used with incompatible scores,
--   indicating a parser bug.
module Scoring.FunTyped

-- | A paritally applied score of type <tt>s</tt> with an unknown number of
--   holes (as used by the <a>ChartParser</a>). Wraps a <a>TypedScore</a>
--   together with witnesses for the number of holes on each side.
data Score s i
[MkScore] :: forall (nl :: Nat) (nr :: Nat) s i. SNat nl -> SNat nr -> TypedScore nl nr s i -> Score s i

-- | A partially applied score of type <tt>s</tt>. Comes in four variants,
--   depending on whether the score is fully applied or needs to be
--   combined on either or both sides. Values that need to be combined are
--   lists that represent scores with holes. Each variant carries IDs of
--   type <tt>i</tt> that determine which objects fit on either of its
--   sides. Only score objects with matching IDs can be combined.
--   
--   As a shorthand notation, we use <tt>a-b</tt> to indicate a value that
--   depends on <tt>a</tt> on its left and on <tt>b</tt> on its right. If
--   the value does not depend on anything on either side, we use
--   <tt>()</tt>, i.e. <tt>()-a</tt> stands for <tt>SLeft _ a</tt> and
--   <tt>()-()</tt> stands for <tt>SVal _</tt>.
data TypedScore (nl :: Nat) (nr :: Nat) s i

-- | Carries a fully applied value
[SVal] :: forall s i. !s -> TypedScore 'Z 'Z s i

-- | The right part of a combination, expects an argument to its left.
--   Implemented as a function that takes a left counterpart and returns a
--   score with fewer holes.
[SRight] :: forall i (nl1 :: Nat) s. !LeftId i -> !RightHoles nl1 s -> TypedScore ('S nl1) 'Z s i

-- | The left part of a combination, expects an argument to its right.
--   Implemented as a function that takes a right hole and applies it.
[SLeft] :: forall (nr1 :: Nat) s i. !LeftHoles nr1 s -> !RightId i -> TypedScore 'Z ('S nr1) s i

-- | A combination of <a>SLeft</a> and <a>SRight</a> that expects arguments
--   on both sides. Implemented as a function that expects both a right and
--   a left hole to be complete.
[SBoth] :: forall i (nl1 :: Nat) (nr1 :: Nat) s. !LeftId i -> !BothHoles nl1 nr1 s -> !RightId i -> TypedScore ('S nl1) ('S nr1) s i

-- | Creates a simple value score of type ()-().
val :: s -> Score s i

-- | Returns a string representation of a <a>Score</a> (more compact than
--   it's <a>Show</a> instance).
showScore :: (Show s, Show i) => Score s i -> String

-- | Newtype for the left ID of a partial score.
newtype LeftId i
LeftId :: i -> LeftId i

-- | Newtype for the right ID of a partial score.
newtype RightId i
RightId :: i -> RightId i

-- | Returns the ID on the left side of an <a>Score</a>, or <a>Nothing</a>
--   for <a>SVal</a> and <a>SLeft</a>.
--   
--   <pre>
--   a-b -&gt; a
--   </pre>
leftSide :: Score s i -> Maybe (LeftId i)

-- | Returns the ID on the right side of an <a>Score</a>, or <a>Nothing</a>
--   for <a>SVal</a> and <a>SRight</a>.
--   
--   <pre>
--   a-b -&gt; b
--   </pre>
rightSide :: Score s i -> Maybe (RightId i)

-- | The type of a function representing <tt>n</tt> left holes.
type LeftHoles (n :: Nat) s = RightHoles n s -> s

-- | The type of a function representing <tt>n</tt> right holes.
type RightHoles (n :: Nat) s = s -> RightHole n s

-- | A single right hole (helper for <a>RightHoles</a>).
data RightHole (n :: Nat) s

-- | The type of a function containing <tt>nl</tt> left and <tt>nr</tt>
--   right holes.
type BothHoles (nl :: Nat) (nr :: Nat) s = RightHoles nr s -> RightHoles nl s

-- | Combines two partially applied <a>Score</a>s by applying them to each
--   other and/or multiplying the underlying semiring values. Shapes and
--   IDs at the adjacent sides must match, otherwise <a>Nothing</a> is
--   returned.
--   
--   <pre>
--   a-b × b-c -&gt; a-c
--   </pre>
times :: forall s i (nl :: Nat) (n :: Nat) (nr :: Nat). (Semiring s, Eq i, Show i) => TypedScore nl n s i -> TypedScore n nr s i -> Maybe (TypedScore nl nr s i)

-- | Adds two partially applied <a>TypedScore</a>s by adding their
--   underlying (or resulting) semiring values. This operation is only
--   admitted if the two scores are of the same shape and have matching
--   IDs. Otherwise, <a>Nothing</a> is returned.
--   
--   <pre>
--   a-b + a-b -&gt; a-b
--   </pre>
plus :: forall s i (nl :: Nat) (nr :: Nat). (Semiring s, Eq i) => TypedScore nl nr s i -> TypedScore nl nr s i -> Maybe (TypedScore nl nr s i)

-- | Combines the <a>Score</a>s of two edges with a <tt>split</tt>
--   operation into the score of the parent edge. This is expected to be
--   called on compatible scores and will throw an error otherwise to
--   indicate parser bugs.
--   
--   <pre>
--   a-b   b-c
--   --------- unsplit
--      a-c
--   </pre>
unsplitScores :: (Semiring s, Eq i, Show i, Show s) => s -> Score s i -> Score s i -> Score s i

-- | Creates the <a>Score</a> of a left parent edge from a left child edge
--   of an <tt>unspread</tt>. Will throw an error if called on invalid
--   input to indicate parser bugs.
unspreadScoresLeft :: forall s i. (Eq i, Show i, Semiring s, Show s) => i -> Score s i -> Score s i

-- | Creates the <a>Score</a> of a right parent edge from the middle and
--   right child edges of an <tt>unspread</tt> and a <tt>spread</tt>
--   operation.
unspreadScoresRight :: (Eq i, Semiring s, Show i, Show s) => i -> s -> Score s i -> Score s i -> Score s i

-- | Adds two <a>Score</a>s that are alternative derivations of the same
--   transition. This is expected to be called on compatible scores and
--   will throw an error otherwise to indicate parser bugs.
--   
--   <pre>
--   a-b   a-b
--   --------- add
--      a-b
--   </pre>
addScores :: (Semiring s, Eq i) => Score s i -> Score s i -> Score s i

-- | Extracts the value from a fully applied <a>Score</a>. This function is
--   intended to be used to extract the final score of the parser. If the
--   score is not fully applied, throws an exception to indicate parser
--   bugs.
getScoreVal :: Score s i -> s
instance Scoring.FunTyped.AddHole ('Data.Nat.S n)
instance Scoring.FunTyped.AddHole 'Data.Nat.Z
instance GHC.Classes.Eq i => GHC.Classes.Eq (Scoring.FunTyped.LeftId i)
instance GHC.Classes.Eq i => GHC.Classes.Eq (Scoring.FunTyped.RightId i)
instance GHC.Internal.Generics.Generic (Scoring.FunTyped.LeftId i)
instance GHC.Internal.Generics.Generic (Scoring.FunTyped.RightId i)
instance Data.Hashable.Class.Hashable i => Data.Hashable.Class.Hashable (Scoring.FunTyped.LeftId i)
instance Data.Hashable.Class.Hashable i => Data.Hashable.Class.Hashable (Scoring.FunTyped.RightId i)
instance Control.DeepSeq.NFData i => Control.DeepSeq.NFData (Scoring.FunTyped.LeftId i)
instance Control.DeepSeq.NFData s => Control.DeepSeq.NFData (Scoring.FunTyped.RightHole n s)
instance Control.DeepSeq.NFData i => Control.DeepSeq.NFData (Scoring.FunTyped.RightId i)
instance (Control.DeepSeq.NFData s, Control.DeepSeq.NFData i) => Control.DeepSeq.NFData (Scoring.FunTyped.Score s i)
instance (Control.DeepSeq.NFData s, Control.DeepSeq.NFData i) => Control.DeepSeq.NFData (Scoring.FunTyped.TypedScore nl nr s i)
instance GHC.Classes.Ord i => GHC.Classes.Ord (Scoring.FunTyped.LeftId i)
instance GHC.Classes.Ord i => GHC.Classes.Ord (Scoring.FunTyped.RightId i)
instance GHC.Internal.Show.Show i => GHC.Internal.Show.Show (Scoring.FunTyped.LeftId i)
instance GHC.Internal.Show.Show i => GHC.Internal.Show.Show (Scoring.FunTyped.RightId i)
instance GHC.Internal.Show.Show i => GHC.Internal.Show.Show (Scoring.FunTyped.Score s i)
instance GHC.Internal.Show.Show i => GHC.Internal.Show.Show (Scoring.FunTyped.TypedScore nl nr s i)


-- | A chart-based semiring parser for path grammars (e.g. the PV grammar).
--   Path grammars operate on "paths" consisting of nodes (slices) and
--   edges (transitions), both of which can contain arbitrary content.
--   Paths are elaborated through two operations, <tt>split</tt>ting
--   transitions and <tt>spread</tt>ing slices (plus <tt>freeze</tt>, which
--   terminates generation on a transition).
--   
--   The parser is polymorphic in the grammar as well as the contents of
--   slices (path nodes) and transitions (path edges). The grammar to parse
--   is definend in an "evaluator" (<a>Eval</a>) which provides completions
--   for parsing the splits, spreads and freezes.
module ChartParser

-- | The main entrypoint to the parser. Expects an evaluator for the
--   specific grammar and an input path. Returns the combined semiring
--   value of all full derivations.
parse :: Parsable tr slc h v => (TChart tr slc v -> Either (VChart tr slc h v) [Slice slc] -> Int -> IO ()) -> Eval tr tr' slc slc' h v -> Path slc' tr' -> IO v

-- | Parse a piece using the <a>logSize</a> logging function.
parseSize :: Parsable tr slc h v => Eval tr tr' slc slc' h v -> Path slc' tr' -> IO v

-- | Parse a piece without logging.
parseSilent :: Parsable tr slc h v => Eval tr tr' slc slc' h v -> Path slc' tr' -> IO v

-- | A logging function that logs the sice of the charts at each level.
logSize :: TChart tr1 slc1 v1 -> Either (VChart tr2 slc2 h2 v2) [Slice slc2] -> Int -> IO ()

-- | A logging function that emits the state of the chart in TikZ code at
--   every level.
logTikz :: (Foldable t, Show slc1, Show slc2, Hashable tr1, Eq slc3) => TChart tr1 slc3 v1 -> Either (VChart tr2 slc1 h v2) (t (Slice slc2)) -> Int -> IO ()

-- | A slice during chart parsing. Besides the slice content (e.g., notes),
--   it maintains indices to the first and last surface slice covered, as
--   well as an ID that is used for matching compatible parents of a
--   spread.
data Slice slc

-- | A transition during chart parsing. Has pointers to the two slices it
--   connects, a content (e.g., protovoice connections), and a flag
--   indicating whether it is the second (right) parent of a spread.
data Transition tr slc

-- | Returns the "length" of the transition in terms of surface slices
--   covered.
transLen :: Transition e a -> Int

-- | A parsing item. Combines an intermediate value (e.g. a transition)
--   with a semiring score.
data Item i v

-- | A transition item.
type TItem tr slc v = Item Transition tr slc v

-- | The contents of a transition chart (under a particular index). A
--   mapping from transitions (with score ID constraints left and right) to
--   (partial) semiring scores. This mapping usually contains all
--   transition items that satisfy a certain criterion, irrespective of
--   their position in the chart (which is encoded in the transitions
--   themselves).
--   
--   When new transition items are added, if the transition already exists
--   in the chart (as the result of a different partial parse), the scores
--   of the new and existing items are "added" (this also requires the
--   score IDs to match).
type TContents tr slc v = HashMap (Transition tr slc, Maybe LeftId Int, Maybe RightId Int) Score v Int

-- | A transition chart. Stores intermediate transition items redundantly
--   under several indices:
--   
--   <ul>
--   <li>by surface length</li>
--   <li>by left slice</li>
--   <li>by right slice</li>
--   </ul>
data TChart tr slc v

-- | Returns all transition items with the same length.
tcGetByLength :: TChart tr slc v -> Int -> [TItem tr slc v]

-- | Represents the middle part of an incomplete unspread
--   ("verticalization"). Expresses how the middle transition and the two
--   child slices (<tt>vMiddle</tt>) are derived from the parent slice
--   (<tt>vTop</tt>) using a spread operation (<tt>vOp</tt>).
--   
--   <a>Vert</a> objects are stored in the <a>VChart</a> to record the
--   intermediate steps of an unspread, which is found by first parsing the
--   middle transition into the parent slice (generating a <a>Vert</a>) and
--   then combining the <a>Vert</a> with the left and right child
--   transitions to generate the left and right parent transitions,
--   respectively.
data Vert tr slc h v

-- | A verticalization chart. Stores <a>Vert</a> objects at certain chart
--   positions. To support efficient lookup of <a>Vert</a> objects from
--   different indices, each <a>Vert</a> is redundantly stored in several
--   hash maps, one for each index:
--   
--   <ul>
--   <li>by surface length</li>
--   <li>by surface length (only left border of a <a>Vert</a>)</li>
--   <li>by left child slice ID and mid transition length</li>
--   <li>by right child ID</li>
--   </ul>
--   
--   In addition, the <a>VChart</a> maintains IDs of new slices. (Every new
--   slice is the parent of an unspread.)
data VChart tr slc h v

-- | Returns all <a>Vert</a> objects in the <a>VChart</a> with the same
--   length.
vcGetByLength :: VChart tr slc h v -> Int -> [Vert tr slc h v]

-- | A summary constraint for transitions, slices, hori-operations, and
--   semiring values
type Parsable tr slc h v = (Normal tr, Normal slc, Normal h, Normal' v)

-- | An alias for common constraints on slices and transitions
type Normal x = (Eq x, Ord x, Show x, Hashable x, NFData x)

-- | An alias for common constraints on semiring values
type Normal' x = (Eq x, Show x, NFData x, Semiring x)
instance GHC.Classes.Eq slc => GHC.Classes.Eq (ChartParser.Slice slc)
instance (GHC.Classes.Eq slc, GHC.Classes.Eq tr) => GHC.Classes.Eq (ChartParser.Transition tr slc)
instance GHC.Internal.Generics.Generic (ChartParser.Item i v)
instance GHC.Internal.Generics.Generic (ChartParser.Slice slc)
instance GHC.Internal.Generics.Generic (ChartParser.TChart tr slc v)
instance GHC.Internal.Generics.Generic (ChartParser.Transition tr slc)
instance GHC.Internal.Generics.Generic (ChartParser.VChart tr slc h v)
instance GHC.Internal.Generics.Generic (ChartParser.Vert tr slc h v)
instance GHC.Classes.Eq slc => Data.Hashable.Class.Hashable (ChartParser.Slice slc)
instance (GHC.Classes.Eq slc, Data.Hashable.Class.Hashable tr) => Data.Hashable.Class.Hashable (ChartParser.Transition tr slc)
instance (Control.DeepSeq.NFData i, Control.DeepSeq.NFData v) => Control.DeepSeq.NFData (ChartParser.Item i v)
instance Control.DeepSeq.NFData slc => Control.DeepSeq.NFData (ChartParser.Slice slc)
instance (Control.DeepSeq.NFData slc, Control.DeepSeq.NFData tr, Control.DeepSeq.NFData v) => Control.DeepSeq.NFData (ChartParser.TChart tr slc v)
instance (Control.DeepSeq.NFData slc, Control.DeepSeq.NFData tr) => Control.DeepSeq.NFData (ChartParser.Transition tr slc)
instance (Control.DeepSeq.NFData slc, Control.DeepSeq.NFData h, Control.DeepSeq.NFData v, Control.DeepSeq.NFData tr) => Control.DeepSeq.NFData (ChartParser.VChart tr slc h v)
instance (Control.DeepSeq.NFData slc, Control.DeepSeq.NFData h, Control.DeepSeq.NFData v, Control.DeepSeq.NFData tr) => Control.DeepSeq.NFData (ChartParser.Vert tr slc h v)
instance GHC.Classes.Ord slc => GHC.Classes.Ord (ChartParser.Slice slc)
instance (GHC.Classes.Ord slc, GHC.Classes.Ord tr) => GHC.Classes.Ord (ChartParser.Transition tr slc)
instance (GHC.Internal.Show.Show i, GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (ChartParser.Item i v)
instance GHC.Internal.Show.Show slc => GHC.Internal.Show.Show (ChartParser.Slice slc)
instance (GHC.Internal.Show.Show slc, GHC.Internal.Show.Show tr) => GHC.Internal.Show.Show (ChartParser.TChart tr slc v)
instance (GHC.Internal.Show.Show a, GHC.Internal.Show.Show e) => GHC.Internal.Show.Show (ChartParser.Transition e a)
instance (GHC.Internal.Show.Show tr, GHC.Internal.Show.Show slc, GHC.Internal.Show.Show h, GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (ChartParser.VChart tr slc h v)
instance (GHC.Internal.Show.Show e, GHC.Internal.Show.Show a, GHC.Internal.Show.Show h, GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (ChartParser.Vert e a h v)
