-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/DCMLab/protovoices-haskell#readme</a>
@package protovoices-rl
@version 0.1.0.0

module RL.ModelTypes
type QDType = 'Double
type IsValidDevice (dev :: (DeviceType, Nat)) = (GeluDTypeIsValid dev QDType, RandDTypeIsValid dev QDType, BasicArithmeticDTypeIsValid dev QDType, SumDTypeIsValid dev QDType, MeanDTypeValidation dev QDType, StandardFloatingPointDTypeValidation dev QDType, KnownDevice dev)
type QType = Double
inf :: QType
qDType :: DType
type QTensor (device :: (DeviceType, Nat)) (shape :: [Nat]) = Tensor device QDType shape
opts :: forall (dev :: (DeviceType, Nat)). KnownDevice dev => TensorOptions
toOpts :: forall (dev :: (DeviceType, Nat)) a. (KnownDevice dev, HasTypes a Tensor) => a -> a
toQTensor' :: forall (dev :: (DeviceType, Nat)). KnownDevice dev => QType -> Tensor
toQTensor :: forall (dev :: (DeviceType, Nat)). KnownDevice dev => QType -> QTensor dev ('[] :: [Nat])
type FakeSize = 1337
type MaxPitches = 8
type MaxEdges = 8
type PVAction = Action Notes SPitch Edges SPitch Split SPitch Freeze SPitch Spread SPitch
type PVState = GreedyState Edges SPitch [Edge SPitch] Notes SPitch PVLeftmost SPitch
type PVActionResult = Either PVState (Edges SPitch, [PVLeftmost SPitch])
type PVRewardFn label = PVActionResult -> Maybe NonEmpty PVAction -> PVAction -> label -> IO QType
type CommonHiddenSize = 8
type FifthLow = 'Neg 3
type FifthPadding = 6
type OctaveLow = 'Pos 2
type OctavePadding = 2
type EmbSize = CommonHiddenSize
type FifthSize = 2 * FifthPadding + 1
type OctaveSize = 2 * OctavePadding + 1
type PShape = '[FifthSize, OctaveSize]
type PSize = FifthSize + OctaveSize
type EmbShape = EmbSize ': PShape
type ESize = PSize + PSize
type EShape' = '[FakeSize, ESize]
type QOutHidden = CommonHiddenSize
type QSliceHidden = CommonHiddenSize
type QTransHidden = CommonHiddenSize
type QActionHidden = CommonHiddenSize
type QStateHidden = CommonHiddenSize
instance GHC.Internal.Generics.Generic (Torch.Typed.Optim.Adam momenta)
instance GHC.Internal.Generics.Generic Torch.Typed.Optim.GD
instance GHC.Internal.Generics.Generic (Torch.Typed.Parameter.Parameter dev dtype shape)
instance GHC.Internal.Generics.Generic (Torch.Typed.Tensor.Tensor dev dtype shape)
instance Control.DeepSeq.NFData (Torch.HList.HList momenta) => Control.DeepSeq.NFData (Torch.Typed.Optim.Adam momenta)
instance Control.DeepSeq.NFData (Torch.Typed.NN.Convolution.Conv2d cin cout k0 k1 dtype dev)
instance Control.DeepSeq.NFData Torch.Typed.Optim.GD
instance Control.DeepSeq.NFData (Torch.HList.HList '[])
instance (Control.DeepSeq.NFData x, Control.DeepSeq.NFData (Torch.HList.HList xs)) => Control.DeepSeq.NFData (Torch.HList.HList (x : xs))
instance Control.DeepSeq.NFData Torch.Autograd.IndependentTensor
instance Control.DeepSeq.NFData (Torch.Typed.NN.Normalization.LayerNorm shape dtype dev)
instance Control.DeepSeq.NFData (Torch.Typed.NN.Linear.Linear nin nout dtype dev)
instance Control.DeepSeq.NFData (Torch.Typed.Parameter.Parameter dev dtype shape)
instance Control.DeepSeq.NFData (Torch.Typed.Tensor.Tensor dev dtype shape)
instance NoThunks.Class.NoThunks (Torch.HList.HList momenta) => NoThunks.Class.NoThunks (Torch.Typed.Optim.Adam momenta)
instance NoThunks.Class.NoThunks (Torch.Typed.NN.Convolution.Conv2d cin cout k0 k1 dtype dev)
instance NoThunks.Class.NoThunks Torch.Typed.Optim.GD
instance NoThunks.Class.NoThunks (Torch.HList.HList '[])
instance (NoThunks.Class.NoThunks x, NoThunks.Class.NoThunks (Torch.HList.HList xs)) => NoThunks.Class.NoThunks (Torch.HList.HList (x : xs))
instance NoThunks.Class.NoThunks Torch.Autograd.IndependentTensor
instance NoThunks.Class.NoThunks (Torch.Typed.NN.Normalization.LayerNorm shape dtype dev)
instance NoThunks.Class.NoThunks (Torch.Typed.NN.Linear.Linear nin nout dtype dev)
instance NoThunks.Class.NoThunks (Torch.Typed.Parameter.Parameter dev dtype shape)
instance NoThunks.Class.NoThunks (Torch.Typed.Tensor.Tensor dev dtype shape)
instance NoThunks.Class.NoThunks Torch.Tensor.Tensor

module RL.Encoding
class Stackable a where {
    type Stacked a (n :: Nat);
}
stack :: forall (n :: Nat). (Stackable a, KnownNat n, KnownNat (1 + n)) => Vector (1 + n) a -> Stacked a (1 + n)
stackUnsafe :: Stackable a => [a] -> Stacked a FakeSize
class Batchable a where {
    type Batched a;
}
addBatchDim :: Batchable a => a -> Batched a
data QMaybe (dev :: (DeviceType, Nat)) (batchShape :: [Nat]) a
QMaybe :: QTensor dev batchShape -> a -> QMaybe (dev :: (DeviceType, Nat)) (batchShape :: [Nat]) a
[qmMask] :: QMaybe (dev :: (DeviceType, Nat)) (batchShape :: [Nat]) a -> QTensor dev batchShape
[qmContent] :: QMaybe (dev :: (DeviceType, Nat)) (batchShape :: [Nat]) a -> a
qNothing :: forall (batchShape :: [Nat]) (dev :: (DeviceType, Nat)) a. TensorOptions batchShape QDType dev => a -> QMaybe dev batchShape a
qJust :: forall (batchShape :: [Nat]) (dev :: (DeviceType, Nat)) a. TensorOptions batchShape QDType dev => a -> QMaybe dev batchShape a
data QBoundedList (dev :: (DeviceType, Nat)) (dtype :: DType) (maxLen :: Nat) (batchShape :: [Nat]) (innerShape :: [Nat])
QBoundedList :: QTensor dev (batchShape ++ '[maxLen]) -> Tensor dev dtype ((batchShape ++ '[maxLen]) ++ innerShape) -> QBoundedList (dev :: (DeviceType, Nat)) (dtype :: DType) (maxLen :: Nat) (batchShape :: [Nat]) (innerShape :: [Nat])
[qlMask] :: QBoundedList (dev :: (DeviceType, Nat)) (dtype :: DType) (maxLen :: Nat) (batchShape :: [Nat]) (innerShape :: [Nat]) -> QTensor dev (batchShape ++ '[maxLen])
[qlContent] :: QBoundedList (dev :: (DeviceType, Nat)) (dtype :: DType) (maxLen :: Nat) (batchShape :: [Nat]) (innerShape :: [Nat]) -> Tensor dev dtype ((batchShape ++ '[maxLen]) ++ innerShape)
qBoundedList :: forall (dev :: (DeviceType, Nat)) (dtype :: DType) (maxLen :: Nat) (innerShape :: [Nat]). (KnownNat maxLen, KnownDevice dev, KnownShape innerShape, TensorOptions innerShape QDType dev, TensorOptions innerShape dtype dev) => [Tensor dev dtype innerShape] -> QBoundedList dev dtype maxLen ('[] :: [Nat]) innerShape
data QStartStop (dev :: (DeviceType, Nat)) (batchShape :: [Nat]) a
QStartStop :: Tensor dev 'Int64 batchShape -> a -> QStartStop (dev :: (DeviceType, Nat)) (batchShape :: [Nat]) a
[qssTag] :: QStartStop (dev :: (DeviceType, Nat)) (batchShape :: [Nat]) a -> Tensor dev 'Int64 batchShape
[qssContent] :: QStartStop (dev :: (DeviceType, Nat)) (batchShape :: [Nat]) a -> a
qInner :: forall (batchShape :: [Nat]) (dev :: (DeviceType, Nat)) a. TensorOptions batchShape 'Int64 dev => a -> QStartStop dev batchShape a
qStart :: forall (batchShape :: [Nat]) (dev :: (DeviceType, Nat)) a. TensorOptions batchShape 'Int64 dev => a -> QStartStop dev batchShape a
qStop :: forall (batchShape :: [Nat]) (dev :: (DeviceType, Nat)) a. TensorOptions batchShape 'Int64 dev => a -> QStartStop dev batchShape a
qStartStop :: forall (batchShape :: [Nat]) (dev :: (DeviceType, Nat)) a b. TensorOptions batchShape 'Int64 dev => (a -> b) -> b -> StartStop a -> QStartStop dev batchShape b
newtype SliceEncodingSparse (dev :: (DeviceType, Nat)) (batchShape :: [Nat])
SliceEncodingSparse :: QBoundedList dev 'Int64 MaxPitches batchShape '[2] -> SliceEncodingSparse (dev :: (DeviceType, Nat)) (batchShape :: [Nat])
[getSliceEncodingSparse] :: SliceEncodingSparse (dev :: (DeviceType, Nat)) (batchShape :: [Nat]) -> QBoundedList dev 'Int64 MaxPitches batchShape '[2]
newtype SliceEncodingDense (dev :: (DeviceType, Nat)) (batchShape :: [Nat])
SliceEncodingDense :: QTensor dev (batchShape ++ PShape) -> SliceEncodingDense (dev :: (DeviceType, Nat)) (batchShape :: [Nat])
[getSliceEncodingDense] :: SliceEncodingDense (dev :: (DeviceType, Nat)) (batchShape :: [Nat]) -> QTensor dev (batchShape ++ PShape)
type SliceEncoding = SliceEncodingDense
getSlice :: forall (dev :: (DeviceType, Nat)) (batchShape :: [Nat]). SliceEncoding dev batchShape -> QTensor dev (batchShape ++ PShape)
encodePitches :: forall (dev :: (DeviceType, Nat)). KnownDevice dev => [SPitch] -> SliceEncoding dev ('[] :: [Nat])
pitch2index :: SPitch -> [Int]
pitchesMultiHot :: forall (dev :: (DeviceType, Nat)). KnownDevice dev => HashSet SPitch -> QTensor dev PShape
pitchesOneHotSum :: forall (dev :: (DeviceType, Nat)). KnownDevice dev => [SPitch] -> SliceEncodingDense dev ('[] :: [Nat])
pitchesOneHots :: forall (dev :: (DeviceType, Nat)). KnownDevice dev => [SPitch] -> QBoundedList dev QDType MaxPitches ('[] :: [Nat]) (1 ': PShape)
pitchesTokens :: forall (dev :: (DeviceType, Nat)). KnownDevice dev => [SPitch] -> QBoundedList dev QDType MaxPitches ('[] :: [Nat]) '[PSize]
pitchesIndices :: forall (dev :: (DeviceType, Nat)). KnownDevice dev => [SPitch] -> SliceEncodingSparse dev ('[] :: [Nat])
encodeSlice :: forall (dev :: (DeviceType, Nat)). KnownDevice dev => Notes SPitch -> SliceEncoding dev ('[] :: [Nat])
emptySlice :: forall (dev :: (DeviceType, Nat)). KnownDevice dev => SliceEncoding dev ('[] :: [Nat])
data TransitionEncoding (dev :: (DeviceType, Nat)) (batchShape :: [Nat])
TransitionEncoding :: QBoundedList dev QDType MaxEdges batchShape (2 ': PShape) -> QBoundedList dev QDType MaxEdges batchShape (2 ': PShape) -> SliceEncoding dev batchShape -> SliceEncoding dev batchShape -> QTensor dev batchShape -> TransitionEncoding (dev :: (DeviceType, Nat)) (batchShape :: [Nat])
[trencPassing] :: TransitionEncoding (dev :: (DeviceType, Nat)) (batchShape :: [Nat]) -> QBoundedList dev QDType MaxEdges batchShape (2 ': PShape)
[trencInner] :: TransitionEncoding (dev :: (DeviceType, Nat)) (batchShape :: [Nat]) -> QBoundedList dev QDType MaxEdges batchShape (2 ': PShape)
[trencLeft] :: TransitionEncoding (dev :: (DeviceType, Nat)) (batchShape :: [Nat]) -> SliceEncoding dev batchShape
[trencRight] :: TransitionEncoding (dev :: (DeviceType, Nat)) (batchShape :: [Nat]) -> SliceEncoding dev batchShape
[trencRoot] :: TransitionEncoding (dev :: (DeviceType, Nat)) (batchShape :: [Nat]) -> QTensor dev batchShape
edgesMultiHot :: forall (dev :: (DeviceType, Nat)). KnownDevice dev => HashSet (InnerEdge SPitch) -> QTensor dev EShape'
edgesOneHots :: forall (dev :: (DeviceType, Nat)). KnownDevice dev => [InnerEdge SPitch] -> QBoundedList dev QDType MaxEdges ('[] :: [Nat]) (2 ': PShape)
edgesTokens :: forall (dev :: (DeviceType, Nat)). KnownDevice dev => [InnerEdge SPitch] -> QBoundedList dev QDType MaxEdges ('[] :: [Nat]) '[ESize]
encodeTransition :: forall (dev :: (DeviceType, Nat)). KnownDevice dev => Edges SPitch -> TransitionEncoding dev ('[] :: [Nat])
emptyTransition :: forall (dev :: (DeviceType, Nat)). KnownDevice dev => TransitionEncoding dev ('[] :: [Nat])
data ActionTop (dev :: (DeviceType, Nat)) (batchShape :: [Nat])
ActionTop :: !QStartStop dev batchShape (SliceEncoding dev batchShape) -> !TransitionEncoding dev batchShape -> !QMaybe dev batchShape (SliceEncoding dev batchShape) -> !QMaybe dev batchShape (TransitionEncoding dev batchShape) -> !QStartStop dev batchShape (SliceEncoding dev batchShape) -> ActionTop (dev :: (DeviceType, Nat)) (batchShape :: [Nat])
[atopSl] :: ActionTop (dev :: (DeviceType, Nat)) (batchShape :: [Nat]) -> !QStartStop dev batchShape (SliceEncoding dev batchShape)
[atopT1] :: ActionTop (dev :: (DeviceType, Nat)) (batchShape :: [Nat]) -> !TransitionEncoding dev batchShape
[atopSm] :: ActionTop (dev :: (DeviceType, Nat)) (batchShape :: [Nat]) -> !QMaybe dev batchShape (SliceEncoding dev batchShape)
[atopT2] :: ActionTop (dev :: (DeviceType, Nat)) (batchShape :: [Nat]) -> !QMaybe dev batchShape (TransitionEncoding dev batchShape)
[atopSr] :: ActionTop (dev :: (DeviceType, Nat)) (batchShape :: [Nat]) -> !QStartStop dev batchShape (SliceEncoding dev batchShape)
data ActionEncoding (dev :: (DeviceType, Nat)) (batchShape :: [Nat])
ActionEncoding :: !ActionTop dev batchShape -> !Tensor dev 'Int64 batchShape -> ActionEncoding (dev :: (DeviceType, Nat)) (batchShape :: [Nat])
[actionEncodingTop] :: ActionEncoding (dev :: (DeviceType, Nat)) (batchShape :: [Nat]) -> !ActionTop dev batchShape
[actionEncodingOp] :: ActionEncoding (dev :: (DeviceType, Nat)) (batchShape :: [Nat]) -> !Tensor dev 'Int64 batchShape
encodePVAction :: forall (dev :: (DeviceType, Nat)). KnownDevice dev => PVAction -> ActionEncoding dev ('[] :: [Nat])
data StateEncoding (dev :: (DeviceType, Nat))
StateEncoding :: !QStartStop dev ('[] :: [Nat]) (SliceEncoding dev ('[] :: [Nat])) -> !QMaybe dev ('[] :: [Nat]) (TransitionEncoding dev '[FakeSize], QStartStop dev '[FakeSize] (SliceEncoding dev '[FakeSize])) -> !QMaybe dev ('[] :: [Nat]) (TransitionEncoding dev '[FakeSize], QStartStop dev '[FakeSize] (SliceEncoding dev '[FakeSize])) -> StateEncoding (dev :: (DeviceType, Nat))
[stateEncodingMid] :: StateEncoding (dev :: (DeviceType, Nat)) -> !QStartStop dev ('[] :: [Nat]) (SliceEncoding dev ('[] :: [Nat]))
[stateEncodingFrozen] :: StateEncoding (dev :: (DeviceType, Nat)) -> !QMaybe dev ('[] :: [Nat]) (TransitionEncoding dev '[FakeSize], QStartStop dev '[FakeSize] (SliceEncoding dev '[FakeSize]))
[stateEncodingOpen] :: StateEncoding (dev :: (DeviceType, Nat)) -> !QMaybe dev ('[] :: [Nat]) (TransitionEncoding dev '[FakeSize], QStartStop dev '[FakeSize] (SliceEncoding dev '[FakeSize]))
getFrozen :: forall (dev :: (DeviceType, Nat)) t. (Foldable t, KnownDevice dev) => Path (Maybe (t (Edge SPitch))) (Notes SPitch) -> (TransitionEncoding dev '[FakeSize], QStartStop dev '[FakeSize] (SliceEncoding dev '[FakeSize]))
getOpen :: forall (dev :: (DeviceType, Nat)). KnownDevice dev => Path (Edges SPitch) (Notes SPitch) -> (TransitionEncoding dev '[FakeSize], QStartStop dev '[FakeSize] (SliceEncoding dev '[FakeSize]))
encodePVState :: forall (dev :: (DeviceType, Nat)). KnownDevice dev => PVState -> StateEncoding dev
data QEncoding (dev :: (DeviceType, Nat)) (batchShape :: [Nat])
QEncoding :: !ActionEncoding dev batchShape -> !StateEncoding dev -> QEncoding (dev :: (DeviceType, Nat)) (batchShape :: [Nat])
[qActionEncoding] :: QEncoding (dev :: (DeviceType, Nat)) (batchShape :: [Nat]) -> !ActionEncoding dev batchShape
[qStateEncoding] :: QEncoding (dev :: (DeviceType, Nat)) (batchShape :: [Nat]) -> !StateEncoding dev
encodeStep :: forall (dev :: (DeviceType, Nat)). KnownDevice dev => PVState -> PVAction -> QEncoding dev ('[] :: [Nat])
withBatchedEncoding :: forall (dev :: (DeviceType, Nat)) r. KnownDevice dev => PVState -> NonEmpty PVAction -> (forall (n :: Nat). KnownNat n => QEncoding dev '[n] -> r) -> r
instance RL.Encoding.Batchable (RL.Encoding.ActionEncoding dev shape)
instance RL.Encoding.Batchable (RL.Encoding.ActionTop dev shape)
instance RL.Encoding.Batchable (RL.Encoding.QBoundedList dev dtype maxLen batchShape innerShape)
instance RL.Encoding.Batchable (RL.Encoding.QEncoding dev shape)
instance RL.Encoding.Batchable a => RL.Encoding.Batchable (RL.Encoding.QMaybe dev shape a)
instance RL.Encoding.Batchable a => RL.Encoding.Batchable (RL.Encoding.QStartStop dev shape a)
instance RL.Encoding.Batchable (RL.Encoding.SliceEncodingDense dev batchShape)
instance RL.Encoding.Batchable (RL.Encoding.SliceEncodingSparse dev shape)
instance RL.Encoding.Batchable (Torch.Typed.Tensor.Tensor dev dtype shape)
instance RL.Encoding.Batchable (RL.Encoding.TransitionEncoding dev shape)
instance GHC.Internal.Generics.Generic (RL.Encoding.ActionEncoding dev batchShape)
instance GHC.Internal.Generics.Generic (RL.Encoding.ActionTop dev batchShape)
instance GHC.Internal.Generics.Generic (RL.Encoding.QBoundedList dev dtype maxLen batchShape innerShape)
instance GHC.Internal.Generics.Generic (RL.Encoding.QEncoding dev batchShape)
instance GHC.Internal.Generics.Generic (RL.Encoding.QMaybe dev batchShape a)
instance GHC.Internal.Generics.Generic (RL.Encoding.QStartStop dev batchShape a)
instance GHC.Internal.Generics.Generic (RL.Encoding.SliceEncodingDense dev batchShape)
instance GHC.Internal.Generics.Generic (RL.Encoding.SliceEncodingSparse dev batchShape)
instance GHC.Internal.Generics.Generic (RL.Encoding.StateEncoding dev)
instance GHC.Internal.Generics.Generic (RL.Encoding.TransitionEncoding dev batchShape)
instance Control.DeepSeq.NFData (RL.Encoding.ActionEncoding dev batchShape)
instance Control.DeepSeq.NFData (RL.Encoding.ActionTop dev batchShape)
instance Control.DeepSeq.NFData (RL.Encoding.QBoundedList dev dtype maxLen batchShape innerShape)
instance Control.DeepSeq.NFData (RL.Encoding.QEncoding dev batchShape)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (RL.Encoding.QMaybe dev batchShape a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (RL.Encoding.QStartStop dev batchShape a)
instance Control.DeepSeq.NFData (RL.Encoding.SliceEncodingDense dev batchShape)
instance Control.DeepSeq.NFData (RL.Encoding.SliceEncodingSparse dev batchShape)
instance Control.DeepSeq.NFData (RL.Encoding.StateEncoding dev)
instance Control.DeepSeq.NFData (RL.Encoding.TransitionEncoding dev batchShape)
instance GHC.Internal.Show.Show (RL.Encoding.ActionEncoding dev batchShape)
instance GHC.Internal.Show.Show (RL.Encoding.ActionTop dev batchShape)
instance GHC.Internal.Show.Show (RL.Encoding.QBoundedList dev dtype maxLen batchShape innerShape)
instance GHC.Internal.Show.Show (RL.Encoding.QEncoding dev batchShape)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (RL.Encoding.QMaybe dev batchShape a)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (RL.Encoding.QStartStop dev batchShape a)
instance GHC.Internal.Show.Show (RL.Encoding.SliceEncodingDense dev batchShape)
instance GHC.Internal.Show.Show (RL.Encoding.SliceEncodingSparse dev batchShape)
instance GHC.Internal.Show.Show (RL.Encoding.StateEncoding dev)
instance GHC.Internal.Show.Show (RL.Encoding.TransitionEncoding dev batchShape)
instance RL.Encoding.Stackable (RL.Encoding.ActionEncoding dev batchShape)
instance RL.Encoding.Stackable (RL.Encoding.ActionTop dev batchShape)
instance RL.Encoding.Stackable (RL.Encoding.QBoundedList dev dtype maxLen batchShape innerShape)
instance RL.Encoding.Stackable a => RL.Encoding.Stackable (RL.Encoding.QMaybe dev batchShape a)
instance RL.Encoding.Stackable a => RL.Encoding.Stackable (RL.Encoding.QStartStop dev batchShape a)
instance RL.Encoding.Stackable (RL.Encoding.SliceEncodingDense dev batchShape)
instance RL.Encoding.Stackable (RL.Encoding.SliceEncodingSparse dev batchShape)
instance RL.Encoding.Stackable (RL.Encoding.TransitionEncoding dev batchShape)

module RL.Callbacks
pvRewardSample :: Gen RealWorld -> Hyper PVParams -> PVRewardFn label
pvRewardExp :: Hyper PVParams -> PVRewardFn label
pvRewardExp' :: Hyper PVParams -> PVAnalysis SPitch -> IO QType
pvRewardActionByLen :: Hyper PVParams -> PVRewardFn Int
pvRewardChord :: PVRewardFn [Int]
addRewards :: QType -> PVRewardFn a -> PVRewardFn b -> PVRewardFn (a, b)
pvRewardChordAndActionByLen :: QType -> Hyper PVParams -> PVRewardFn (Int, [Int])
cosSchedule :: QType -> QType -> QType
expSchedule :: QType -> QType -> QType -> QType -> QType

module RL.Plotting
mean :: Foldable t => t QType -> QType
zipWithStrict :: (a -> b -> c) -> List a -> List b -> List c
mkHistoryPlot :: String -> [QType] -> StateT (Layout Int QType) (State CState) ()
mkHistoriesPlot :: String -> [[QType]] -> StateT (Layout Int QType) (State CState) ()
mkHistoryPlot' :: String -> QType -> [QType] -> StateT (Layout Int QType) (State CState) ()
mkHistoriesPlot' :: String -> [QType] -> [[QType]] -> StateT (Layout Int QType) (State CState) ()
fileOpts :: FileOptions
showHistory :: String -> [QType] -> IO ()
plotHistory :: String -> [QType] -> IO ()
plotHistories :: String -> [[QType]] -> IO ()
plotHistory' :: String -> QType -> [QType] -> IO ()
plotHistories' :: String -> [QType] -> [[QType]] -> IO ()
plotDeriv :: Foldable t => FilePath -> t (Leftmost (Split SPitch) (Freeze SPitch) (Spread SPitch)) -> IO ()

module RL.Pretraining

module RL.ReplayBuffer
newtype RPState tr tr' slc s f h
RPState :: GreedyState tr tr' slc (Leftmost s f h) -> RPState tr tr' slc s f h
newtype RPAction slc tr s f h
RPAction :: Action slc tr s f h -> RPAction slc tr s f h
data ReplayStep (dev :: (DeviceType, Nat)) tr tr' slc s f h
ReplayStep :: !RPState tr tr' slc s f h -> !RPAction slc tr s f h -> !QEncoding dev ('[] :: [Nat]) -> !Maybe (RPState tr tr' slc s f h) -> ![QEncoding dev ('[] :: [Nat])] -> !QType -> ReplayStep (dev :: (DeviceType, Nat)) tr tr' slc s f h
[replayState] :: ReplayStep (dev :: (DeviceType, Nat)) tr tr' slc s f h -> !RPState tr tr' slc s f h
[replayAction] :: ReplayStep (dev :: (DeviceType, Nat)) tr tr' slc s f h -> !RPAction slc tr s f h
[replayStep] :: ReplayStep (dev :: (DeviceType, Nat)) tr tr' slc s f h -> !QEncoding dev ('[] :: [Nat])
[replayNextState] :: ReplayStep (dev :: (DeviceType, Nat)) tr tr' slc s f h -> !Maybe (RPState tr tr' slc s f h)
[replayNextSteps] :: ReplayStep (dev :: (DeviceType, Nat)) tr tr' slc s f h -> ![QEncoding dev ('[] :: [Nat])]
[replayReward] :: ReplayStep (dev :: (DeviceType, Nat)) tr tr' slc s f h -> !QType
data ReplayBuffer (dev :: (DeviceType, Nat)) tr tr' slc s f h
ReplayBuffer :: !Int -> ![ReplayStep dev tr tr' slc s f h] -> ReplayBuffer (dev :: (DeviceType, Nat)) tr tr' slc s f h
mkReplayBuffer :: forall (dev :: (DeviceType, Nat)) tr tr' slc s f h. Int -> ReplayBuffer dev tr tr' slc s f h
seedReplayBuffer :: forall (dev :: (DeviceType, Nat)) tr tr' slc s f h. Int -> [ReplayStep dev tr tr' slc s f h] -> ReplayBuffer dev tr tr' slc s f h
pushStep :: forall (dev :: (DeviceType, Nat)) tr tr' slc s f h. ReplayBuffer dev tr tr' slc s f h -> ReplayStep dev tr tr' slc s f h -> ReplayBuffer dev tr tr' slc s f h
sampleSteps :: forall (dev :: (DeviceType, Nat)) tr tr' slc s f h. ReplayBuffer dev tr tr' slc s f h -> Int -> IO [ReplayStep dev tr tr' slc s f h]
instance (GHC.Internal.Show.Show slc, GHC.Internal.Show.Show tr, GHC.Internal.Show.Show s, GHC.Internal.Show.Show f, GHC.Internal.Show.Show h) => GHC.Internal.Show.Show (RL.ReplayBuffer.RPAction slc tr s f h)
instance (GHC.Internal.Show.Show tr, GHC.Internal.Show.Show tr', GHC.Internal.Show.Show slc, GHC.Internal.Show.Show s, GHC.Internal.Show.Show f, GHC.Internal.Show.Show h) => GHC.Internal.Show.Show (RL.ReplayBuffer.RPState tr tr' slc s f h)
instance (GHC.Internal.Show.Show slc, GHC.Internal.Show.Show s, GHC.Internal.Show.Show f, GHC.Internal.Show.Show h, GHC.Internal.Show.Show tr, GHC.Internal.Show.Show tr') => GHC.Internal.Show.Show (RL.ReplayBuffer.ReplayBuffer dev tr tr' slc s f h)
instance (GHC.Internal.Show.Show slc, GHC.Internal.Show.Show s, GHC.Internal.Show.Show f, GHC.Internal.Show.Show h, GHC.Internal.Show.Show tr, GHC.Internal.Show.Show tr') => GHC.Internal.Show.Show (RL.ReplayBuffer.ReplayStep dev tr tr' slc s f h)

module RL.TorchHelpers

-- | Helper Type to map sumAll over a HList.
data SumAll
SumAll :: SumAll

-- | Helper Type to fold a HList by adding the values.
data Add
Add :: Add

-- | Helper Type to multiply a HList with a scalar
newtype Mul num
Mul :: num -> Mul num
newtype Mul' (dev :: (DeviceType, Nat)) (dtype :: DType)
Mul' :: Tensor dev dtype ('[] :: [Nat]) -> Mul' (dev :: (DeviceType, Nat)) (dtype :: DType)

-- | Detach a typed tensor.
detach :: forall (dev :: (DeviceType, Nat)) (dtype :: DType) (shape :: [Nat]). Tensor dev dtype shape -> IO (Tensor dev dtype shape)

-- | Helper type for combining detach and <a>Apply'</a>.
data Detach
Detach :: Detach

-- | Helper Type for interpolating qnet parameters.
newtype Interpolate num
Interpolate :: num -> Interpolate num

-- | Helper Type for getting the number of parameters in a model
data ShapeVal
ShapeVal :: ShapeVal

-- | Helper Type for getting a list out of a HList
data ToList
ToList :: ToList
type family ToModelTensors (params :: [Type]) :: [Type]

-- | Run a batched operation in an unbatched context
withBatchDim :: forall (dev1 :: (DeviceType, Nat)) (dtype1 :: DType) (shape1 :: [Natural]) (dev2 :: (DeviceType, Nat)) (dtype2 :: DType) (shape2 :: [Natural]). (Tensor dev1 dtype1 (1 ': shape1) -> Tensor dev2 dtype2 (1 ': shape2)) -> Tensor dev1 dtype1 shape1 -> Tensor dev2 dtype2 shape2

-- | conv2d with dropped batch size constraint
conv2dRelaxed :: forall (stride :: (Nat, Nat)) (padding :: (Nat, Nat)) (inputChannelSize :: Nat) (outputChannelSize :: Nat) (kernelSize0 :: Nat) (kernelSize1 :: Nat) (inputSize0 :: Nat) (inputSize1 :: Nat) (batchSize :: Nat) (outputSize0 :: Nat) (outputSize1 :: Nat) (dtype :: DType) (device :: (DeviceType, Nat)). (All KnownNat '[Fst stride, Snd stride, Fst padding, Snd padding], ConvSideCheck inputSize0 kernelSize0 (Fst stride) (Fst padding) outputSize0, ConvSideCheck inputSize1 kernelSize1 (Snd stride) (Snd padding) outputSize1) => Tensor device dtype '[outputChannelSize, inputChannelSize, kernelSize0, kernelSize1] -> Tensor device dtype '[outputChannelSize] -> Tensor device dtype '[batchSize, inputChannelSize, inputSize0, inputSize1] -> Tensor device dtype '[batchSize, outputChannelSize, outputSize0, outputSize1]
conv2dForwardRelaxed :: forall (stride :: (Nat, Nat)) (padding :: (Nat, Nat)) (inputChannelSize :: Nat) (outputChannelSize :: Nat) (kernelSize0 :: Nat) (kernelSize1 :: Nat) (inputSize0 :: Nat) (inputSize1 :: Nat) (batchSize :: Nat) (outputSize0 :: Nat) (outputSize1 :: Nat) (dtype :: DType) (device :: (DeviceType, Nat)). (All KnownNat '[Fst stride, Snd stride, Fst padding, Snd padding], ConvSideCheck inputSize0 kernelSize0 (Fst stride) (Fst padding) outputSize0, ConvSideCheck inputSize1 kernelSize1 (Snd stride) (Snd padding) outputSize1) => Conv2d inputChannelSize outputChannelSize kernelSize0 kernelSize1 dtype device -> Tensor device dtype '[batchSize, inputChannelSize, inputSize0, inputSize1] -> Tensor device dtype '[batchSize, outputChannelSize, outputSize0, outputSize1]
instance (Torch.Typed.Tensor.BasicArithmeticDTypeIsValid dev dtype, Torch.Typed.Tensor.CheckBroadcast shape1 shape2 (Torch.Typed.Tensor.ComputeBroadcast (Torch.Typed.Auxiliary.ReverseImpl shape1 '[]) (Torch.Typed.Auxiliary.ReverseImpl shape2 '[])) GHC.Types.~ shapeOut) => Torch.HList.Apply' RL.TorchHelpers.Add (Torch.Typed.Tensor.Tensor dev dtype shape1, Torch.Typed.Tensor.Tensor dev dtype shape2) (Torch.Typed.Tensor.Tensor dev dtype shapeOut)
instance Torch.HList.Apply' RL.TorchHelpers.Detach (Torch.Typed.Tensor.Tensor dev dtype shape) (GHC.Types.IO (Torch.Typed.Tensor.Tensor dev dtype shape))
instance (Torch.Scalar.Scalar num, GHC.Internal.Num.Num num, Torch.Typed.Tensor.BasicArithmeticDTypeIsValid dev dtype, Torch.Typed.Tensor.CheckBroadcast shape shape (Torch.Typed.Tensor.ComputeBroadcast (Torch.Typed.Auxiliary.ReverseImpl shape '[]) (Torch.Typed.Auxiliary.ReverseImpl shape '[])) GHC.Types.~ shape) => Torch.HList.Apply' (RL.TorchHelpers.Interpolate num) (Torch.Typed.Tensor.Tensor dev dtype shape, Torch.Typed.Tensor.Tensor dev dtype shape) (Torch.Typed.Tensor.Tensor dev dtype shape)
instance (shape GHC.Types.~ Torch.Typed.Tensor.Broadcast '[] shape, Torch.Typed.Tensor.BasicArithmeticDTypeIsValid dev dtype) => Torch.HList.Apply' (RL.TorchHelpers.Mul' dev dtype) (Torch.Typed.Tensor.Tensor dev dtype shape) (Torch.Typed.Tensor.Tensor dev dtype shape)
instance Torch.Scalar.Scalar num => Torch.HList.Apply' (RL.TorchHelpers.Mul num) (Torch.Typed.Tensor.Tensor dev dtype shape) (Torch.Typed.Tensor.Tensor dev dtype shape)
instance Torch.Typed.Tensor.KnownShape shape => Torch.HList.Apply' RL.TorchHelpers.ShapeVal (Torch.Typed.Parameter.Parameter dev dtype shape) [GHC.Types.Int]
instance Torch.Typed.Tensor.KnownShape shape => Torch.HList.Apply' RL.TorchHelpers.ShapeVal (Torch.Typed.Tensor.Tensor dev dtype shape) [GHC.Types.Int]
instance (dtype' GHC.Types.~ Torch.Typed.Functional.SumDType dtype, Torch.Typed.Functional.SumDTypeIsValid dev dtype) => Torch.HList.Apply' RL.TorchHelpers.SumAll (Torch.Typed.Tensor.Tensor dev dtype shape) (Torch.Typed.Tensor.Tensor dev dtype' '[])
instance Torch.HList.Apply' RL.TorchHelpers.ToList (t, [t]) [t]

module RL.Model
activation :: forall (dev :: (DeviceType, Nat)) (shape :: [Nat]). IsValidDevice dev => QTensor dev shape -> QTensor dev shape
expandAs :: Tensor -> Tensor -> Tensor
traceDyn :: forall (a :: (DeviceType, Nat)) (b :: DType) (c :: [Nat]). Tensor a b c -> Tensor a b c
unsafeReshape :: forall (dev :: (DeviceType, Nat)) (dtype :: DType) (shape :: [Nat]) (shape' :: [Nat]). [Int] -> Tensor dev dtype shape -> Tensor dev dtype shape'
data ConstEmbSpec (dev :: k) (shape :: [Nat])
ConstEmbSpec :: ConstEmbSpec (dev :: k) (shape :: [Nat])
newtype ConstEmb (dev :: (DeviceType, Nat)) (shape :: [Nat])
ConstEmb :: Parameter dev QDType shape -> ConstEmb (dev :: (DeviceType, Nat)) (shape :: [Nat])
data SliceSpec (dev :: k)
SliceSpec :: SliceSpec (dev :: k)
data SliceEncoder (dev :: (DeviceType, Nat))
SliceEncoder :: !Conv2d 1 QSliceHidden 1 1 QDType dev -> !Conv2d QSliceHidden EmbSize FifthSize OctaveSize QDType dev -> !ConstEmb dev EmbShape -> !ConstEmb dev EmbShape -> SliceEncoder (dev :: (DeviceType, Nat))
[_slcL1] :: SliceEncoder (dev :: (DeviceType, Nat)) -> !Conv2d 1 QSliceHidden 1 1 QDType dev
[_slcL2] :: SliceEncoder (dev :: (DeviceType, Nat)) -> !Conv2d QSliceHidden EmbSize FifthSize OctaveSize QDType dev
[_slcStart] :: SliceEncoder (dev :: (DeviceType, Nat)) -> !ConstEmb dev EmbShape
[_slcStop] :: SliceEncoder (dev :: (DeviceType, Nat)) -> !ConstEmb dev EmbShape
data TransitionSpec (dev :: k)
TransitionSpec :: TransitionSpec (dev :: k)
data TransitionEncoder (dev :: (DeviceType, Nat))
TransitionEncoder :: !Conv2d 2 QTransHidden FifthSize OctaveSize QDType dev -> !Conv2d 2 QTransHidden FifthSize OctaveSize QDType dev -> !Conv2d 1 QTransHidden 1 1 QDType dev -> !Conv2d 1 QTransHidden 1 1 QDType dev -> !ConstEmb dev '[QTransHidden] -> !Conv2d QTransHidden EmbSize FifthSize OctaveSize QDType dev -> TransitionEncoder (dev :: (DeviceType, Nat))
[trL1Passing] :: TransitionEncoder (dev :: (DeviceType, Nat)) -> !Conv2d 2 QTransHidden FifthSize OctaveSize QDType dev
[trL1Inner] :: TransitionEncoder (dev :: (DeviceType, Nat)) -> !Conv2d 2 QTransHidden FifthSize OctaveSize QDType dev
[trL1Left] :: TransitionEncoder (dev :: (DeviceType, Nat)) -> !Conv2d 1 QTransHidden 1 1 QDType dev
[trL1Right] :: TransitionEncoder (dev :: (DeviceType, Nat)) -> !Conv2d 1 QTransHidden 1 1 QDType dev
[trL1Root] :: TransitionEncoder (dev :: (DeviceType, Nat)) -> !ConstEmb dev '[QTransHidden]
[trL2] :: TransitionEncoder (dev :: (DeviceType, Nat)) -> !Conv2d QTransHidden EmbSize FifthSize OctaveSize QDType dev
data ActionSpec (dev :: k)
ActionSpec :: ActionSpec (dev :: k)
data ActionEncoder (dev :: (DeviceType, Nat))
ActionEncoder :: !Conv2d EmbSize QActionHidden FifthSize OctaveSize QDType dev -> !Conv2d EmbSize QActionHidden FifthSize OctaveSize QDType dev -> !Conv2d EmbSize QActionHidden FifthSize OctaveSize QDType dev -> !Conv2d EmbSize QActionHidden FifthSize OctaveSize QDType dev -> !Conv2d EmbSize QActionHidden FifthSize OctaveSize QDType dev -> !Conv2d QActionHidden EmbSize FifthSize OctaveSize QDType dev -> ConstEmb dev '[EmbSize - 3] -> ConstEmb dev '[EmbSize - 3] -> ConstEmb dev '[EmbSize - 3] -> ActionEncoder (dev :: (DeviceType, Nat))
[actTop1sl] :: ActionEncoder (dev :: (DeviceType, Nat)) -> !Conv2d EmbSize QActionHidden FifthSize OctaveSize QDType dev
[actTop1sm] :: ActionEncoder (dev :: (DeviceType, Nat)) -> !Conv2d EmbSize QActionHidden FifthSize OctaveSize QDType dev
[actTop1sr] :: ActionEncoder (dev :: (DeviceType, Nat)) -> !Conv2d EmbSize QActionHidden FifthSize OctaveSize QDType dev
[actTop1t1] :: ActionEncoder (dev :: (DeviceType, Nat)) -> !Conv2d EmbSize QActionHidden FifthSize OctaveSize QDType dev
[actTop1t2] :: ActionEncoder (dev :: (DeviceType, Nat)) -> !Conv2d EmbSize QActionHidden FifthSize OctaveSize QDType dev
[actTop2] :: ActionEncoder (dev :: (DeviceType, Nat)) -> !Conv2d QActionHidden EmbSize FifthSize OctaveSize QDType dev
[actSplit] :: ActionEncoder (dev :: (DeviceType, Nat)) -> ConstEmb dev '[EmbSize - 3]
[actSpread] :: ActionEncoder (dev :: (DeviceType, Nat)) -> ConstEmb dev '[EmbSize - 3]
[actFreeze] :: ActionEncoder (dev :: (DeviceType, Nat)) -> ConstEmb dev '[EmbSize - 3]
opTypes :: forall (dev :: (DeviceType, Nat)). KnownDevice dev => QTensor dev '[6, 3]
data StateSpec (dev :: k)
StateSpec :: StateSpec (dev :: k)
data StateEncoder (dev :: (DeviceType, Nat))
StateEncoder :: Conv2d EmbSize QStateHidden FifthSize OctaveSize QDType dev -> Conv2d EmbSize QStateHidden FifthSize OctaveSize QDType dev -> Conv2d EmbSize QStateHidden FifthSize OctaveSize QDType dev -> Conv2d EmbSize QStateHidden FifthSize OctaveSize QDType dev -> Conv2d EmbSize QStateHidden FifthSize OctaveSize QDType dev -> Conv2d QStateHidden QStateHidden FifthSize OctaveSize QDType dev -> Conv2d QStateHidden EmbSize FifthSize OctaveSize QDType dev -> StateEncoder (dev :: (DeviceType, Nat))
[stL1mid] :: StateEncoder (dev :: (DeviceType, Nat)) -> Conv2d EmbSize QStateHidden FifthSize OctaveSize QDType dev
[stL1frozenSlc] :: StateEncoder (dev :: (DeviceType, Nat)) -> Conv2d EmbSize QStateHidden FifthSize OctaveSize QDType dev
[stL1frozenTr] :: StateEncoder (dev :: (DeviceType, Nat)) -> Conv2d EmbSize QStateHidden FifthSize OctaveSize QDType dev
[stL1openSlc] :: StateEncoder (dev :: (DeviceType, Nat)) -> Conv2d EmbSize QStateHidden FifthSize OctaveSize QDType dev
[stL1openTr] :: StateEncoder (dev :: (DeviceType, Nat)) -> Conv2d EmbSize QStateHidden FifthSize OctaveSize QDType dev
[stL2] :: StateEncoder (dev :: (DeviceType, Nat)) -> Conv2d QStateHidden QStateHidden FifthSize OctaveSize QDType dev
[stL3] :: StateEncoder (dev :: (DeviceType, Nat)) -> Conv2d QStateHidden EmbSize FifthSize OctaveSize QDType dev
data QSpec (dev :: k)
QSpec :: QSpec (dev :: k)
data QModel (dev :: (DeviceType, Nat))
QModel :: !SliceEncoder dev -> !TransitionEncoder dev -> !ActionEncoder dev -> !StateEncoder dev -> !Conv2d EmbSize QOutHidden FifthSize OctaveSize QDType dev -> !LayerNorm '[QOutHidden] QDType dev -> !Linear QOutHidden 1 QDType dev -> !Linear EmbSize QOutHidden QDType dev -> !LayerNorm '[QOutHidden] QDType dev -> !Linear QOutHidden 1 QDType dev -> QModel (dev :: (DeviceType, Nat))
[qModelSlc] :: QModel (dev :: (DeviceType, Nat)) -> !SliceEncoder dev
[qModelTr] :: QModel (dev :: (DeviceType, Nat)) -> !TransitionEncoder dev
[qModelAct] :: QModel (dev :: (DeviceType, Nat)) -> !ActionEncoder dev
[qModelSt] :: QModel (dev :: (DeviceType, Nat)) -> !StateEncoder dev
[qModelFinal1] :: QModel (dev :: (DeviceType, Nat)) -> !Conv2d EmbSize QOutHidden FifthSize OctaveSize QDType dev
[qModelNorm1] :: QModel (dev :: (DeviceType, Nat)) -> !LayerNorm '[QOutHidden] QDType dev
[qModelFinal2] :: QModel (dev :: (DeviceType, Nat)) -> !Linear QOutHidden 1 QDType dev
[qModelValue1] :: QModel (dev :: (DeviceType, Nat)) -> !Linear EmbSize QOutHidden QDType dev
[qModelValueNorm] :: QModel (dev :: (DeviceType, Nat)) -> !LayerNorm '[QOutHidden] QDType dev
[qModelValue2] :: QModel (dev :: (DeviceType, Nat)) -> !Linear QOutHidden 1 QDType dev
forwardQModel :: forall (dev :: (DeviceType, Nat)). IsValidDevice dev => QModel dev -> QEncoding dev ('[] :: [Nat]) -> QTensor dev '[1]
forwardQModelBatched :: forall (dev :: (DeviceType, Nat)) (batchSize :: Nat). (IsValidDevice dev, 1 <= batchSize) => QModel dev -> QEncoding dev '[batchSize] -> QTensor dev '[batchSize, 1]
forwardPolicy :: forall (dev :: (DeviceType, Nat)). (GeluDTypeIsValid dev QDType, RandDTypeIsValid dev QDType, BasicArithmeticDTypeIsValid dev QDType, SumDTypeIsValid dev QDType, MeanDTypeValidation dev QDType, StandardFloatingPointDTypeValidation dev QDType, KnownDevice dev) => QModel dev -> QEncoding dev ('[] :: [Nat]) -> QTensor dev '[1]
forwardPolicyBatched :: forall (dev :: (DeviceType, Nat)) (batchSize :: Nat). (OrdCond (CmpNat 1 batchSize) 'True 'True 'False ~ 'True, GeluDTypeIsValid dev QDType, RandDTypeIsValid dev QDType, BasicArithmeticDTypeIsValid dev QDType, SumDTypeIsValid dev QDType, MeanDTypeValidation dev QDType, StandardFloatingPointDTypeValidation dev QDType, KnownDevice dev) => QModel dev -> QEncoding dev '[batchSize] -> QTensor dev '[batchSize, 1]
forwardValue :: forall (dev :: (DeviceType, Nat)). IsValidDevice dev => QModel dev -> StateEncoding dev -> QTensor dev '[1]

-- | A loss for any model with 0 gradients everywhere. Can be used to
--   ensure that all parameters have a gradient, if not all parameters are
--   used in the real loss.
fakeLoss :: forall (dev :: (DeviceType, Nat)) (ps :: [Type]). (IsValidDevice dev, ps ~ Parameters (QModel dev)) => QModel dev -> QTensor dev ('[] :: [Nat])
mkQModel :: forall (dev :: (DeviceType, Nat)). IsValidDevice dev => IO (QModel dev)
loadModel :: forall (dev :: (DeviceType, Nat)). IsValidDevice dev => FilePath -> IO (QModel dev)
saveModel :: forall (dev :: (DeviceType, Nat)). FilePath -> QModel dev -> IO ()
modelSize :: forall (dev :: (DeviceType, Nat)). QModel dev -> Int
runQ :: forall (dev :: (DeviceType, Nat)) s a. IsValidDevice dev => (s -> a -> QEncoding dev ('[] :: [Nat])) -> QModel dev -> s -> a -> QType
runQ' :: forall (dev :: (DeviceType, Nat)) s a. IsValidDevice dev => (s -> a -> QEncoding dev ('[] :: [Nat])) -> QModel dev -> s -> a -> QTensor dev '[1]
runBatchedPolicy :: forall (dev :: (DeviceType, Nat)) (batchSize :: Nat). (IsValidDevice dev, KnownNat batchSize) => QModel dev -> QEncoding dev '[batchSize] -> Tensor
instance GHC.Internal.Generics.Generic (RL.Model.ActionEncoder dev)
instance GHC.Internal.Generics.Generic (RL.Model.ConstEmb dev shape)
instance GHC.Internal.Generics.Generic (RL.Model.QModel dev)
instance GHC.Internal.Generics.Generic (RL.Model.SliceEncoder dev)
instance GHC.Internal.Generics.Generic (RL.Model.StateEncoder dev)
instance GHC.Internal.Generics.Generic (RL.Model.TransitionEncoder dev)
instance (RL.ModelTypes.IsValidDevice dev, outShape GHC.Types.~ (batchSize : RL.ModelTypes.EmbSize : RL.ModelTypes.PShape), 1 Data.TypeNums.Comparison.<= batchSize) => Torch.NN.HasForward (RL.Model.ActionEncoder dev) (RL.Model.SliceEncoder dev, RL.Model.TransitionEncoder dev, RL.Encoding.ActionEncoding dev '[batchSize]) (RL.ModelTypes.QTensor dev outShape)
instance Torch.NN.HasForward (RL.Model.ConstEmb dev size) () (RL.ModelTypes.QTensor dev size)
instance (RL.ModelTypes.IsValidDevice dev, Torch.Typed.Auxiliary.CheckIsSuffixOf '[RL.ModelTypes.QOutHidden] '[1, RL.ModelTypes.QOutHidden] (RL.ModelTypes.QOutHidden GHC.Internal.Data.Type.Equality.== RL.ModelTypes.QOutHidden)) => Torch.NN.HasForward (RL.Model.QModel dev) (RL.Encoding.QEncoding dev '[]) (RL.ModelTypes.QTensor dev '[1])
instance (RL.ModelTypes.IsValidDevice dev, GHC.Internal.TypeNats.KnownNat batchSize, 1 Data.TypeNums.Comparison.<= batchSize, Torch.Typed.Auxiliary.CheckIsSuffixOf '[RL.ModelTypes.QOutHidden] '[batchSize, RL.ModelTypes.QOutHidden] (RL.ModelTypes.QOutHidden GHC.Internal.Data.Type.Equality.== RL.ModelTypes.QOutHidden)) => Torch.NN.HasForward (RL.Model.QModel dev) (RL.Encoding.QEncoding dev '[batchSize]) (RL.ModelTypes.QTensor dev '[batchSize, 1])
instance (embshape GHC.Types.~ RL.ModelTypes.EmbShape, RL.ModelTypes.IsValidDevice dev) => Torch.NN.HasForward (RL.Model.SliceEncoder dev) (RL.Encoding.QStartStop dev '[] (RL.Encoding.SliceEncoding dev '[])) (RL.ModelTypes.QTensor dev embshape)
instance (RL.ModelTypes.IsValidDevice dev, embshape GHC.Types.~ (batchSize : RL.ModelTypes.EmbSize : RL.ModelTypes.PShape)) => Torch.NN.HasForward (RL.Model.SliceEncoder dev) (RL.Encoding.QStartStop dev '[batchSize] (RL.Encoding.SliceEncoding dev '[batchSize])) (RL.ModelTypes.QTensor dev embshape)
instance (embshape GHC.Types.~ RL.ModelTypes.EmbShape, RL.ModelTypes.IsValidDevice dev) => Torch.NN.HasForward (RL.Model.SliceEncoder dev) (RL.Encoding.SliceEncoding dev '[]) (RL.ModelTypes.QTensor dev embshape)
instance (RL.ModelTypes.IsValidDevice dev, embshape GHC.Types.~ '[batchSize, RL.ModelTypes.EmbSize, RL.ModelTypes.FifthSize, RL.ModelTypes.OctaveSize]) => Torch.NN.HasForward (RL.Model.SliceEncoder dev) (RL.Encoding.SliceEncoding dev '[batchSize]) (RL.ModelTypes.QTensor dev embshape)
instance (RL.ModelTypes.IsValidDevice dev, outShape GHC.Types.~ (RL.ModelTypes.EmbSize : RL.ModelTypes.PShape)) => Torch.NN.HasForward (RL.Model.StateEncoder dev) (RL.Model.SliceEncoder dev, RL.Model.TransitionEncoder dev, RL.Encoding.StateEncoding dev) (RL.ModelTypes.QTensor dev outShape)
instance (RL.ModelTypes.IsValidDevice dev, embshape GHC.Types.~ (RL.ModelTypes.EmbSize : RL.ModelTypes.PShape)) => Torch.NN.HasForward (RL.Model.TransitionEncoder dev) (RL.Encoding.TransitionEncoding dev '[]) (RL.ModelTypes.QTensor dev embshape)
instance (RL.ModelTypes.IsValidDevice dev, embshape GHC.Types.~ (batchSize : RL.ModelTypes.EmbSize : RL.ModelTypes.PShape)) => Torch.NN.HasForward (RL.Model.TransitionEncoder dev) (RL.Encoding.TransitionEncoding dev '[batchSize]) (RL.ModelTypes.QTensor dev embshape)
instance Control.DeepSeq.NFData (RL.Model.ActionEncoder dev)
instance Control.DeepSeq.NFData (RL.Model.ConstEmb dev shape)
instance Control.DeepSeq.NFData (RL.Model.QModel dev)
instance Control.DeepSeq.NFData (RL.Model.SliceEncoder dev)
instance Control.DeepSeq.NFData (RL.Model.StateEncoder dev)
instance Control.DeepSeq.NFData (RL.Model.TransitionEncoder dev)
instance NoThunks.Class.NoThunks (RL.Model.ActionEncoder dev)
instance NoThunks.Class.NoThunks (RL.Model.ConstEmb dev shape)
instance NoThunks.Class.NoThunks (RL.Model.QModel dev)
instance NoThunks.Class.NoThunks (RL.Model.SliceEncoder dev)
instance NoThunks.Class.NoThunks (RL.Model.StateEncoder dev)
instance NoThunks.Class.NoThunks (RL.Model.TransitionEncoder dev)
instance Torch.Typed.Parameter.Parameterized (RL.Model.ActionEncoder dev)
instance Torch.Typed.Parameter.Parameterized (RL.Model.ConstEmb dev shape)
instance Torch.Typed.Parameter.Parameterized (RL.Model.QModel dev)
instance Torch.Typed.Parameter.Parameterized (RL.Model.SliceEncoder dev)
instance Torch.Typed.Parameter.Parameterized (RL.Model.StateEncoder dev)
instance Torch.Typed.Parameter.Parameterized (RL.Model.TransitionEncoder dev)
instance RL.ModelTypes.IsValidDevice dev => Torch.NN.Randomizable (RL.Model.ActionSpec dev) (RL.Model.ActionEncoder dev)
instance (RL.ModelTypes.IsValidDevice dev, Torch.Typed.Tensor.TensorOptions shape RL.ModelTypes.QDType dev) => Torch.NN.Randomizable (RL.Model.ConstEmbSpec dev shape) (RL.Model.ConstEmb dev shape)
instance RL.ModelTypes.IsValidDevice dev => Torch.NN.Randomizable (RL.Model.QSpec dev) (RL.Model.QModel dev)
instance RL.ModelTypes.IsValidDevice dev => Torch.NN.Randomizable (RL.Model.SliceSpec dev) (RL.Model.SliceEncoder dev)
instance RL.ModelTypes.IsValidDevice dev => Torch.NN.Randomizable (RL.Model.StateSpec dev) (RL.Model.StateEncoder dev)
instance RL.ModelTypes.IsValidDevice dev => Torch.NN.Randomizable (RL.Model.TransitionSpec dev) (RL.Model.TransitionEncoder dev)
instance GHC.Internal.Show.Show (RL.Model.ActionEncoder dev)
instance GHC.Internal.Show.Show (RL.Model.ConstEmb dev shape)
instance GHC.Internal.Show.Show (RL.Model.QModel dev)
instance GHC.Internal.Show.Show (RL.Model.SliceEncoder dev)
instance GHC.Internal.Show.Show (RL.Model.StateEncoder dev)
instance GHC.Internal.Show.Show (RL.Model.TransitionEncoder dev)

module RL.Jit
compileBatchedPolicy :: forall (dev :: (DeviceType, Nat)) (bs :: Nat). (IsValidDevice dev, KnownNat bs) => ScriptCache -> QModel dev -> QEncoding dev '[bs] -> Tensor

module RL.DQN
gamma :: forall (dev :: (DeviceType, Nat)). KnownDevice dev => QTensor dev ('[] :: [Nat])
tau :: QType
learningRate :: forall (dev :: (DeviceType, Nat)). IsValidDevice dev => Double -> LearningRate dev QDType
bufferSize :: Int
replayN :: Int
epsStart :: QType
epsEnd :: QType
eps :: Int -> Int -> QType
data DQNState (dev :: (DeviceType, Nat)) opt tr tr' slc s f h (r :: k)
DQNState :: !QModel dev -> !QModel dev -> !opt -> !ReplayBuffer dev tr tr' slc s f h -> DQNState (dev :: (DeviceType, Nat)) opt tr tr' slc s f h (r :: k)
[pnet] :: DQNState (dev :: (DeviceType, Nat)) opt tr tr' slc s f h (r :: k) -> !QModel dev
[tnet] :: DQNState (dev :: (DeviceType, Nat)) opt tr tr' slc s f h (r :: k) -> !QModel dev
[opt] :: DQNState (dev :: (DeviceType, Nat)) opt tr tr' slc s f h (r :: k) -> !opt
[buffer] :: DQNState (dev :: (DeviceType, Nat)) opt tr tr' slc s f h (r :: k) -> !ReplayBuffer dev tr tr' slc s f h
greedyPolicy :: forall m embedding (dev :: (DeviceType, Nat)). Applicative m => (embedding -> QTensor dev '[1]) -> [embedding] -> m Int
epsilonic :: StatefulGen gen m => gen -> QType -> ([embedding] -> m Int) -> [embedding] -> m Int
softmaxPolicy :: forall gen m embedding (dev :: (DeviceType, Nat)). StatefulGen gen m => gen -> (embedding -> QTensor dev '[1]) -> [embedding] -> m Int
runEpisode :: forall {k} (dev :: (DeviceType, Nat)) tr tr' slc slc' s f h (gen :: k) state action encoding step. (state ~ GreedyState tr tr' slc (Leftmost s f h), action ~ Action slc tr s f h, encoding ~ QEncoding dev ('[] :: [Nat]), step ~ (state, action, encoding, Maybe (state, [encoding]), Maybe Bool)) => Eval tr tr' slc slc' h (Leftmost s f h) -> (state -> action -> encoding) -> ([encoding] -> IO Int) -> Path slc' tr' -> IO (Either String ([step], Analysis s f h tr slc))
trainLoop :: forall (dev :: (DeviceType, Nat)) tr tr' slc slc' s f h gen opt {device :: (DeviceType, Nat)}. (GeluDTypeIsValid dev QDType, RandDTypeIsValid dev QDType, SumDTypeIsValid dev QDType, MeanDTypeValidation dev QDType, StandardFloatingPointDTypeValidation dev QDType, GeluDTypeIsValid device QDType, RandDTypeIsValid device QDType, BasicArithmeticDTypeIsValid device QDType, SumDTypeIsValid device QDType, MeanDTypeValidation device QDType, StandardFloatingPointDTypeValidation device QDType, BasicArithmeticDTypeIsValid dev 'Double, StatefulGen gen IO, Optimizer opt '[Tensor dev 'Double '[8, 1, 1, 1], Tensor dev 'Double '[8], Tensor dev 'Double '[8, 8, 13, 5], Tensor dev 'Double '[8], Tensor dev 'Double '[EmbSize, 13, 5], Tensor dev 'Double '[EmbSize, 13, 5], Tensor dev 'Double '[8, 2, 13, 5], Tensor dev 'Double '[8], Tensor dev 'Double '[8, 2, 13, 5], Tensor dev 'Double '[8], Tensor dev 'Double '[8, 1, 1, 1], Tensor dev 'Double '[8], Tensor dev 'Double '[8, 1, 1, 1], Tensor dev 'Double '[8], Tensor dev 'Double '[QTransHidden], Tensor dev 'Double '[8, 8, 13, 5], Tensor dev 'Double '[8], Tensor dev 'Double '[8, 8, 13, 5], Tensor dev 'Double '[8], Tensor dev 'Double '[8, 8, 13, 5], Tensor dev 'Double '[8], Tensor dev 'Double '[8, 8, 13, 5], Tensor dev 'Double '[8], Tensor dev 'Double '[8, 8, 13, 5], Tensor dev 'Double '[8], Tensor dev 'Double '[8, 8, 13, 5], Tensor dev 'Double '[8], Tensor dev 'Double '[8, 8, 13, 5], Tensor dev 'Double '[8], Tensor dev 'Double '[5], Tensor dev 'Double '[5], Tensor dev 'Double '[5], Tensor dev 'Double '[8, 8, 13, 5], Tensor dev 'Double '[8], Tensor dev 'Double '[8, 8, 13, 5], Tensor dev 'Double '[8], Tensor dev 'Double '[8, 8, 13, 5], Tensor dev 'Double '[8], Tensor dev 'Double '[8, 8, 13, 5], Tensor dev 'Double '[8], Tensor dev 'Double '[8, 8, 13, 5], Tensor dev 'Double '[8], Tensor dev 'Double '[8, 8, 13, 5], Tensor dev 'Double '[8], Tensor dev 'Double '[8, 8, 13, 5], Tensor dev 'Double '[8], Tensor dev 'Double '[8, 8, 13, 5], Tensor dev 'Double '[8], Tensor dev 'Double '[QOutHidden], Tensor dev 'Double '[QOutHidden], Tensor dev 'Double '[1, 8], Tensor dev 'Double '[1], Tensor dev 'Double '[8, 8], Tensor dev 'Double '[8], Tensor dev 'Double '[QOutHidden], Tensor dev 'Double '[QOutHidden], Tensor dev 'Double '[1, 8], Tensor dev 'Double '[1]] '[Tensor dev 'Double '[8, 1, 1, 1], Tensor dev 'Double '[8], Tensor dev 'Double '[8, 8, 13, 5], Tensor dev 'Double '[8], Tensor dev 'Double '[EmbSize, 13, 5], Tensor dev 'Double '[EmbSize, 13, 5], Tensor dev 'Double '[8, 2, 13, 5], Tensor dev 'Double '[8], Tensor dev 'Double '[8, 2, 13, 5], Tensor dev 'Double '[8], Tensor dev 'Double '[8, 1, 1, 1], Tensor dev 'Double '[8], Tensor dev 'Double '[8, 1, 1, 1], Tensor dev 'Double '[8], Tensor dev 'Double '[QTransHidden], Tensor dev 'Double '[8, 8, 13, 5], Tensor dev 'Double '[8], Tensor dev 'Double '[8, 8, 13, 5], Tensor dev 'Double '[8], Tensor dev 'Double '[8, 8, 13, 5], Tensor dev 'Double '[8], Tensor dev 'Double '[8, 8, 13, 5], Tensor dev 'Double '[8], Tensor dev 'Double '[8, 8, 13, 5], Tensor dev 'Double '[8], Tensor dev 'Double '[8, 8, 13, 5], Tensor dev 'Double '[8], Tensor dev 'Double '[8, 8, 13, 5], Tensor dev 'Double '[8], Tensor dev 'Double '[5], Tensor dev 'Double '[5], Tensor dev 'Double '[5], Tensor dev 'Double '[8, 8, 13, 5], Tensor dev 'Double '[8], Tensor dev 'Double '[8, 8, 13, 5], Tensor dev 'Double '[8], Tensor dev 'Double '[8, 8, 13, 5], Tensor dev 'Double '[8], Tensor dev 'Double '[8, 8, 13, 5], Tensor dev 'Double '[8], Tensor dev 'Double '[8, 8, 13, 5], Tensor dev 'Double '[8], Tensor dev 'Double '[8, 8, 13, 5], Tensor dev 'Double '[8], Tensor dev 'Double '[8, 8, 13, 5], Tensor dev 'Double '[8], Tensor dev 'Double '[8, 8, 13, 5], Tensor dev 'Double '[8], Tensor dev 'Double '[QOutHidden], Tensor dev 'Double '[QOutHidden], Tensor dev 'Double '[1, 8], Tensor dev 'Double '[1], Tensor dev 'Double '[8, 8], Tensor dev 'Double '[8], Tensor dev 'Double '[QOutHidden], Tensor dev 'Double '[QOutHidden], Tensor dev 'Double '[1, 8], Tensor dev 'Double '[1]] QDType device, KnownDevice device, KnownDevice dev) => gen -> Eval tr tr' slc slc' h (Leftmost s f h) -> (GreedyState tr tr' slc (Leftmost s f h) -> Action slc tr s f h -> QEncoding dev ('[] :: [Nat])) -> (Analysis s f h tr slc -> IO QType) -> (Action slc tr s f h -> Maybe Bool -> IO QType) -> Path slc' tr' -> DQNState dev opt tr tr' slc s f h QType -> Int -> Int -> IO (DQNState dev opt tr tr' slc s f h QType, QType, QType)
trainDQN :: forall (dev :: (DeviceType, Nat)) gen tr tr' slc slc' s f h. (IsValidDevice dev, StatefulGen gen IO, Show s, Show f, Show h, s ~ Split SPitch, f ~ Freeze SPitch, h ~ Spread SPitch, Show slc, Show tr) => gen -> Eval tr tr' slc slc' h (Leftmost s f h) -> (GreedyState tr tr' slc (Leftmost s f h) -> Action slc tr s f h -> QEncoding dev ('[] :: [Nat])) -> (Analysis s f h tr slc -> IO QType) -> (Action slc tr s f h -> Maybe Bool -> IO QType) -> [Path slc' tr'] -> Int -> IO ([QType], [QType], QModel dev)
hi :: String -> IO ()

module RL.A2CHelpers
type ModelParams (dev :: (DeviceType, Nat)) = Parameters QModel dev
type ModelTensors (dev :: (DeviceType, Nat)) = ToModelTensors ModelParams dev
newtype UpdateEligCritic
UpdateEligCritic :: QType -> UpdateEligCritic
updateEligCritic :: forall (dev :: (DeviceType, Nat)). KnownDevice dev => QType -> QType -> HList (ModelTensors dev) -> HList (ModelTensors dev) -> HList (ModelTensors dev)
data UpdateEligActor
UpdateEligActor :: QType -> QType -> UpdateEligActor
updateEligActor :: forall (dev :: (DeviceType, Nat)). KnownDevice dev => QType -> QType -> QType -> HList (ModelTensors dev) -> HList (ModelTensors dev) -> HList (ModelTensors dev)
mulModelTensors :: forall (dev :: (DeviceType, Nat)). IsValidDevice dev => QTensor dev ('[] :: [Nat]) -> HList (ModelTensors dev) -> HList (ModelTensors dev)
modelZeros :: forall (dev :: (DeviceType, Nat)). IsValidDevice dev => QModel dev -> HList (ModelTensors dev)
sumTensorList :: forall (dev :: (DeviceType, Nat)). IsValidDevice dev => HList (ModelTensors dev) -> QTensor dev ('[] :: [Nat])
instance Torch.Typed.Tensor.KnownDevice dev => Torch.HList.Apply' RL.A2CHelpers.UpdateEligActor (RL.ModelTypes.QTensor dev shape, RL.ModelTypes.QTensor dev shape) (RL.ModelTypes.QTensor dev shape)
instance Torch.Typed.Tensor.KnownDevice dev => Torch.HList.Apply' RL.A2CHelpers.UpdateEligCritic (RL.ModelTypes.QTensor dev shape, RL.ModelTypes.QTensor dev shape) (RL.ModelTypes.QTensor dev shape)

module RL.A2C
gamma :: QType
lambdaV :: QType
lambdaP :: QType
nWorkers :: Int
printTensors :: forall (dev :: (DeviceType, Nat)). HList (ModelTensors dev) -> IO ()
printParams :: forall (dev :: (DeviceType, Nat)). HList (ModelParams dev) -> IO ()
data A2CState (dev :: (DeviceType, Nat))
A2CState :: !QModel dev -> !QModel dev -> !GD -> !GD -> A2CState (dev :: (DeviceType, Nat))
[a2cActor] :: A2CState (dev :: (DeviceType, Nat)) -> !QModel dev
[a2cCritic] :: A2CState (dev :: (DeviceType, Nat)) -> !QModel dev
[a2cOptActor] :: A2CState (dev :: (DeviceType, Nat)) -> !GD
[a2cOptCritic] :: A2CState (dev :: (DeviceType, Nat)) -> !GD
data A2CStepState (dev :: (DeviceType, Nat))
A2CStepState :: !HList (ModelTensors dev) -> !HList (ModelTensors dev) -> !QType -> !QType -> !GreedyState (Edges SPitch) [Edge SPitch] (Notes SPitch) (PVLeftmost SPitch) -> !NonEmpty PVAction -> A2CStepState (dev :: (DeviceType, Nat))
[a2cStepZV] :: A2CStepState (dev :: (DeviceType, Nat)) -> !HList (ModelTensors dev)
[a2cStepZP] :: A2CStepState (dev :: (DeviceType, Nat)) -> !HList (ModelTensors dev)
[a2cStepIntensity] :: A2CStepState (dev :: (DeviceType, Nat)) -> !QType
[a2cStepReward] :: A2CStepState (dev :: (DeviceType, Nat)) -> !QType
[a2cStepState] :: A2CStepState (dev :: (DeviceType, Nat)) -> !GreedyState (Edges SPitch) [Edge SPitch] (Notes SPitch) (PVLeftmost SPitch)
[a2cStepActions] :: A2CStepState (dev :: (DeviceType, Nat)) -> !NonEmpty PVAction
initPieceState :: forall (dev :: (DeviceType, Nat)). KnownDevice dev => Eval (Edges SPitch) [Edge SPitch] (Notes SPitch) [Note SPitch] (Spread SPitch) (PVLeftmost SPitch) -> Path [Note SPitch] [Edge SPitch] -> HList (ModelTensors dev) -> Either (A2CStepState dev) QType
pieceStep :: forall (dev :: (DeviceType, Nat)) label. IsValidDevice dev => Eval (Edges SPitch) [Edge SPitch] (Notes SPitch) [Note SPitch] (Spread SPitch) (PVLeftmost SPitch) -> IOGenM StdGen -> PVRewardFn label -> label -> QType -> QType -> Int -> A2CState dev -> A2CStepState dev -> ExceptT String IO (A2CState dev, Either (A2CStepState dev) QType, QType)

-- | Run an episode
runEpisode :: forall (dev :: (DeviceType, Nat)) label. (GeluDTypeIsValid dev QDType, RandDTypeIsValid dev QDType, BasicArithmeticDTypeIsValid dev QDType, SumDTypeIsValid dev QDType, MeanDTypeValidation dev QDType, StandardFloatingPointDTypeValidation dev QDType, KnownDevice dev) => Eval (Edges SPitch) [Edge SPitch] (Notes SPitch) [Note SPitch] (Spread SPitch) (PVLeftmost SPitch) -> IOGenM StdGen -> PVRewardFn label -> (QType -> QType) -> (QType -> QType) -> Path [Note SPitch] [Edge SPitch] -> label -> A2CState dev -> Int -> IO (Either String (A2CState dev, QType, QType))
runAccuracy :: forall (dev :: (DeviceType, Nat)) slc' label. IsValidDevice dev => Eval (Edges SPitch) [Edge SPitch] (Notes SPitch) slc' (Spread SPitch) (PVLeftmost SPitch) -> PVRewardFn label -> QModel dev -> (Path slc' [Edge SPitch], label) -> IO (Either String (QType, PVAnalysis SPitch))
data A2CLoopState (dev :: (DeviceType, Nat))
A2CLoopState :: A2CState dev -> List (List QType) -> List (List QType) -> List (List QType) -> A2CLoopState (dev :: (DeviceType, Nat))
[a2clState] :: A2CLoopState (dev :: (DeviceType, Nat)) -> A2CState dev
[a2clRewards] :: A2CLoopState (dev :: (DeviceType, Nat)) -> List (List QType)
[a2clLosses] :: A2CLoopState (dev :: (DeviceType, Nat)) -> List (List QType)
[a2clAccs] :: A2CLoopState (dev :: (DeviceType, Nat)) -> List (List QType)
trainA2C :: forall (dev :: (DeviceType, Nat)) label. IsValidDevice dev => Eval (Edges SPitch) [Edge SPitch] (Notes SPitch) [Note SPitch] (Spread SPitch) (PVLeftmost SPitch) -> IOGenM StdGen -> PVRewardFn label -> (QType -> QType) -> (QType -> QType) -> Maybe [QType] -> QModel dev -> QModel dev -> [(Path [Note SPitch] [Edge SPitch], label)] -> Int -> IO ([[QType]], [QType], QModel dev, QModel dev)
instance GHC.Internal.Generics.Generic (RL.A2C.A2CLoopState dev)
instance GHC.Internal.Generics.Generic (RL.A2C.A2CState dev)
instance NoThunks.Class.NoThunks a => NoThunks.Class.NoThunks (StrictList.List a)

module RL
trainDQN :: forall (dev :: (DeviceType, Nat)) gen tr tr' slc slc' s f h. (IsValidDevice dev, StatefulGen gen IO, Show s, Show f, Show h, s ~ Split SPitch, f ~ Freeze SPitch, h ~ Spread SPitch, Show slc, Show tr) => gen -> Eval tr tr' slc slc' h (Leftmost s f h) -> (GreedyState tr tr' slc (Leftmost s f h) -> Action slc tr s f h -> QEncoding dev ('[] :: [Nat])) -> (Analysis s f h tr slc -> IO QType) -> (Action slc tr s f h -> Maybe Bool -> IO QType) -> [Path slc' tr'] -> Int -> IO ([QType], [QType], QModel dev)
trainA2C :: forall (dev :: (DeviceType, Nat)) label. IsValidDevice dev => Eval (Edges SPitch) [Edge SPitch] (Notes SPitch) [Note SPitch] (Spread SPitch) (PVLeftmost SPitch) -> IOGenM StdGen -> PVRewardFn label -> (QType -> QType) -> (QType -> QType) -> Maybe [QType] -> QModel dev -> QModel dev -> [(Path [Note SPitch] [Edge SPitch], label)] -> Int -> IO ([[QType]], [QType], QModel dev, QModel dev)

module RLNoLearn
