<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="annot"><span class="hs-comment">{-|
Copyright  :  (C) 2016     , University of Twente,
                  2017-2018, QBayLogic B.V.,
                  2017     , Google Inc.
License    :  BSD2 (see the file LICENSE)
Maintainer :  Christiaan Baaij &lt;christiaan.baaij@gmail.com&gt;

A type checker plugin for GHC that can derive \&quot;complex\&quot; @KnownNat@
constraints from other simple/variable @KnownNat@ constraints. i.e. without
this plugin, you must have both a @KnownNat n@ and a @KnownNat (n+2)@
constraint in the type signature of the following function:

@
f :: forall n . (KnownNat n, KnownNat (n+2)) =&gt; Proxy n -&gt; Integer
f _ = natVal (Proxy :: Proxy n) + natVal (Proxy :: Proxy (n+2))
@

Using the plugin you can omit the @KnownNat (n+2)@ constraint:

@
f :: forall n . KnownNat n =&gt; Proxy n -&gt; Integer
f _ = natVal (Proxy :: Proxy n) + natVal (Proxy :: Proxy (n+2))
@

The plugin can derive @KnownNat@ constraints for types consisting of:

* Type variables, when there is a corresponding @KnownNat@ constraint
* Type-level naturals
* Applications of the arithmetic expression: @{+,-,*,^}@
* Type functions, when there is either:
  * a matching given @KnownNat@ constraint; or
  * a corresponding @KnownNat\&lt;N\&gt;@ instance for the type function

To elaborate the latter points, given the type family @Min@:

@
type family Min (a :: Nat) (b :: Nat) :: Nat where
  Min 0 b = 0
  Min a b = If (a &lt;=? b) a b
@

the plugin can derive a @KnownNat (Min x y + 1)@ constraint given only a
@KnownNat (Min x y)@ constraint:

@
g :: forall x y . (KnownNat (Min x y)) =&gt; Proxy x -&gt; Proxy y -&gt; Integer
g _ _ = natVal (Proxy :: Proxy (Min x y + 1))
@

And, given the type family @Max@:

@
type family Max (a :: Nat) (b :: Nat) :: Nat where
  Max 0 b = b
  Max a b = If (a &lt;=? b) b a
@

and corresponding @KnownNat2@ instance:

@
instance (KnownNat a, KnownNat b) =&gt; KnownNat2 \&quot;TestFunctions.Max\&quot; a b where
  natSing2 = let x = natVal (Proxy @a)
                 y = natVal (Proxy @b)
                 z = max x y
             in  SNatKn z
  \{\-# INLINE natSing2 \#-\}
@

the plugin can derive a @KnownNat (Max x y + 1)@ constraint given only a
@KnownNat x@ and @KnownNat y@ constraint:

@
h :: forall x y . (KnownNat x, KnownNat y) =&gt; Proxy x -&gt; Proxy y -&gt; Integer
h _ _ = natVal (Proxy :: Proxy (Max x y + 1))
@

To use the plugin, add the

@
OPTIONS_GHC -fplugin GHC.TypeLits.KnownNat.Solver
@

Pragma to the header of your file.

-}</span></span><span>
</span><span id="line-86"></span><span>
</span><span id="line-87"></span><span class="hs-pragma">{-# LANGUAGE CPP           #-}</span><span>
</span><span id="line-88"></span><span class="hs-pragma">{-# LANGUAGE LambdaCase    #-}</span><span>
</span><span id="line-89"></span><span class="hs-pragma">{-# LANGUAGE TupleSections #-}</span><span>
</span><span id="line-90"></span><span class="hs-pragma">{-# LANGUAGE ViewPatterns  #-}</span><span>
</span><span id="line-91"></span><span class="hs-pragma">{-# LANGUAGE TemplateHaskellQuotes #-}</span><span>
</span><span id="line-92"></span><span class="hs-pragma">{-# LANGUAGE Trustworthy   #-}</span><span>
</span><span id="line-93"></span><span>
</span><span id="line-94"></span><span class="hs-pragma">{-# OPTIONS_HADDOCK show-extensions #-}</span><span>
</span><span id="line-95"></span><span>
</span><span id="line-96"></span><span class="hs-keyword">module</span><span> </span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html"><span class="hs-identifier">GHC.TypeLits.KnownNat.Solver</span></a></span><span>
</span><span id="line-97"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#plugin"><span class="hs-identifier">plugin</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-98"></span><span class="hs-keyword">where</span><span>
</span><span id="line-99"></span><span>
</span><span id="line-100"></span><span class="hs-comment">-- external</span><span>
</span><span id="line-101"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Arrow</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-operator">(&amp;&amp;&amp;)</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">first</span></span><span class="hs-special">)</span><span>
</span><span id="line-102"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad.Trans.Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">MaybeT</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-103"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad.Trans.Writer.Strict</span></span><span>
</span><span id="line-104"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">catMaybes</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">fromMaybe</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">mapMaybe</span></span><span class="hs-special">)</span><span>
</span><span id="line-105"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Type.Ord</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">OrdCond</span></span><span class="hs-special">)</span><span>
</span><span id="line-106"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Type.Bool</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">If</span></span><span class="hs-special">)</span><span>
</span><span id="line-107"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.TcPluginM.Extra</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">newWanted</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">tracePlugin</span></span><span class="hs-special">)</span><span>
</span><span id="line-108"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.TypeLits.Normalise.SOP</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">SOP</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Product</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Symbol</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-109"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.TypeLits.Normalise.Unify</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">CType</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier">normaliseNat</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier">reifySOP</span></span><span class="hs-special">)</span><span>
</span><span id="line-110"></span><span>
</span><span id="line-111"></span><span class="hs-comment">-- GHC API</span><span>
</span><span id="line-112"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Builtin.Names</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">knownNatClassName</span></span><span class="hs-special">)</span><span>
</span><span id="line-113"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Builtin.Types</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">boolTy</span></span><span class="hs-special">)</span><span>
</span><span id="line-114"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Builtin.Types.Literals</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">typeNatAddTyCon</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">typeNatDivTyCon</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">typeNatSubTyCon</span></span><span class="hs-special">)</span><span>
</span><span id="line-115"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Builtin.Types</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">promotedFalseDataCon</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">promotedTrueDataCon</span></span><span class="hs-special">)</span><span>
</span><span id="line-116"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Builtin.Types.Literals</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">typeNatCmpTyCon</span></span><span class="hs-special">)</span><span>
</span><span id="line-117"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Core.Class</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Class</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">classMethods</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">className</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">classTyCon</span></span><span class="hs-special">)</span><span>
</span><span id="line-118"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Core.Coercion</span></span><span>
</span><span id="line-119"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Coercion</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Role</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Nominal</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Representational</span></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">coercionRKind</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">mkNomReflCo</span></span><span class="hs-special">,</span><span>
</span><span id="line-120"></span><span>   </span><span class="annot"><span class="hs-identifier">mkTyConAppCo</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">mkUnivCo</span></span><span class="hs-special">)</span><span>
</span><span id="line-121"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Core.InstEnv</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">instanceDFunId</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">lookupUniqueInstEnv</span></span><span class="hs-special">)</span><span>
</span><span id="line-122"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Core.Make</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">mkNaturalExpr</span></span><span class="hs-special">)</span><span>
</span><span id="line-123"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Core.Predicate</span></span><span>
</span><span id="line-124"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">EqRel</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">NomEq</span></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Pred</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">ClassPred</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier">EqPred</span></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">classifyPredType</span></span><span class="hs-special">)</span><span>
</span><span id="line-125"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Core.TyCo.Rep</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Type</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">TyLit</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">UnivCoProvenance</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">PluginProv</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-126"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Core.TyCon</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">tyConName</span></span><span class="hs-special">)</span><span class="hs-cpp">
#if MIN_VERSION_ghc(9,6,0)
</span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Core.Type</span></span><span>
</span><span id="line-129"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">PredType</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">dropForAlls</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">funResultTy</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">mkNumLitTy</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">mkStrLitTy</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">mkTyConApp</span></span><span class="hs-special">,</span><span>
</span><span id="line-130"></span><span>   </span><span class="annot"><span class="hs-identifier">piResultTys</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">splitFunTys</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">splitTyConApp_maybe</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">tyConAppTyCon_maybe</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">typeKind</span></span><span class="hs-special">,</span><span>
</span><span id="line-131"></span><span>   </span><span class="annot"><span class="hs-identifier">irrelevantMult</span></span><span class="hs-special">)</span><span>
</span><span id="line-132"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Core.TyCo.Compare</span></span><span>
</span><span id="line-133"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">eqType</span></span><span class="hs-special">)</span><span class="hs-cpp">
#else
</span><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">GHC.Core.Type</span><span>
</span><span id="line-136"></span><span>  </span><span class="hs-special">(</span><span class="hs-identifier">PredType</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">dropForAlls</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">eqType</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">funResultTy</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">mkNumLitTy</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">mkStrLitTy</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">mkTyConApp</span><span class="hs-special">,</span><span>
</span><span id="line-137"></span><span>   </span><span class="hs-identifier">piResultTys</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">splitFunTys</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">splitTyConApp_maybe</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">tyConAppTyCon_maybe</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">typeKind</span><span class="hs-special">,</span><span>
</span><span id="line-138"></span><span>   </span><span class="hs-identifier">irrelevantMult</span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Data.FastString</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">fsLit</span></span><span class="hs-special">)</span><span>
</span><span id="line-141"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Driver.Plugins</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Plugin</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">defaultPlugin</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">purePlugin</span></span><span class="hs-special">)</span><span>
</span><span id="line-142"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Tc.Instance.Family</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">tcInstNewTyCon_maybe</span></span><span class="hs-special">)</span><span>
</span><span id="line-143"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Tc.Plugin</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">TcPluginM</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">tcLookupClass</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">getInstEnvs</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">unsafeTcPluginTcM</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">tcPluginIO</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">tcLookupTyCon</span></span><span class="hs-special">)</span><span>
</span><span id="line-144"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Tc.Types</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">TcPlugin</span></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">TcPluginSolveResult</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">getPlatform</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">env_top</span></span><span class="hs-special">)</span><span>
</span><span id="line-145"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Tc.Types.Constraint</span></span><span>
</span><span id="line-146"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Ct</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">ctEvExpr</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">ctEvidence</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">ctEvPred</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">ctLoc</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">mkNonCanonical</span></span><span class="hs-special">)</span><span class="hs-cpp">
#if MIN_VERSION_ghc(9,6,0)
</span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Tc.Types.Evidence</span></span><span>
</span><span id="line-149"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">EvTerm</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">EvExpr</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">EvBindsVar</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">evDFunApp</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">mkEvCast</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">evTermCoercion_maybe</span></span><span class="hs-special">)</span><span>
</span><span id="line-150"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Plugins</span></span><span>
</span><span id="line-151"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">mkSymCo</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">mkTransCo</span></span><span class="hs-special">)</span><span class="hs-cpp">
#else
</span><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">GHC.Tc.Types.Evidence</span><span>
</span><span id="line-154"></span><span>  </span><span class="hs-special">(</span><span class="hs-identifier">EvTerm</span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">EvExpr</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">EvBindsVar</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">evDFunApp</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">mkEvCast</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">mkTcSymCo</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">mkTcTransCo</span><span class="hs-special">,</span><span>
</span><span id="line-155"></span><span>   </span><span class="hs-identifier">evTermCoercion_maybe</span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Types.Id</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">idType</span></span><span class="hs-special">)</span><span>
</span><span id="line-158"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Types.Name</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">nameModule_maybe</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">nameOccName</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Name</span></span><span class="hs-special">)</span><span>
</span><span id="line-159"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Types.Name.Occurrence</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">occNameString</span></span><span class="hs-special">)</span><span>
</span><span id="line-160"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Types.Unique.FM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">emptyUFM</span></span><span class="hs-special">)</span><span>
</span><span id="line-161"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Types.Var</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">DFunId</span></span><span class="hs-special">)</span><span>
</span><span id="line-162"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Unit.Module</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">moduleName</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">moduleNameString</span></span><span class="hs-special">)</span><span>
</span><span id="line-163"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Language.Haskell.TH</span></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">TH</span></span><span>
</span><span id="line-164"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Plugins</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">thNameToGhcNameIO</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">TyCon</span></span><span class="hs-special">)</span><span>
</span><span id="line-165"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Driver.Env</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">hsc_NC</span></span><span class="hs-special">)</span><span>
</span><span id="line-166"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Data.IOEnv</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">getEnv</span></span><span class="hs-special">)</span><span>
</span><span id="line-167"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.TypeLits.KnownNat.html"><span class="hs-identifier">GHC.TypeLits.KnownNat</span></a></span><span class="hs-cpp">

#if MIN_VERSION_ghc(9,6,0)
</span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#mkTcSymCo"><span class="hs-identifier hs-type">mkTcSymCo</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Coercion</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Coercion</span></span><span>
</span><span id="line-171"></span><span id="mkTcSymCo"><span class="annot"><span class="annottext">mkTcSymCo :: Coercion -&gt; Coercion
</span><a href="GHC.TypeLits.KnownNat.Solver.html#mkTcSymCo"><span class="hs-identifier hs-var hs-var">mkTcSymCo</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Coercion -&gt; Coercion
</span><span class="hs-identifier hs-var">mkSymCo</span></span><span>
</span><span id="line-172"></span><span>
</span><span id="line-173"></span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#mkTcTransCo"><span class="hs-identifier hs-type">mkTcTransCo</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Coercion</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Coercion</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Coercion</span></span><span>
</span><span id="line-174"></span><span id="mkTcTransCo"><span class="annot"><span class="annottext">mkTcTransCo :: Coercion -&gt; Coercion -&gt; Coercion
</span><a href="GHC.TypeLits.KnownNat.Solver.html#mkTcTransCo"><span class="hs-identifier hs-var hs-var">mkTcTransCo</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Coercion -&gt; Coercion -&gt; Coercion
</span><span class="hs-identifier hs-var">mkTransCo</span></span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-177"></span><span class="annot"><span class="hs-comment">-- | Classes and instances from &quot;GHC.TypeLits.KnownNat&quot;</span></span><span>
</span><span id="line-178"></span><span class="hs-keyword">data</span><span> </span><span id="KnownNatDefs"><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#KnownNatDefs"><span class="hs-identifier hs-var">KnownNatDefs</span></a></span></span><span>
</span><span id="line-179"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="KnownNatDefs"><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#KnownNatDefs"><span class="hs-identifier hs-var">KnownNatDefs</span></a></span></span><span>
</span><span id="line-180"></span><span>  </span><span class="hs-special">{</span><span> </span><span id="knownBool"><span class="annot"><span class="annottext">KnownNatDefs -&gt; Class
</span><a href="GHC.TypeLits.KnownNat.Solver.html#knownBool"><span class="hs-identifier hs-var hs-var">knownBool</span></a></span></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Class</span></span><span>
</span><span id="line-181"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="knownBoolNat2"><span class="annot"><span class="annottext">KnownNatDefs -&gt; Class
</span><a href="GHC.TypeLits.KnownNat.Solver.html#knownBoolNat2"><span class="hs-identifier hs-var hs-var">knownBoolNat2</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Class</span></span><span>
</span><span id="line-182"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="knownNat2Bool"><span class="annot"><span class="annottext">KnownNatDefs -&gt; Class
</span><a href="GHC.TypeLits.KnownNat.Solver.html#knownNat2Bool"><span class="hs-identifier hs-var hs-var">knownNat2Bool</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Class</span></span><span>
</span><span id="line-183"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="knownNatN"><span class="annot"><span class="annottext">KnownNatDefs -&gt; Int -&gt; Maybe Class
</span><a href="GHC.TypeLits.KnownNat.Solver.html#knownNatN"><span class="hs-identifier hs-var hs-var">knownNatN</span></a></span></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Class</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ KnownNat{N}</span></span><span>
</span><span id="line-184"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="ordCondTyCon"><span class="annot"><span class="annottext">KnownNatDefs -&gt; TyCon
</span><a href="GHC.TypeLits.KnownNat.Solver.html#ordCondTyCon"><span class="hs-identifier hs-var hs-var">ordCondTyCon</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TyCon</span></span><span>
</span><span id="line-185"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="ifTyCon"><span class="annot"><span class="annottext">KnownNatDefs -&gt; TyCon
</span><a href="GHC.TypeLits.KnownNat.Solver.html#ifTyCon"><span class="hs-identifier hs-var hs-var">ifTyCon</span></a></span></span><span>       </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TyCon</span></span><span>
</span><span id="line-186"></span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-187"></span><span>
</span><span id="line-188"></span><span class="hs-comment">-- | Simple newtype wrapper to distinguish the original (flattened) argument of</span><span>
</span><span id="line-189"></span><span class="hs-comment">-- knownnat from the un-flattened version that we work with internally.</span><span>
</span><span id="line-190"></span><span class="hs-keyword">newtype</span><span> </span><span id="Orig"><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#Orig"><span class="hs-identifier hs-var">Orig</span></a></span></span><span> </span><span id="local-6989586621679223480"><span class="annot"><a href="#local-6989586621679223480"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Orig"><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#Orig"><span class="hs-identifier hs-var">Orig</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="unOrig"><span class="annot"><span class="annottext">forall a. Orig a -&gt; a
</span><a href="GHC.TypeLits.KnownNat.Solver.html#unOrig"><span class="hs-identifier hs-var hs-var">unOrig</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679223480"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-191"></span><span>
</span><span id="line-192"></span><span class="annot"><span class="hs-comment">-- | KnownNat constraints</span></span><span>
</span><span id="line-193"></span><span class="hs-keyword">type</span><span> </span><span id="KnConstraint"><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#KnConstraint"><span class="hs-identifier hs-var">KnConstraint</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Ct</span></span><span>    </span><span class="hs-comment">-- The constraint</span><span>
</span><span id="line-194"></span><span>                    </span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Class</span></span><span> </span><span class="hs-comment">-- KnownNat class</span><span>
</span><span id="line-195"></span><span>                    </span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>  </span><span class="hs-comment">-- The argument to KnownNat</span><span>
</span><span id="line-196"></span><span>                    </span><span class="hs-special">,</span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#Orig"><span class="hs-identifier hs-type">Orig</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>  </span><span class="hs-comment">-- Original, flattened, argument to KnownNat</span><span>
</span><span id="line-197"></span><span>                    </span><span class="hs-special">)</span><span>
</span><span id="line-198"></span><span>
</span><span id="line-199"></span><span class="annot"><span class="hs-comment">{-|
A type checker plugin for GHC that can derive \&quot;complex\&quot; @KnownNat@
constraints from other simple/variable @KnownNat@ constraints. i.e. without
this plugin, you must have both a @KnownNat n@ and a @KnownNat (n+2)@
constraint in the type signature of the following function:

@
f :: forall n . (KnownNat n, KnownNat (n+2)) =&gt; Proxy n -&gt; Integer
f _ = natVal (Proxy :: Proxy n) + natVal (Proxy :: Proxy (n+2))
@

Using the plugin you can omit the @KnownNat (n+2)@ constraint:

@
f :: forall n . KnownNat n =&gt; Proxy n -&gt; Integer
f _ = natVal (Proxy :: Proxy n) + natVal (Proxy :: Proxy (n+2))
@

The plugin can derive @KnownNat@ constraints for types consisting of:

* Type variables, when there is a corresponding @KnownNat@ constraint
* Type-level naturals
* Applications of the arithmetic expression: @{+,-,*,^}@
* Type functions, when there is either:
  * a matching given @KnownNat@ constraint; or
  * a corresponding @KnownNat\&lt;N\&gt;@ instance for the type function

To elaborate the latter points, given the type family @Min@:

@
type family Min (a :: Nat) (b :: Nat) :: Nat where
  Min 0 b = 0
  Min a b = If (a &lt;=? b) a b
@

the plugin can derive a @KnownNat (Min x y + 1)@ constraint given only a
@KnownNat (Min x y)@ constraint:

@
g :: forall x y . (KnownNat (Min x y)) =&gt; Proxy x -&gt; Proxy y -&gt; Integer
g _ _ = natVal (Proxy :: Proxy (Min x y + 1))
@

And, given the type family @Max@:

@
type family Max (a :: Nat) (b :: Nat) :: Nat where
  Max 0 b = b
  Max a b = If (a &lt;=? b) b a

$(genDefunSymbols [''Max]) -- creates the 'MaxSym0' symbol
@

and corresponding @KnownNat2@ instance:

@
instance (KnownNat a, KnownNat b) =&gt; KnownNat2 \&quot;TestFunctions.Max\&quot; a b where
  type KnownNatF2 \&quot;TestFunctions.Max\&quot; = MaxSym0
  natSing2 = let x = natVal (Proxy @ a)
                 y = natVal (Proxy @ b)
                 z = max x y
             in  SNatKn z
  \{\-# INLINE natSing2 \#-\}
@

the plugin can derive a @KnownNat (Max x y + 1)@ constraint given only a
@KnownNat x@ and @KnownNat y@ constraint:

@
h :: forall x y . (KnownNat x, KnownNat y) =&gt; Proxy x -&gt; Proxy y -&gt; Integer
h _ _ = natVal (Proxy :: Proxy (Max x y + 1))
@

To use the plugin, add the

@
OPTIONS_GHC -fplugin GHC.TypeLits.KnownNat.Solver
@

Pragma to the header of your file.

-}</span></span><span>
</span><span id="line-281"></span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#plugin"><span class="hs-identifier hs-type">plugin</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Plugin</span></span><span>
</span><span id="line-282"></span><span id="plugin"><span class="annot"><span class="annottext">plugin :: Plugin
</span><a href="GHC.TypeLits.KnownNat.Solver.html#plugin"><span class="hs-identifier hs-var hs-var">plugin</span></a></span></span><span>
</span><span id="line-283"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Plugin
</span><span class="hs-identifier hs-var">defaultPlugin</span></span><span>
</span><span id="line-284"></span><span>  </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="hs-identifier hs-var">tcPlugin</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">const</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#normalisePlugin"><span class="hs-identifier hs-type">normalisePlugin</span></a></span><span class="hs-cpp">
#if MIN_VERSION_ghc(8,6,0)
</span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-var">pluginRecompile</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">purePlugin</span></span><span class="hs-cpp">
#endif
</span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-289"></span><span>
</span><span id="line-290"></span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#normalisePlugin"><span class="hs-identifier hs-type">normalisePlugin</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TcPlugin</span></span><span>
</span><span id="line-291"></span><span id="normalisePlugin"><span class="annot"><span class="annottext">normalisePlugin :: TcPlugin
</span><a href="GHC.TypeLits.KnownNat.Solver.html#normalisePlugin"><span class="hs-identifier hs-var hs-var">normalisePlugin</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CommandLineOption -&gt; TcPlugin -&gt; TcPlugin
</span><span class="hs-identifier hs-var">tracePlugin</span></span><span> </span><span class="annot"><span class="annottext">CommandLineOption
</span><span class="hs-string">&quot;ghc-typelits-knownnat&quot;</span></span><span>
</span><span id="line-292"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">TcPlugin</span></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">tcPluginInit :: TcPluginM KnownNatDefs
</span><span class="hs-identifier hs-var">tcPluginInit</span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TcPluginM KnownNatDefs
</span><a href="GHC.TypeLits.KnownNat.Solver.html#lookupKnownNatDefs"><span class="hs-identifier hs-var">lookupKnownNatDefs</span></a></span><span>
</span><span id="line-293"></span><span>           </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">tcPluginSolve :: KnownNatDefs -&gt; TcPluginSolver
</span><span class="hs-identifier hs-var">tcPluginSolve</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">KnownNatDefs -&gt; TcPluginSolver
</span><a href="GHC.TypeLits.KnownNat.Solver.html#solveKnownNat"><span class="hs-identifier hs-var">solveKnownNat</span></a></span><span>
</span><span id="line-294"></span><span>           </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">tcPluginRewrite :: KnownNatDefs -&gt; UniqFM TyCon TcPluginRewriter
</span><span class="hs-identifier hs-var">tcPluginRewrite</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">UniqFM TyCon TcPluginRewriter
-&gt; KnownNatDefs -&gt; UniqFM TyCon TcPluginRewriter
forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="annot"><span class="annottext">UniqFM TyCon TcPluginRewriter
forall {k} (key :: k) elt. UniqFM key elt
</span><span class="hs-identifier hs-var">emptyUFM</span></span><span>
</span><span id="line-295"></span><span>           </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">tcPluginStop :: KnownNatDefs -&gt; TcPluginM ()
</span><span class="hs-identifier hs-var">tcPluginStop</span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TcPluginM () -&gt; KnownNatDefs -&gt; TcPluginM ()
forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">() -&gt; TcPluginM ()
forall a. a -&gt; TcPluginM a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-296"></span><span>           </span><span class="hs-special">}</span><span>
</span><span id="line-297"></span><span>
</span><span id="line-298"></span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#solveKnownNat"><span class="hs-identifier hs-type">solveKnownNat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#KnownNatDefs"><span class="hs-identifier hs-type">KnownNatDefs</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">EvBindsVar</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Ct</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Ct</span></span><span class="hs-special">]</span><span>
</span><span id="line-299"></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TcPluginM</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">TcPluginSolveResult</span></span><span>
</span><span id="line-300"></span><span id="solveKnownNat"><span class="annot"><span class="annottext">solveKnownNat :: KnownNatDefs -&gt; TcPluginSolver
</span><a href="GHC.TypeLits.KnownNat.Solver.html#solveKnownNat"><span class="hs-identifier hs-var hs-var">solveKnownNat</span></a></span></span><span> </span><span id="local-6989586621679223860"><span class="annot"><span class="annottext">KnownNatDefs
</span><a href="#local-6989586621679223860"><span class="hs-identifier hs-var">_defs</span></a></span></span><span> </span><span class="annot"><span class="annottext">EvBindsVar
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679223861"><span class="annot"><span class="annottext">[Ct]
</span><a href="#local-6989586621679223861"><span class="hs-identifier hs-var">_givens</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TcPluginSolveResult -&gt; TcPluginM TcPluginSolveResult
forall a. a -&gt; TcPluginM a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[(EvTerm, Ct)] -&gt; [Ct] -&gt; TcPluginSolveResult
</span><span class="hs-identifier hs-var">TcPluginOk</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-301"></span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#solveKnownNat"><span class="hs-identifier hs-var">solveKnownNat</span></a></span><span> </span><span id="local-6989586621679223863"><span class="annot"><span class="annottext">KnownNatDefs
</span><a href="#local-6989586621679223863"><span class="hs-identifier hs-var">defs</span></a></span></span><span>  </span><span class="annot"><span class="annottext">EvBindsVar
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679223864"><span class="annot"><span class="annottext">[Ct]
</span><a href="#local-6989586621679223864"><span class="hs-identifier hs-var">givens</span></a></span></span><span>  </span><span id="local-6989586621679223865"><span class="annot"><span class="annottext">[Ct]
</span><a href="#local-6989586621679223865"><span class="hs-identifier hs-var">wanteds</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-302"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679223866"><span class="annot"><span class="annottext">kn_wanteds :: [(Ct, Class, Type, Orig Type)]
</span><a href="#local-6989586621679223866"><span class="hs-identifier hs-var hs-var">kn_wanteds</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">((Ct, Class, Type, Orig Type) -&gt; (Ct, Class, Type, Orig Type))
-&gt; [(Ct, Class, Type, Orig Type)] -&gt; [(Ct, Class, Type, Orig Type)]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621679223867"><span class="annot"><span class="annottext">Ct
</span><a href="#local-6989586621679223867"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679223868"><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679223868"><span class="hs-identifier hs-var">y</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679223869"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679223869"><span class="hs-identifier hs-var">z</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679223870"><span class="annot"><span class="annottext">Orig Type
</span><a href="#local-6989586621679223870"><span class="hs-identifier hs-var">orig</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Ct
</span><a href="#local-6989586621679223867"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679223868"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679223869"><span class="hs-identifier hs-var">z</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Orig Type
</span><a href="#local-6989586621679223870"><span class="hs-identifier hs-var">orig</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-303"></span><span>                 </span><span class="annot"><span class="annottext">([(Ct, Class, Type, Orig Type)] -&gt; [(Ct, Class, Type, Orig Type)])
-&gt; [(Ct, Class, Type, Orig Type)] -&gt; [(Ct, Class, Type, Orig Type)]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(Ct -&gt; Maybe (Ct, Class, Type, Orig Type))
-&gt; [Ct] -&gt; [(Ct, Class, Type, Orig Type)]
forall a b. (a -&gt; Maybe b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">mapMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">KnownNatDefs -&gt; Ct -&gt; Maybe (Ct, Class, Type, Orig Type)
</span><a href="GHC.TypeLits.KnownNat.Solver.html#toKnConstraint"><span class="hs-identifier hs-var">toKnConstraint</span></a></span><span> </span><span class="annot"><span class="annottext">KnownNatDefs
</span><a href="#local-6989586621679223863"><span class="hs-identifier hs-var">defs</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Ct]
</span><a href="#local-6989586621679223865"><span class="hs-identifier hs-var">wanteds</span></a></span><span>
</span><span id="line-304"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">[(Ct, Class, Type, Orig Type)]
</span><a href="#local-6989586621679223866"><span class="hs-identifier hs-var">kn_wanteds</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-305"></span><span>    </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">TcPluginSolveResult -&gt; TcPluginM TcPluginSolveResult
forall a. a -&gt; TcPluginM a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[(EvTerm, Ct)] -&gt; [Ct] -&gt; TcPluginSolveResult
</span><span class="hs-identifier hs-var">TcPluginOk</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-306"></span><span>    </span><span class="annot"><span class="annottext">[(Ct, Class, Type, Orig Type)]
</span><span class="hs-identifier">_</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-307"></span><span>      </span><span class="hs-comment">-- Make a lookup table for all the [G]iven constraints</span><span>
</span><span id="line-308"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679223872"><span class="annot"><span class="annottext">given_map :: [(CType, EvExpr)]
</span><a href="#local-6989586621679223872"><span class="hs-identifier hs-var hs-var hs-var">given_map</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Ct -&gt; (CType, EvExpr)) -&gt; [Ct] -&gt; [(CType, EvExpr)]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Ct -&gt; (CType, EvExpr)
</span><a href="GHC.TypeLits.KnownNat.Solver.html#toGivenEntry"><span class="hs-identifier hs-var">toGivenEntry</span></a></span><span> </span><span class="annot"><span class="annottext">[Ct]
</span><a href="#local-6989586621679223864"><span class="hs-identifier hs-var">givens</span></a></span><span>
</span><span id="line-309"></span><span>
</span><span id="line-310"></span><span>      </span><span class="hs-comment">-- Try to solve the wanted KnownNat constraints given the [G]iven</span><span>
</span><span id="line-311"></span><span>      </span><span class="hs-comment">-- KnownNat constraints</span><span>
</span><span id="line-312"></span><span>      </span><span class="hs-special">(</span><span id="local-6989586621679223874"><span class="annot"><a href="#local-6989586621679223874"><span class="hs-identifier hs-var">solved</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679223875"><span class="annot"><a href="#local-6989586621679223875"><span class="hs-identifier hs-var">new</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[((EvTerm, Ct), [Ct])] -&gt; ([(EvTerm, Ct)], [[Ct]])
forall a b. [(a, b)] -&gt; ([a], [b])
</span><span class="hs-identifier hs-var">unzip</span></span><span> </span><span class="annot"><span class="annottext">([((EvTerm, Ct), [Ct])] -&gt; ([(EvTerm, Ct)], [[Ct]]))
-&gt; ([Maybe ((EvTerm, Ct), [Ct])] -&gt; [((EvTerm, Ct), [Ct])])
-&gt; [Maybe ((EvTerm, Ct), [Ct])]
-&gt; ([(EvTerm, Ct)], [[Ct]])
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">[Maybe ((EvTerm, Ct), [Ct])] -&gt; [((EvTerm, Ct), [Ct])]
forall a. [Maybe a] -&gt; [a]
</span><span class="hs-identifier hs-var">catMaybes</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">([Maybe ((EvTerm, Ct), [Ct])] -&gt; ([(EvTerm, Ct)], [[Ct]]))
-&gt; TcPluginM [Maybe ((EvTerm, Ct), [Ct])]
-&gt; TcPluginM ([(EvTerm, Ct)], [[Ct]])
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">((Ct, Class, Type, Orig Type)
 -&gt; TcPluginM (Maybe ((EvTerm, Ct), [Ct])))
-&gt; [(Ct, Class, Type, Orig Type)]
-&gt; TcPluginM [Maybe ((EvTerm, Ct), [Ct])]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; [a] -&gt; m [b]
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">KnownNatDefs
-&gt; [(CType, EvExpr)]
-&gt; (Ct, Class, Type, Orig Type)
-&gt; TcPluginM (Maybe ((EvTerm, Ct), [Ct]))
</span><a href="GHC.TypeLits.KnownNat.Solver.html#constraintToEvTerm"><span class="hs-identifier hs-var">constraintToEvTerm</span></a></span><span> </span><span class="annot"><span class="annottext">KnownNatDefs
</span><a href="#local-6989586621679223863"><span class="hs-identifier hs-var">defs</span></a></span><span> </span><span class="annot"><span class="annottext">[(CType, EvExpr)]
</span><a href="#local-6989586621679223872"><span class="hs-identifier hs-var">given_map</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[(Ct, Class, Type, Orig Type)]
</span><a href="#local-6989586621679223866"><span class="hs-identifier hs-var">kn_wanteds</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-313"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">TcPluginOk</span></span><span> </span><span class="annot"><a href="#local-6989586621679223874"><span class="hs-identifier hs-type">solved</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">concat</span></span><span> </span><span class="annot"><a href="#local-6989586621679223875"><span class="hs-identifier hs-type">new</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-314"></span><span>
</span><span id="line-315"></span><span class="annot"><span class="hs-comment">-- | Get the KnownNat constraints</span></span><span>
</span><span id="line-316"></span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#toKnConstraint"><span class="hs-identifier hs-type">toKnConstraint</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#KnownNatDefs"><span class="hs-identifier hs-type">KnownNatDefs</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ct</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#KnConstraint"><span class="hs-identifier hs-type">KnConstraint</span></a></span><span>
</span><span id="line-317"></span><span id="toKnConstraint"><span class="annot"><span class="annottext">toKnConstraint :: KnownNatDefs -&gt; Ct -&gt; Maybe (Ct, Class, Type, Orig Type)
</span><a href="GHC.TypeLits.KnownNat.Solver.html#toKnConstraint"><span class="hs-identifier hs-var hs-var">toKnConstraint</span></a></span></span><span> </span><span id="local-6989586621679223882"><span class="annot"><span class="annottext">KnownNatDefs
</span><a href="#local-6989586621679223882"><span class="hs-identifier hs-var">defs</span></a></span></span><span> </span><span id="local-6989586621679223883"><span class="annot"><span class="annottext">Ct
</span><a href="#local-6989586621679223883"><span class="hs-identifier hs-var">ct</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Pred
</span><span class="hs-identifier hs-var">classifyPredType</span></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Pred) -&gt; Type -&gt; Pred
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; Type
</span><span class="hs-identifier hs-var">ctEvPred</span></span><span> </span><span class="annot"><span class="annottext">(CtEvidence -&gt; Type) -&gt; CtEvidence -&gt; Type
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Ct -&gt; CtEvidence
</span><span class="hs-identifier hs-var">ctEvidence</span></span><span> </span><span class="annot"><span class="annottext">Ct
</span><a href="#local-6989586621679223883"><span class="hs-identifier hs-var">ct</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-318"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">ClassPred</span></span><span> </span><span id="local-6989586621679223884"><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679223884"><span class="hs-identifier hs-var">cls</span></a></span></span><span> </span><span class="hs-special">[</span><span id="local-6989586621679223885"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679223885"><span class="hs-identifier hs-var">ty</span></a></span></span><span class="hs-special">]</span><span>
</span><span id="line-319"></span><span>    </span><span class="hs-glyph">|</span><span>  </span><span class="annot"><span class="annottext">Class -&gt; Name
</span><span class="hs-identifier hs-var">className</span></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679223884"><span class="hs-identifier hs-var">cls</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><span class="hs-identifier hs-var">knownNatClassName</span></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">||</span></span><span>
</span><span id="line-320"></span><span>       </span><span class="annot"><span class="annottext">Class -&gt; Name
</span><span class="hs-identifier hs-var">className</span></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679223884"><span class="hs-identifier hs-var">cls</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Class -&gt; Name
</span><span class="hs-identifier hs-var">className</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">KnownNatDefs -&gt; Class
</span><a href="GHC.TypeLits.KnownNat.Solver.html#knownBool"><span class="hs-identifier hs-var">knownBool</span></a></span><span> </span><span class="annot"><span class="annottext">KnownNatDefs
</span><a href="#local-6989586621679223882"><span class="hs-identifier hs-var">defs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-321"></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Ct, Class, Type, Orig Type) -&gt; Maybe (Ct, Class, Type, Orig Type)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Ct
</span><a href="#local-6989586621679223883"><span class="hs-identifier hs-var">ct</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679223884"><span class="hs-identifier hs-var">cls</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679223885"><span class="hs-identifier hs-var">ty</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Type -&gt; Orig Type
forall a. a -&gt; Orig a
</span><a href="GHC.TypeLits.KnownNat.Solver.html#Orig"><span class="hs-identifier hs-var">Orig</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679223885"><span class="hs-identifier hs-var">ty</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-322"></span><span>  </span><span class="annot"><span class="annottext">Pred
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe (Ct, Class, Type, Orig Type)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-323"></span><span>
</span><span id="line-324"></span><span class="annot"><span class="hs-comment">-- | Create a look-up entry for a [G]iven constraint.</span></span><span>
</span><span id="line-325"></span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#toGivenEntry"><span class="hs-identifier hs-type">toGivenEntry</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ct</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">CType</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">EvExpr</span></span><span class="hs-special">)</span><span>
</span><span id="line-326"></span><span id="toGivenEntry"><span class="annot"><span class="annottext">toGivenEntry :: Ct -&gt; (CType, EvExpr)
</span><a href="GHC.TypeLits.KnownNat.Solver.html#toGivenEntry"><span class="hs-identifier hs-var hs-var">toGivenEntry</span></a></span></span><span> </span><span id="local-6989586621679223887"><span class="annot"><span class="annottext">Ct
</span><a href="#local-6989586621679223887"><span class="hs-identifier hs-var">ct</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679223888"><span class="annot"><span class="annottext">ct_ev :: CtEvidence
</span><a href="#local-6989586621679223888"><span class="hs-identifier hs-var hs-var">ct_ev</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Ct -&gt; CtEvidence
</span><span class="hs-identifier hs-var">ctEvidence</span></span><span> </span><span class="annot"><span class="annottext">Ct
</span><a href="#local-6989586621679223887"><span class="hs-identifier hs-var">ct</span></a></span><span>
</span><span id="line-327"></span><span>                      </span><span id="local-6989586621679223889"><span class="annot"><span class="annottext">c_ty :: Type
</span><a href="#local-6989586621679223889"><span class="hs-identifier hs-var hs-var">c_ty</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; Type
</span><span class="hs-identifier hs-var">ctEvPred</span></span><span>   </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621679223888"><span class="hs-identifier hs-var">ct_ev</span></a></span><span>
</span><span id="line-328"></span><span>                      </span><span id="local-6989586621679223891"><span class="annot"><span class="annottext">ev :: EvExpr
</span><a href="#local-6989586621679223891"><span class="hs-identifier hs-var hs-var">ev</span></a></span></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">HasDebugCallStack =&gt; CtEvidence -&gt; EvExpr
CtEvidence -&gt; EvExpr
</span><span class="hs-identifier hs-var">ctEvExpr</span></span><span>   </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621679223888"><span class="hs-identifier hs-var">ct_ev</span></a></span><span>
</span><span id="line-329"></span><span>                  </span><span class="hs-keyword">in</span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; CType
</span><span class="hs-identifier hs-var">CType</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679223889"><span class="hs-identifier hs-var">c_ty</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">EvExpr
</span><a href="#local-6989586621679223891"><span class="hs-identifier hs-var">ev</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-330"></span><span>
</span><span id="line-331"></span><span class="annot"><span class="hs-comment">-- | Find the \&quot;magic\&quot; classes and instances in &quot;GHC.TypeLits.KnownNat&quot;</span></span><span>
</span><span id="line-332"></span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#lookupKnownNatDefs"><span class="hs-identifier hs-type">lookupKnownNatDefs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TcPluginM</span></span><span> </span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#KnownNatDefs"><span class="hs-identifier hs-type">KnownNatDefs</span></a></span><span>
</span><span id="line-333"></span><span id="lookupKnownNatDefs"><span class="annot"><span class="annottext">lookupKnownNatDefs :: TcPluginM KnownNatDefs
</span><a href="GHC.TypeLits.KnownNat.Solver.html#lookupKnownNatDefs"><span class="hs-identifier hs-var hs-var">lookupKnownNatDefs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-334"></span><span>    </span><span id="local-6989586621679223893"><span class="annot"><a href="#local-6989586621679223893"><span class="hs-identifier hs-var">kbC</span></a></span></span><span>    </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Name -&gt; TcPluginM Class
</span><a href="#local-6989586621679223894"><span class="hs-identifier hs-var">look</span></a></span><span> </span><span class="hs-special">''</span><span class="hs-identifier">KnownBool</span><span>
</span><span id="line-335"></span><span>    </span><span id="local-6989586621679223895"><span class="annot"><a href="#local-6989586621679223895"><span class="hs-identifier hs-var">kbn2C</span></a></span></span><span>  </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="#local-6989586621679223894"><span class="hs-identifier hs-type">look</span></a></span><span> </span><span class="hs-special">''</span><span class="hs-identifier">KnownBoolNat2</span><span>
</span><span id="line-336"></span><span>    </span><span id="local-6989586621679223896"><span class="annot"><a href="#local-6989586621679223896"><span class="hs-identifier hs-var">kn2bC</span></a></span></span><span>  </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="#local-6989586621679223894"><span class="hs-identifier hs-type">look</span></a></span><span> </span><span class="hs-special">''</span><span class="hs-identifier">KnownNat2Bool</span><span>
</span><span id="line-337"></span><span>    </span><span id="local-6989586621679223897"><span class="annot"><a href="#local-6989586621679223897"><span class="hs-identifier hs-var">kn1C</span></a></span></span><span>   </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="#local-6989586621679223894"><span class="hs-identifier hs-type">look</span></a></span><span> </span><span class="hs-special">''</span><span class="hs-identifier">KnownNat1</span><span>
</span><span id="line-338"></span><span>    </span><span id="local-6989586621679223898"><span class="annot"><a href="#local-6989586621679223898"><span class="hs-identifier hs-var">kn2C</span></a></span></span><span>   </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="#local-6989586621679223894"><span class="hs-identifier hs-type">look</span></a></span><span> </span><span class="hs-special">''</span><span class="hs-identifier">KnownNat2</span><span>
</span><span id="line-339"></span><span>    </span><span id="local-6989586621679223899"><span class="annot"><a href="#local-6989586621679223899"><span class="hs-identifier hs-var">kn3C</span></a></span></span><span>   </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="#local-6989586621679223894"><span class="hs-identifier hs-type">look</span></a></span><span> </span><span class="hs-special">''</span><span class="hs-identifier">KnownNat3</span><span>
</span><span id="line-340"></span><span>    </span><span id="local-6989586621679223900"><span class="annot"><a href="#local-6989586621679223900"><span class="hs-identifier hs-var">ordcond</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#lookupTHName"><span class="hs-identifier hs-type">lookupTHName</span></a></span><span> </span><span class="hs-special">''</span><span class="hs-identifier">OrdCond</span><span> </span><span class="annot"><span class="hs-operator hs-type">&gt;&gt;=</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">tcLookupTyCon</span></span><span>
</span><span id="line-341"></span><span>    </span><span id="local-6989586621679223902"><span class="annot"><a href="#local-6989586621679223902"><span class="hs-identifier hs-var">ifTc</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#lookupTHName"><span class="hs-identifier hs-type">lookupTHName</span></a></span><span> </span><span class="hs-special">''</span><span class="hs-identifier">If</span><span> </span><span class="annot"><span class="hs-operator hs-type">&gt;&gt;=</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">tcLookupTyCon</span></span><span>
</span><span id="line-342"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#KnownNatDefs"><span class="hs-identifier hs-type">KnownNatDefs</span></a></span><span>
</span><span id="line-343"></span><span>           </span><span class="hs-special">{</span><span> </span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#knownBool"><span class="hs-identifier hs-var">knownBool</span></a></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621679223893"><span class="hs-identifier hs-type">kbC</span></a></span><span>
</span><span id="line-344"></span><span>           </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#knownBoolNat2"><span class="hs-identifier hs-var">knownBoolNat2</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621679223895"><span class="hs-identifier hs-type">kbn2C</span></a></span><span>
</span><span id="line-345"></span><span>           </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#knownNat2Bool"><span class="hs-identifier hs-var">knownNat2Bool</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621679223896"><span class="hs-identifier hs-type">kn2bC</span></a></span><span>
</span><span id="line-346"></span><span>           </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#knownNatN"><span class="hs-identifier hs-var">knownNatN</span></a></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Class -&gt; Maybe Class
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679223897"><span class="hs-identifier hs-var">kn1C</span></a></span><span>
</span><span id="line-347"></span><span>                                   </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">2</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Class -&gt; Maybe Class
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679223898"><span class="hs-identifier hs-var">kn2C</span></a></span><span>
</span><span id="line-348"></span><span>                                   </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">3</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Class -&gt; Maybe Class
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679223899"><span class="hs-identifier hs-var">kn3C</span></a></span><span>
</span><span id="line-349"></span><span>                                   </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe Class
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-350"></span><span>                                   </span><span class="hs-special">}</span><span>
</span><span id="line-351"></span><span>           </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#ordCondTyCon"><span class="hs-identifier hs-var">ordCondTyCon</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621679223900"><span class="hs-identifier hs-type">ordcond</span></a></span><span>
</span><span id="line-352"></span><span>           </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#ifTyCon"><span class="hs-identifier hs-var">ifTyCon</span></a></span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621679223902"><span class="hs-identifier hs-type">ifTc</span></a></span><span>
</span><span id="line-353"></span><span>           </span><span class="hs-special">}</span><span>
</span><span id="line-354"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-355"></span><span>    </span><span id="local-6989586621679223894"><span class="annot"><span class="annottext">look :: Name -&gt; TcPluginM Class
</span><a href="#local-6989586621679223894"><span class="hs-identifier hs-var hs-var">look</span></a></span></span><span> </span><span id="local-6989586621679223904"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679223904"><span class="hs-identifier hs-var">nm</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; TcPluginM Name
</span><a href="GHC.TypeLits.KnownNat.Solver.html#lookupTHName"><span class="hs-identifier hs-var">lookupTHName</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679223904"><span class="hs-identifier hs-var">nm</span></a></span><span> </span><span class="annot"><span class="annottext">TcPluginM Name -&gt; (Name -&gt; TcPluginM Class) -&gt; TcPluginM Class
forall a b. TcPluginM a -&gt; (a -&gt; TcPluginM b) -&gt; TcPluginM b
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; TcPluginM Class
</span><span class="hs-identifier hs-var">tcLookupClass</span></span><span>
</span><span id="line-356"></span><span>
</span><span id="line-357"></span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#lookupTHName"><span class="hs-identifier hs-type">lookupTHName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TH.Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TcPluginM</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>
</span><span id="line-358"></span><span id="lookupTHName"><span class="annot"><span class="annottext">lookupTHName :: Name -&gt; TcPluginM Name
</span><a href="GHC.TypeLits.KnownNat.Solver.html#lookupTHName"><span class="hs-identifier hs-var hs-var">lookupTHName</span></a></span></span><span> </span><span id="local-6989586621679223905"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679223905"><span class="hs-identifier hs-var">th</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-359"></span><span>    </span><span id="local-6989586621679223906"><span class="annot"><a href="#local-6989586621679223906"><span class="hs-identifier hs-var">nc</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">TcM NameCache -&gt; TcPluginM NameCache
forall a. TcM a -&gt; TcPluginM a
</span><span class="hs-identifier hs-var">unsafeTcPluginTcM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">HscEnv -&gt; NameCache
</span><span class="hs-identifier hs-var">hsc_NC</span></span><span> </span><span class="annot"><span class="annottext">(HscEnv -&gt; NameCache)
-&gt; (Env TcGblEnv TcLclEnv -&gt; HscEnv)
-&gt; Env TcGblEnv TcLclEnv
-&gt; NameCache
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Env TcGblEnv TcLclEnv -&gt; HscEnv
forall gbl lcl. Env gbl lcl -&gt; HscEnv
</span><span class="hs-identifier hs-var">env_top</span></span><span> </span><span class="annot"><span class="annottext">(Env TcGblEnv TcLclEnv -&gt; NameCache)
-&gt; IOEnv (Env TcGblEnv TcLclEnv) (Env TcGblEnv TcLclEnv)
-&gt; TcM NameCache
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">IOEnv (Env TcGblEnv TcLclEnv) (Env TcGblEnv TcLclEnv)
forall env. IOEnv env env
</span><span class="hs-identifier hs-var">getEnv</span></span><span class="hs-special">)</span><span>
</span><span id="line-360"></span><span>    </span><span id="local-6989586621679223907"><span class="annot"><a href="#local-6989586621679223907"><span class="hs-identifier hs-var">res</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="hs-identifier hs-type">tcPluginIO</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">thNameToGhcNameIO</span></span><span> </span><span class="annot"><a href="#local-6989586621679223906"><span class="hs-identifier hs-type">nc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679223905"><span class="hs-identifier hs-type">th</span></a></span><span>
</span><span id="line-361"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">fail</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="annot"><span class="hs-string">&quot;Failed to lookup &quot;</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">++</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">show</span></span><span> </span><span class="annot"><a href="#local-6989586621679223905"><span class="hs-identifier hs-type">th</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="annot"><a href="#local-6989586621679223907"><span class="hs-identifier hs-type">res</span></a></span><span>
</span><span id="line-362"></span><span>
</span><span id="line-363"></span><span class="annot"><span class="hs-comment">-- | Try to create evidence for a wanted constraint</span></span><span>
</span><span id="line-364"></span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#constraintToEvTerm"><span class="hs-identifier hs-type">constraintToEvTerm</span></a></span><span>
</span><span id="line-365"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#KnownNatDefs"><span class="hs-identifier hs-type">KnownNatDefs</span></a></span><span>
</span><span id="line-366"></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ The &quot;magic&quot; KnownNatN classes</span></span><span>
</span><span id="line-367"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">CType</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">EvExpr</span></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-368"></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ All the [G]iven constraints</span></span><span>
</span><span id="line-369"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#KnConstraint"><span class="hs-identifier hs-type">KnConstraint</span></a></span><span>
</span><span id="line-370"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TcPluginM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">EvTerm</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Ct</span></span><span class="hs-special">)</span><span class="hs-special">,</span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Ct</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-371"></span><span id="constraintToEvTerm"><span class="annot"><span class="annottext">constraintToEvTerm :: KnownNatDefs
-&gt; [(CType, EvExpr)]
-&gt; (Ct, Class, Type, Orig Type)
-&gt; TcPluginM (Maybe ((EvTerm, Ct), [Ct]))
</span><a href="GHC.TypeLits.KnownNat.Solver.html#constraintToEvTerm"><span class="hs-identifier hs-var hs-var">constraintToEvTerm</span></a></span></span><span> </span><span id="local-6989586621679223910"><span class="annot"><span class="annottext">KnownNatDefs
</span><a href="#local-6989586621679223910"><span class="hs-identifier hs-var">defs</span></a></span></span><span> </span><span id="local-6989586621679223911"><span class="annot"><span class="annottext">[(CType, EvExpr)]
</span><a href="#local-6989586621679223911"><span class="hs-identifier hs-var">givens</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679223912"><span class="annot"><span class="annottext">Ct
</span><a href="#local-6989586621679223912"><span class="hs-identifier hs-var">ct</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679223913"><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679223913"><span class="hs-identifier hs-var">cls</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679223914"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679223914"><span class="hs-identifier hs-var">op</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679223915"><span class="annot"><span class="annottext">Orig Type
</span><a href="#local-6989586621679223915"><span class="hs-identifier hs-var">orig</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-372"></span><span>    </span><span class="hs-comment">-- 1. Determine if we are an offset apart from a [G]iven constraint</span><span>
</span><span id="line-373"></span><span>    </span><span id="local-6989586621679223916"><span class="annot"><a href="#local-6989586621679223916"><span class="hs-identifier hs-var">offsetM</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; TcPluginM (Maybe (EvTerm, [Ct]))
</span><a href="#local-6989586621679223917"><span class="hs-identifier hs-var">offset</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679223914"><span class="hs-identifier hs-var">op</span></a></span><span>
</span><span id="line-374"></span><span>    </span><span id="local-6989586621679223918"><span class="annot"><a href="#local-6989586621679223918"><span class="hs-identifier hs-var">evM</span></a></span></span><span>     </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><a href="#local-6989586621679223916"><span class="hs-identifier hs-type">offsetM</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-375"></span><span>                 </span><span class="hs-comment">-- 3.a If so, we are done</span><span>
</span><span id="line-376"></span><span>                 </span><span id="local-6989586621679223919"><span class="annot"><span class="annottext">found :: Maybe (EvTerm, [Ct])
</span><a href="#local-6989586621679223919"><span class="hs-identifier hs-var">found</span></a></span></span><span class="hs-glyph">@</span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe (EvTerm, [Ct]) -&gt; TcPluginM (Maybe (EvTerm, [Ct]))
forall a. a -&gt; TcPluginM a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Maybe (EvTerm, [Ct])
</span><a href="#local-6989586621679223919"><span class="hs-identifier hs-var">found</span></a></span><span>
</span><span id="line-377"></span><span>                 </span><span class="hs-comment">-- 3.b If not, we check if the outer type-level operation</span><span>
</span><span id="line-378"></span><span>                 </span><span class="hs-comment">-- has a corresponding KnownNat&lt;N&gt; instance.</span><span>
</span><span id="line-379"></span><span>                 </span><span class="annot"><span class="annottext">Maybe (EvTerm, [Ct])
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Type, Maybe Coercion) -&gt; TcPluginM (Maybe (EvTerm, [Ct]))
</span><a href="#local-6989586621679223920"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679223914"><span class="hs-identifier hs-var">op</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Maybe Coercion
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">)</span><span>
</span><span id="line-380"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">first</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">,</span><span class="annot"><a href="#local-6989586621679223912"><span class="hs-identifier hs-type">ct</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-operator hs-type">&lt;$&gt;</span></span><span> </span><span class="annot"><a href="#local-6989586621679223918"><span class="hs-identifier hs-type">evM</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-381"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-382"></span><span>    </span><span class="hs-comment">-- Determine whether the outer type-level operation has a corresponding</span><span>
</span><span id="line-383"></span><span>    </span><span class="hs-comment">-- KnownNat&lt;N&gt; instance, where /N/ corresponds to the arity of the</span><span>
</span><span id="line-384"></span><span>    </span><span class="hs-comment">-- type-level operation</span><span>
</span><span id="line-385"></span><span>    </span><span class="annot"><a href="#local-6989586621679223920"><span class="hs-identifier hs-type">go</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Coercion</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TcPluginM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">EvTerm</span></span><span class="hs-special">,</span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Ct</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-386"></span><span>    </span><span id="local-6989586621679223920"><span class="annot"><span class="annottext">go :: (Type, Maybe Coercion) -&gt; TcPluginM (Maybe (EvTerm, [Ct]))
</span><a href="#local-6989586621679223920"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Maybe EvTerm
</span><a href="#local-6989586621679223921"><span class="hs-identifier hs-var">go_other</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679223922"><span class="annot"><span class="annottext">EvTerm
</span><a href="#local-6989586621679223922"><span class="hs-identifier hs-var">ev</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Maybe Coercion
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe (EvTerm, [Ct]) -&gt; TcPluginM (Maybe (EvTerm, [Ct]))
forall a. a -&gt; TcPluginM a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(EvTerm, [Ct]) -&gt; Maybe (EvTerm, [Ct])
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">EvTerm
</span><a href="#local-6989586621679223922"><span class="hs-identifier hs-var">ev</span></a></span><span class="hs-special">,</span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-387"></span><span>    </span><span class="annot"><a href="#local-6989586621679223920"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679223923"><span class="annot"><span class="annottext">ty :: Type
</span><a href="#local-6989586621679223923"><span class="hs-identifier hs-var">ty</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">TyConApp</span></span><span> </span><span id="local-6989586621679223925"><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621679223925"><span class="hs-identifier hs-var">tc</span></a></span></span><span> </span><span id="local-6989586621679223926"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679223926"><span class="hs-identifier hs-var">args0</span></a></span></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span id="local-6989586621679223927"><span class="annot"><span class="annottext">Maybe Coercion
</span><a href="#local-6989586621679223927"><span class="hs-identifier hs-var">sM</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-388"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679223928"><span class="annot"><span class="annottext">tcNm :: Name
</span><a href="#local-6989586621679223928"><span class="hs-identifier hs-var hs-var">tcNm</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TyCon -&gt; Name
</span><span class="hs-identifier hs-var">tyConName</span></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621679223925"><span class="hs-identifier hs-var">tc</span></a></span><span>
</span><span id="line-389"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679223929"><span class="annot"><span class="annottext">Module
</span><a href="#local-6989586621679223929"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Maybe Module
</span><span class="hs-identifier hs-var">nameModule_maybe</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679223928"><span class="hs-identifier hs-var">tcNm</span></a></span><span>
</span><span id="line-390"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-391"></span><span>        </span><span id="local-6989586621679223930"><span class="annot"><a href="#local-6989586621679223930"><span class="hs-identifier hs-var">ienv</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">TcPluginM InstEnvs
</span><span class="hs-identifier hs-var">getInstEnvs</span></span><span>
</span><span id="line-392"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679223931"><span class="annot"><a href="#local-6989586621679223931"><span class="hs-identifier hs-var hs-var">mS</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ModuleName -&gt; CommandLineOption
</span><span class="hs-identifier hs-var">moduleNameString</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Module -&gt; ModuleName
forall unit. GenModule unit -&gt; ModuleName
</span><span class="hs-identifier hs-var">moduleName</span></span><span> </span><span class="annot"><span class="annottext">Module
</span><a href="#local-6989586621679223929"><span class="hs-identifier hs-var">m</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-393"></span><span>            </span><span id="local-6989586621679223932"><span class="annot"><a href="#local-6989586621679223932"><span class="hs-identifier hs-var hs-var">tcS</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">OccName -&gt; CommandLineOption
</span><span class="hs-identifier hs-var">occNameString</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; OccName
</span><span class="hs-identifier hs-var">nameOccName</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679223928"><span class="hs-identifier hs-var">tcNm</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-394"></span><span>            </span><span id="local-6989586621679223933"><span class="annot"><a href="#local-6989586621679223933"><span class="hs-identifier hs-var hs-var">fn0</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CommandLineOption
</span><a href="#local-6989586621679223931"><span class="hs-identifier hs-var">mS</span></a></span><span> </span><span class="annot"><span class="annottext">CommandLineOption -&gt; CommandLineOption -&gt; CommandLineOption
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">CommandLineOption
</span><span class="hs-string">&quot;.&quot;</span></span><span> </span><span class="annot"><span class="annottext">CommandLineOption -&gt; CommandLineOption -&gt; CommandLineOption
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">CommandLineOption
</span><a href="#local-6989586621679223932"><span class="hs-identifier hs-var">tcS</span></a></span><span>
</span><span id="line-395"></span><span>            </span><span id="local-6989586621679223934"><span class="annot"><a href="#local-6989586621679223934"><span class="hs-identifier hs-var hs-var">fn1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FastString -&gt; Type
</span><span class="hs-identifier hs-var">mkStrLitTy</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CommandLineOption -&gt; FastString
</span><span class="hs-identifier hs-var">fsLit</span></span><span> </span><span class="annot"><span class="annottext">CommandLineOption
</span><a href="#local-6989586621679223933"><span class="hs-identifier hs-var">fn0</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-396"></span><span>            </span><span id="local-6989586621679223935"><span class="annot"><a href="#local-6989586621679223935"><span class="hs-identifier hs-var hs-var">args1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679223934"><span class="hs-identifier hs-var">fn1</span></a></span><span class="annot"><span class="annottext">Type -&gt; [Type] -&gt; [Type]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679223926"><span class="hs-identifier hs-var">args0</span></a></span><span>
</span><span id="line-397"></span><span>            </span><span id="local-6989586621679223947"><span class="annot"><a href="#local-6989586621679223947"><span class="hs-identifier hs-var hs-var">instM</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-398"></span><span>              </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679223948"><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679223948"><span class="hs-identifier hs-var">knN_cls</span></a></span></span><span>    </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">KnownNatDefs -&gt; Int -&gt; Maybe Class
</span><a href="GHC.TypeLits.KnownNat.Solver.html#knownNatN"><span class="hs-identifier hs-var">knownNatN</span></a></span><span> </span><span class="annot"><span class="annottext">KnownNatDefs
</span><a href="#local-6989586621679223910"><span class="hs-identifier hs-var">defs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Type] -&gt; Int
forall a. [a] -&gt; Int
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679223926"><span class="hs-identifier hs-var">args0</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-399"></span><span>                 </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Right</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679223950"><span class="annot"><span class="annottext">ClsInst
</span><a href="#local-6989586621679223950"><span class="hs-identifier hs-var">inst</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">InstEnvs
-&gt; Class
-&gt; [Type]
-&gt; Either LookupInstanceErrReason (ClsInst, [Type])
</span><span class="hs-identifier hs-var">lookupUniqueInstEnv</span></span><span> </span><span class="annot"><span class="annottext">InstEnvs
</span><a href="#local-6989586621679223930"><span class="hs-identifier hs-var">ienv</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679223948"><span class="hs-identifier hs-var">knN_cls</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679223935"><span class="hs-identifier hs-var">args1</span></a></span><span>
</span><span id="line-400"></span><span>                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(ClsInst, Class, [Type], [Type])
-&gt; Maybe (ClsInst, Class, [Type], [Type])
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ClsInst
</span><a href="#local-6989586621679223950"><span class="hs-identifier hs-var">inst</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679223948"><span class="hs-identifier hs-var">knN_cls</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679223926"><span class="hs-identifier hs-var">args0</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679223935"><span class="hs-identifier hs-var">args1</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-401"></span><span>                 </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621679223925"><span class="hs-identifier hs-var">tc</span></a></span><span> </span><span class="annot"><span class="annottext">TyCon -&gt; TyCon -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">KnownNatDefs -&gt; TyCon
</span><a href="GHC.TypeLits.KnownNat.Solver.html#ordCondTyCon"><span class="hs-identifier hs-var">ordCondTyCon</span></a></span><span> </span><span class="annot"><span class="annottext">KnownNatDefs
</span><a href="#local-6989586621679223910"><span class="hs-identifier hs-var">defs</span></a></span><span>
</span><span id="line-402"></span><span>                 </span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span id="local-6989586621679223951"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679223951"><span class="hs-identifier hs-var">cmpNat</span></a></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">TyConApp</span></span><span> </span><span id="local-6989586621679223952"><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621679223952"><span class="hs-identifier hs-var">t1</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">TyConApp</span></span><span> </span><span id="local-6989586621679223953"><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621679223953"><span class="hs-identifier hs-var">t2</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">TyConApp</span></span><span> </span><span id="local-6989586621679223954"><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621679223954"><span class="hs-identifier hs-var">f1</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679223926"><span class="hs-identifier hs-var">args0</span></a></span><span>
</span><span id="line-403"></span><span>                 </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TyConApp</span></span><span> </span><span id="local-6989586621679223955"><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621679223955"><span class="hs-identifier hs-var">cmpNatTc</span></a></span></span><span> </span><span id="local-6989586621679223956"><span class="annot"><span class="annottext">args2 :: [Type]
</span><a href="#local-6989586621679223956"><span class="hs-identifier hs-var">args2</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span id="local-6989586621679223957"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679223957"><span class="hs-identifier hs-var">arg2</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span class="annot"><span class="annottext">[Type]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679223951"><span class="hs-identifier hs-var">cmpNat</span></a></span><span>
</span><span id="line-404"></span><span>                 </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621679223955"><span class="hs-identifier hs-var">cmpNatTc</span></a></span><span> </span><span class="annot"><span class="annottext">TyCon -&gt; TyCon -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><span class="hs-identifier hs-var">typeNatCmpTyCon</span></span><span>
</span><span id="line-405"></span><span>                 </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621679223952"><span class="hs-identifier hs-var">t1</span></a></span><span> </span><span class="annot"><span class="annottext">TyCon -&gt; TyCon -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><span class="hs-identifier hs-var">promotedTrueDataCon</span></span><span>
</span><span id="line-406"></span><span>                 </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621679223953"><span class="hs-identifier hs-var">t2</span></a></span><span> </span><span class="annot"><span class="annottext">TyCon -&gt; TyCon -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><span class="hs-identifier hs-var">promotedTrueDataCon</span></span><span>
</span><span id="line-407"></span><span>                 </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621679223954"><span class="hs-identifier hs-var">f1</span></a></span><span> </span><span class="annot"><span class="annottext">TyCon -&gt; TyCon -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><span class="hs-identifier hs-var">promotedFalseDataCon</span></span><span>
</span><span id="line-408"></span><span>                 </span><span class="hs-special">,</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679223958"><span class="annot"><span class="annottext">knN_cls :: Class
</span><a href="#local-6989586621679223958"><span class="hs-identifier hs-var hs-var">knN_cls</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">KnownNatDefs -&gt; Class
</span><a href="GHC.TypeLits.KnownNat.Solver.html#knownBoolNat2"><span class="hs-identifier hs-var">knownBoolNat2</span></a></span><span> </span><span class="annot"><span class="annottext">KnownNatDefs
</span><a href="#local-6989586621679223910"><span class="hs-identifier hs-var">defs</span></a></span><span>
</span><span id="line-409"></span><span>                       </span><span id="local-6989586621679223960"><span class="annot"><span class="annottext">ki :: Type
</span><a href="#local-6989586621679223960"><span class="hs-identifier hs-var hs-var">ki</span></a></span></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">HasDebugCallStack =&gt; Type -&gt; Type
Type -&gt; Type
</span><span class="hs-identifier hs-var">typeKind</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679223957"><span class="hs-identifier hs-var">arg2</span></a></span><span>
</span><span id="line-410"></span><span>                       </span><span id="local-6989586621679223961"><span class="annot"><span class="annottext">args1N :: [Type]
</span><a href="#local-6989586621679223961"><span class="hs-identifier hs-var hs-var">args1N</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679223960"><span class="hs-identifier hs-var">ki</span></a></span><span class="annot"><span class="annottext">Type -&gt; [Type] -&gt; [Type]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679223934"><span class="hs-identifier hs-var">fn1</span></a></span><span class="annot"><span class="annottext">Type -&gt; [Type] -&gt; [Type]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679223956"><span class="hs-identifier hs-var">args2</span></a></span><span>
</span><span id="line-411"></span><span>                 </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Right</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679223962"><span class="annot"><span class="annottext">ClsInst
</span><a href="#local-6989586621679223962"><span class="hs-identifier hs-var">inst</span></a></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">[Type]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">InstEnvs
-&gt; Class
-&gt; [Type]
-&gt; Either LookupInstanceErrReason (ClsInst, [Type])
</span><span class="hs-identifier hs-var">lookupUniqueInstEnv</span></span><span> </span><span class="annot"><span class="annottext">InstEnvs
</span><a href="#local-6989586621679223930"><span class="hs-identifier hs-var">ienv</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679223958"><span class="hs-identifier hs-var">knN_cls</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679223961"><span class="hs-identifier hs-var">args1N</span></a></span><span>
</span><span id="line-412"></span><span>                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(ClsInst, Class, [Type], [Type])
-&gt; Maybe (ClsInst, Class, [Type], [Type])
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ClsInst
</span><a href="#local-6989586621679223962"><span class="hs-identifier hs-var">inst</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679223958"><span class="hs-identifier hs-var">knN_cls</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679223956"><span class="hs-identifier hs-var">args2</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679223961"><span class="hs-identifier hs-var">args1N</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-413"></span><span>                 </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">[</span><span id="local-6989586621679223963"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679223963"><span class="hs-identifier hs-var">arg0</span></a></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679223926"><span class="hs-identifier hs-var">args0</span></a></span><span>
</span><span id="line-414"></span><span>                 </span><span class="hs-special">,</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679223964"><span class="annot"><span class="annottext">knN_cls :: Class
</span><a href="#local-6989586621679223964"><span class="hs-identifier hs-var hs-var">knN_cls</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">KnownNatDefs -&gt; Class
</span><a href="GHC.TypeLits.KnownNat.Solver.html#knownBoolNat2"><span class="hs-identifier hs-var">knownBoolNat2</span></a></span><span> </span><span class="annot"><span class="annottext">KnownNatDefs
</span><a href="#local-6989586621679223910"><span class="hs-identifier hs-var">defs</span></a></span><span>
</span><span id="line-415"></span><span>                       </span><span id="local-6989586621679223966"><span class="annot"><span class="annottext">ki :: Type
</span><a href="#local-6989586621679223966"><span class="hs-identifier hs-var hs-var">ki</span></a></span></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">HasDebugCallStack =&gt; Type -&gt; Type
Type -&gt; Type
</span><span class="hs-identifier hs-var">typeKind</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679223963"><span class="hs-identifier hs-var">arg0</span></a></span><span>
</span><span id="line-416"></span><span>                       </span><span id="local-6989586621679223967"><span class="annot"><span class="annottext">args1N :: [Type]
</span><a href="#local-6989586621679223967"><span class="hs-identifier hs-var hs-var">args1N</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679223966"><span class="hs-identifier hs-var">ki</span></a></span><span class="annot"><span class="annottext">Type -&gt; [Type] -&gt; [Type]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679223935"><span class="hs-identifier hs-var">args1</span></a></span><span>
</span><span id="line-417"></span><span>                 </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Right</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679223968"><span class="annot"><span class="annottext">ClsInst
</span><a href="#local-6989586621679223968"><span class="hs-identifier hs-var">inst</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">InstEnvs
-&gt; Class
-&gt; [Type]
-&gt; Either LookupInstanceErrReason (ClsInst, [Type])
</span><span class="hs-identifier hs-var">lookupUniqueInstEnv</span></span><span> </span><span class="annot"><span class="annottext">InstEnvs
</span><a href="#local-6989586621679223930"><span class="hs-identifier hs-var">ienv</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679223964"><span class="hs-identifier hs-var">knN_cls</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679223967"><span class="hs-identifier hs-var">args1N</span></a></span><span>
</span><span id="line-418"></span><span>                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(ClsInst, Class, [Type], [Type])
-&gt; Maybe (ClsInst, Class, [Type], [Type])
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ClsInst
</span><a href="#local-6989586621679223968"><span class="hs-identifier hs-var">inst</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679223964"><span class="hs-identifier hs-var">knN_cls</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679223926"><span class="hs-identifier hs-var">args0</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679223967"><span class="hs-identifier hs-var">args1N</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-419"></span><span>                 </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679223969"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679223969"><span class="hs-identifier hs-var">arg0</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621679223970"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679223970"><span class="hs-identifier hs-var">args0Rest</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679223926"><span class="hs-identifier hs-var">args0</span></a></span><span>
</span><span id="line-420"></span><span>                 </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; Int
forall a. [a] -&gt; Int
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679223970"><span class="hs-identifier hs-var">args0Rest</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">3</span></span><span>
</span><span id="line-421"></span><span>                 </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621679223925"><span class="hs-identifier hs-var">tc</span></a></span><span> </span><span class="annot"><span class="annottext">TyCon -&gt; TyCon -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">KnownNatDefs -&gt; TyCon
</span><a href="GHC.TypeLits.KnownNat.Solver.html#ifTyCon"><span class="hs-identifier hs-var">ifTyCon</span></a></span><span> </span><span class="annot"><span class="annottext">KnownNatDefs
</span><a href="#local-6989586621679223910"><span class="hs-identifier hs-var">defs</span></a></span><span>
</span><span id="line-422"></span><span>                 </span><span class="hs-special">,</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679223971"><span class="annot"><span class="annottext">args1N :: [Type]
</span><a href="#local-6989586621679223971"><span class="hs-identifier hs-var hs-var">args1N</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679223969"><span class="hs-identifier hs-var">arg0</span></a></span><span class="annot"><span class="annottext">Type -&gt; [Type] -&gt; [Type]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679223934"><span class="hs-identifier hs-var">fn1</span></a></span><span class="annot"><span class="annottext">Type -&gt; [Type] -&gt; [Type]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679223970"><span class="hs-identifier hs-var">args0Rest</span></a></span><span>
</span><span id="line-423"></span><span>                       </span><span id="local-6989586621679223972"><span class="annot"><span class="annottext">knN_cls :: Class
</span><a href="#local-6989586621679223972"><span class="hs-identifier hs-var hs-var">knN_cls</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">KnownNatDefs -&gt; Class
</span><a href="GHC.TypeLits.KnownNat.Solver.html#knownNat2Bool"><span class="hs-identifier hs-var">knownNat2Bool</span></a></span><span> </span><span class="annot"><span class="annottext">KnownNatDefs
</span><a href="#local-6989586621679223910"><span class="hs-identifier hs-var">defs</span></a></span><span>
</span><span id="line-424"></span><span>                 </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Right</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679223973"><span class="annot"><span class="annottext">ClsInst
</span><a href="#local-6989586621679223973"><span class="hs-identifier hs-var">inst</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">InstEnvs
-&gt; Class
-&gt; [Type]
-&gt; Either LookupInstanceErrReason (ClsInst, [Type])
</span><span class="hs-identifier hs-var">lookupUniqueInstEnv</span></span><span> </span><span class="annot"><span class="annottext">InstEnvs
</span><a href="#local-6989586621679223930"><span class="hs-identifier hs-var">ienv</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679223972"><span class="hs-identifier hs-var">knN_cls</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679223971"><span class="hs-identifier hs-var">args1N</span></a></span><span>
</span><span id="line-425"></span><span>                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(ClsInst, Class, [Type], [Type])
-&gt; Maybe (ClsInst, Class, [Type], [Type])
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ClsInst
</span><a href="#local-6989586621679223973"><span class="hs-identifier hs-var">inst</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679223972"><span class="hs-identifier hs-var">knN_cls</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679223970"><span class="hs-identifier hs-var">args0Rest</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679223971"><span class="hs-identifier hs-var">args1N</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-426"></span><span>                 </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-427"></span><span>                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe (ClsInst, Class, [Type], [Type])
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-428"></span><span>        </span><span class="hs-keyword">case</span><span> </span><span class="annot"><a href="#local-6989586621679223947"><span class="hs-identifier hs-type">instM</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-429"></span><span>          </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679223974"><span class="annot"><span class="annottext">ClsInst
</span><a href="#local-6989586621679223974"><span class="hs-identifier hs-var">inst</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679223975"><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679223975"><span class="hs-identifier hs-var">knN_cls</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679223976"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679223976"><span class="hs-identifier hs-var">args0N</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679223977"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679223977"><span class="hs-identifier hs-var">args1N</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-430"></span><span>            </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679223978"><span class="annot"><span class="annottext">df_id :: DFunId
</span><a href="#local-6989586621679223978"><span class="hs-identifier hs-var hs-var hs-var">df_id</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ClsInst -&gt; DFunId
</span><span class="hs-identifier hs-var">instanceDFunId</span></span><span> </span><span class="annot"><span class="annottext">ClsInst
</span><a href="#local-6989586621679223974"><span class="hs-identifier hs-var">inst</span></a></span><span>
</span><span id="line-431"></span><span>                </span><span id="local-6989586621679223979"><span class="annot"><span class="annottext">df :: (Class, DFunId)
</span><a href="#local-6989586621679223979"><span class="hs-identifier hs-var hs-var hs-var">df</span></a></span></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679223975"><span class="hs-identifier hs-var">knN_cls</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">DFunId
</span><a href="#local-6989586621679223978"><span class="hs-identifier hs-var">df_id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-432"></span><span>                </span><span id="local-6989586621679223981"><span class="annot"><span class="annottext">df_args :: [Scaled Type]
</span><a href="#local-6989586621679223981"><span class="hs-identifier hs-var hs-var hs-var">df_args</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">([Scaled Type], Type) -&gt; [Scaled Type]
forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span>                  </span><span class="hs-comment">-- [KnownNat x, KnownNat y]</span><span>
</span><span id="line-433"></span><span>                        </span><span class="annot"><span class="annottext">(([Scaled Type], Type) -&gt; [Scaled Type])
-&gt; (Type -&gt; ([Scaled Type], Type)) -&gt; Type -&gt; [Scaled Type]
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; ([Scaled Type], Type)
</span><span class="hs-identifier hs-var">splitFunTys</span></span><span>          </span><span class="hs-comment">-- ([KnownNat x, KnowNat y], DKnownNat2 &quot;+&quot; x y)</span><span>
</span><span id="line-434"></span><span>                        </span><span class="annot"><span class="annottext">(Type -&gt; ([Scaled Type], Type))
-&gt; (Type -&gt; Type) -&gt; Type -&gt; ([Scaled Type], Type)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">HasDebugCallStack =&gt; Type -&gt; [Type] -&gt; Type
Type -&gt; [Type] -&gt; Type
</span><span class="hs-operator hs-var">`piResultTys`</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679223976"><span class="hs-identifier hs-var">args0N</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- (KnowNat x, KnownNat y) =&gt; DKnownNat2 &quot;+&quot; x y</span><span>
</span><span id="line-435"></span><span>                        </span><span class="annot"><span class="annottext">(Type -&gt; [Scaled Type]) -&gt; Type -&gt; [Scaled Type]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">DFunId -&gt; Type
</span><span class="hs-identifier hs-var">idType</span></span><span> </span><span class="annot"><span class="annottext">DFunId
</span><a href="#local-6989586621679223978"><span class="hs-identifier hs-var">df_id</span></a></span><span>         </span><span class="hs-comment">-- forall a b . (KnownNat a, KnownNat b) =&gt; DKnownNat2 &quot;+&quot; a b</span><span>
</span><span id="line-436"></span><span>            </span><span class="hs-special">(</span><span id="local-6989586621679223983"><span class="annot"><a href="#local-6989586621679223983"><span class="hs-identifier hs-var">evs</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679223984"><span class="annot"><a href="#local-6989586621679223984"><span class="hs-identifier hs-var">new</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[(EvExpr, [Ct])] -&gt; ([EvExpr], [[Ct]])
forall a b. [(a, b)] -&gt; ([a], [b])
</span><span class="hs-identifier hs-var">unzip</span></span><span> </span><span class="annot"><span class="annottext">([(EvExpr, [Ct])] -&gt; ([EvExpr], [[Ct]]))
-&gt; TcPluginM [(EvExpr, [Ct])] -&gt; TcPluginM ([EvExpr], [[Ct]])
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">(Scaled Type -&gt; TcPluginM (EvExpr, [Ct]))
-&gt; [Scaled Type] -&gt; TcPluginM [(EvExpr, [Ct])]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; [a] -&gt; m [b]
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; TcPluginM (EvExpr, [Ct])
</span><a href="#local-6989586621679223985"><span class="hs-identifier hs-var">go_arg</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; TcPluginM (EvExpr, [Ct]))
-&gt; (Scaled Type -&gt; Type) -&gt; Scaled Type -&gt; TcPluginM (EvExpr, [Ct])
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Scaled Type -&gt; Type
forall a. Scaled a -&gt; a
</span><span class="hs-identifier hs-var">irrelevantMult</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Scaled Type]
</span><a href="#local-6989586621679223981"><span class="hs-identifier hs-var">df_args</span></a></span><span>
</span><span id="line-437"></span><span>            </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="hs-identifier hs-var">className</span></span><span> </span><span class="annot"><a href="#local-6989586621679223913"><span class="hs-identifier hs-type">cls</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">==</span></span><span> </span><span class="annot"><span class="hs-identifier hs-var">className</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#knownBool"><span class="hs-identifier hs-var">knownBool</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679223910"><span class="hs-identifier hs-type">defs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-438"></span><span>               </span><span class="hs-comment">-- Create evidence using the original, flattened, argument of</span><span>
</span><span id="line-439"></span><span>               </span><span class="hs-comment">-- the KnownNat we're trying to solve. Not doing this results in</span><span>
</span><span id="line-440"></span><span>               </span><span class="hs-comment">-- GHC panics for:</span><span>
</span><span id="line-441"></span><span>               </span><span class="hs-comment">-- https://gist.github.com/christiaanb/0d204fe19f89b28f1f8d24feb63f1e63</span><span>
</span><span id="line-442"></span><span>               </span><span class="hs-comment">--</span><span>
</span><span id="line-443"></span><span>               </span><span class="hs-comment">-- That's because the flattened KnownNat we're asked to solve is</span><span>
</span><span id="line-444"></span><span>               </span><span class="hs-comment">-- [W] KnownNat fsk</span><span>
</span><span id="line-445"></span><span>               </span><span class="hs-comment">-- given:</span><span>
</span><span id="line-446"></span><span>               </span><span class="hs-comment">-- [G] fsk ~ CLog 2 n + 1</span><span>
</span><span id="line-447"></span><span>               </span><span class="hs-comment">-- [G] fsk2 ~ n</span><span>
</span><span id="line-448"></span><span>               </span><span class="hs-comment">-- [G] fsk2 ~ n + m</span><span>
</span><span id="line-449"></span><span>               </span><span class="hs-comment">--</span><span>
</span><span id="line-450"></span><span>               </span><span class="hs-comment">-- Our flattening picks one of the solution, so we try to solve</span><span>
</span><span id="line-451"></span><span>               </span><span class="hs-comment">-- [W] KnownNat (CLog 2 n + 1)</span><span>
</span><span id="line-452"></span><span>               </span><span class="hs-comment">--</span><span>
</span><span id="line-453"></span><span>               </span><span class="hs-comment">-- Turns out, GHC wanted us to solve:</span><span>
</span><span id="line-454"></span><span>               </span><span class="hs-comment">-- [W] KnownNat (CLog 2 (n + m) + 1)</span><span>
</span><span id="line-455"></span><span>               </span><span class="hs-comment">--</span><span>
</span><span id="line-456"></span><span>               </span><span class="hs-comment">-- But we have no way of knowing this! Solving the &quot;wrong&quot; expansion</span><span>
</span><span id="line-457"></span><span>               </span><span class="hs-comment">-- of 'fsk' results in:</span><span>
</span><span id="line-458"></span><span>               </span><span class="hs-comment">--</span><span>
</span><span id="line-459"></span><span>               </span><span class="hs-comment">-- ghc: panic! (the 'impossible' happened)</span><span>
</span><span id="line-460"></span><span>               </span><span class="hs-comment">-- (GHC version 8.6.5 for x86_64-unknown-linux):</span><span>
</span><span id="line-461"></span><span>               </span><span class="hs-comment">--       buildKindCoercion</span><span>
</span><span id="line-462"></span><span>               </span><span class="hs-comment">-- CLog 2 (n_a681K + m_a681L)</span><span>
</span><span id="line-463"></span><span>               </span><span class="hs-comment">-- CLog 2 n_a681K</span><span>
</span><span id="line-464"></span><span>               </span><span class="hs-comment">-- n_a681K + m_a681L</span><span>
</span><span id="line-465"></span><span>               </span><span class="hs-comment">-- n_a681K</span><span>
</span><span id="line-466"></span><span>               </span><span class="hs-comment">--</span><span>
</span><span id="line-467"></span><span>               </span><span class="hs-comment">-- down the line.</span><span>
</span><span id="line-468"></span><span>               </span><span class="hs-comment">--</span><span>
</span><span id="line-469"></span><span>               </span><span class="hs-comment">-- So while the &quot;shape&quot; of the KnownNat evidence that we return</span><span>
</span><span id="line-470"></span><span>               </span><span class="hs-comment">-- follows 'CLog 2 n + 1', the type of the evidence will be</span><span>
</span><span id="line-471"></span><span>               </span><span class="hs-comment">-- 'KnownNat fsk'; the one GHC originally asked us to solve.</span><span>
</span><span id="line-472"></span><span>               </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">concat</span></span><span> </span><span class="annot"><a href="#local-6989586621679223984"><span class="hs-identifier hs-type">new</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-operator hs-type">&lt;$&gt;</span></span><span> </span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#makeOpDictByFiat"><span class="hs-identifier hs-type">makeOpDictByFiat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679223979"><span class="hs-identifier hs-type">df</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679223913"><span class="hs-identifier hs-type">cls</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679223977"><span class="hs-identifier hs-type">args1N</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679223976"><span class="hs-identifier hs-type">args0N</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#unOrig"><span class="hs-identifier hs-var">unOrig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679223915"><span class="hs-identifier hs-type">orig</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679223983"><span class="hs-identifier hs-type">evs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-473"></span><span>               </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">concat</span></span><span> </span><span class="annot"><a href="#local-6989586621679223984"><span class="hs-identifier hs-type">new</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-operator hs-type">&lt;$&gt;</span></span><span> </span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#makeOpDict"><span class="hs-identifier hs-type">makeOpDict</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679223979"><span class="hs-identifier hs-type">df</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679223913"><span class="hs-identifier hs-type">cls</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679223977"><span class="hs-identifier hs-type">args1N</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679223976"><span class="hs-identifier hs-type">args0N</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#unOrig"><span class="hs-identifier hs-var">unOrig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679223915"><span class="hs-identifier hs-type">orig</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679223983"><span class="hs-identifier hs-type">evs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">fmap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679223923"><span class="hs-identifier hs-type">ty</span></a></span><span class="hs-special">,</span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679223927"><span class="hs-identifier hs-type">sM</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-474"></span><span>          </span><span class="annot"><span class="annottext">Maybe (ClsInst, Class, [Type], [Type])
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe (EvTerm, [Ct]) -&gt; TcPluginM (Maybe (EvTerm, [Ct]))
forall a. a -&gt; TcPluginM a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-special">,</span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(EvTerm -&gt; (EvTerm, [Ct])) -&gt; Maybe EvTerm -&gt; Maybe (EvTerm, [Ct])
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Maybe EvTerm
</span><a href="#local-6989586621679223921"><span class="hs-identifier hs-var">go_other</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679223923"><span class="hs-identifier hs-var">ty</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-475"></span><span>
</span><span id="line-476"></span><span>    </span><span class="annot"><a href="#local-6989586621679223920"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">LitTy</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">NumTyLit</span></span><span> </span><span id="local-6989586621679223990"><span class="annot"><span class="annottext">Integer
</span><a href="#local-6989586621679223990"><span class="hs-identifier hs-var">i</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Maybe Coercion
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>
</span><span id="line-477"></span><span>      </span><span class="hs-comment">-- Let GHC solve simple Literal constraints</span><span>
</span><span id="line-478"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="hs-identifier hs-type">LitTy</span></span><span> </span><span class="annot"><span class="annottext">TyLit
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679223914"><span class="hs-identifier hs-var">op</span></a></span><span>
</span><span id="line-479"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe (EvTerm, [Ct]) -&gt; TcPluginM (Maybe (EvTerm, [Ct]))
forall a. a -&gt; TcPluginM a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Maybe (EvTerm, [Ct])
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-480"></span><span>      </span><span class="hs-comment">-- This plugin only solves Literal KnownNat's that needed to be normalised</span><span>
</span><span id="line-481"></span><span>      </span><span class="hs-comment">-- first</span><span>
</span><span id="line-482"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-483"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(EvTerm -&gt; (EvTerm, [Ct])) -&gt; Maybe EvTerm -&gt; Maybe (EvTerm, [Ct])
forall a b. (a -&gt; b) -&gt; Maybe a -&gt; Maybe b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">,</span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Maybe EvTerm -&gt; Maybe (EvTerm, [Ct]))
-&gt; TcPluginM (Maybe EvTerm) -&gt; TcPluginM (Maybe (EvTerm, [Ct]))
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Class -&gt; Type -&gt; Integer -&gt; TcPluginM (Maybe EvTerm)
</span><a href="GHC.TypeLits.KnownNat.Solver.html#makeLitDict"><span class="hs-identifier hs-var">makeLitDict</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679223913"><span class="hs-identifier hs-var">cls</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679223914"><span class="hs-identifier hs-var">op</span></a></span><span> </span><span class="annot"><span class="annottext">Integer
</span><a href="#local-6989586621679223990"><span class="hs-identifier hs-var">i</span></a></span><span>
</span><span id="line-484"></span><span>    </span><span class="annot"><a href="#local-6989586621679223920"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">(Type, Maybe Coercion)
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe (EvTerm, [Ct]) -&gt; TcPluginM (Maybe (EvTerm, [Ct]))
forall a. a -&gt; TcPluginM a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Maybe (EvTerm, [Ct])
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-485"></span><span>
</span><span id="line-486"></span><span>    </span><span class="hs-comment">-- Get EvTerm arguments for type-level operations. If they do not exist</span><span>
</span><span id="line-487"></span><span>    </span><span class="hs-comment">-- as [G]iven constraints, then generate new [W]anted constraints</span><span>
</span><span id="line-488"></span><span>    </span><span class="annot"><a href="#local-6989586621679223985"><span class="hs-identifier hs-type">go_arg</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">PredType</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TcPluginM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">EvExpr</span></span><span class="hs-special">,</span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Ct</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-489"></span><span>    </span><span id="local-6989586621679223985"><span class="annot"><span class="annottext">go_arg :: Type -&gt; TcPluginM (EvExpr, [Ct])
</span><a href="#local-6989586621679223985"><span class="hs-identifier hs-var hs-var">go_arg</span></a></span></span><span> </span><span id="local-6989586621679223992"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679223992"><span class="hs-identifier hs-var">ty</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">CType -&gt; [(CType, EvExpr)] -&gt; Maybe EvExpr
forall a b. Eq a =&gt; a -&gt; [(a, b)] -&gt; Maybe b
</span><span class="hs-identifier hs-var">lookup</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; CType
</span><span class="hs-identifier hs-var">CType</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679223992"><span class="hs-identifier hs-var">ty</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[(CType, EvExpr)]
</span><a href="#local-6989586621679223911"><span class="hs-identifier hs-var">givens</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-490"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679223994"><span class="annot"><span class="annottext">EvExpr
</span><a href="#local-6989586621679223994"><span class="hs-identifier hs-var">ev</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(EvExpr, [Ct]) -&gt; TcPluginM (EvExpr, [Ct])
forall a. a -&gt; TcPluginM a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">EvExpr
</span><a href="#local-6989586621679223994"><span class="hs-identifier hs-var">ev</span></a></span><span class="hs-special">,</span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-491"></span><span>      </span><span class="annot"><span class="annottext">Maybe EvExpr
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-492"></span><span>        </span><span class="hs-special">(</span><span id="local-6989586621679223995"><span class="annot"><a href="#local-6989586621679223995"><span class="hs-identifier hs-var">ev</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679223996"><span class="annot"><a href="#local-6989586621679223996"><span class="hs-identifier hs-var">wanted</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Ct -&gt; Type -&gt; TcPluginM (EvExpr, Ct)
</span><a href="GHC.TypeLits.KnownNat.Solver.html#makeWantedEv"><span class="hs-identifier hs-var">makeWantedEv</span></a></span><span> </span><span class="annot"><span class="annottext">Ct
</span><a href="#local-6989586621679223912"><span class="hs-identifier hs-var">ct</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679223992"><span class="hs-identifier hs-var">ty</span></a></span><span>
</span><span id="line-493"></span><span>        </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679223995"><span class="hs-identifier hs-type">ev</span></a></span><span class="hs-special">,</span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679223996"><span class="hs-identifier hs-type">wanted</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-494"></span><span>
</span><span id="line-495"></span><span>    </span><span class="hs-comment">-- Fall through case: look up the normalised [W]anted constraint in the list</span><span>
</span><span id="line-496"></span><span>    </span><span class="hs-comment">-- of [G]iven constraints.</span><span>
</span><span id="line-497"></span><span>    </span><span class="annot"><a href="#local-6989586621679223921"><span class="hs-identifier hs-type">go_other</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">EvTerm</span></span><span>
</span><span id="line-498"></span><span>    </span><span id="local-6989586621679223921"><span class="annot"><span class="annottext">go_other :: Type -&gt; Maybe EvTerm
</span><a href="#local-6989586621679223921"><span class="hs-identifier hs-var hs-var">go_other</span></a></span></span><span> </span><span id="local-6989586621679223998"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679223998"><span class="hs-identifier hs-var">ty</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-499"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679223999"><span class="annot"><span class="annottext">knClsTc :: TyCon
</span><a href="#local-6989586621679223999"><span class="hs-identifier hs-var hs-var">knClsTc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Class -&gt; TyCon
</span><span class="hs-identifier hs-var">classTyCon</span></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679223913"><span class="hs-identifier hs-var">cls</span></a></span><span>
</span><span id="line-500"></span><span>          </span><span id="local-6989586621679224000"><span class="annot"><span class="annottext">kn :: Type
</span><a href="#local-6989586621679224000"><span class="hs-identifier hs-var hs-var">kn</span></a></span></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TyCon -&gt; [Type] -&gt; Type
</span><span class="hs-identifier hs-var">mkTyConApp</span></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621679223999"><span class="hs-identifier hs-var">knClsTc</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679223998"><span class="hs-identifier hs-var">ty</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-501"></span><span>          </span><span id="local-6989586621679224002"><span class="annot"><span class="annottext">cast :: EvExpr -&gt; Maybe EvTerm
</span><a href="#local-6989586621679224002"><span class="hs-identifier hs-var hs-var">cast</span></a></span></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Type -&gt; CType
</span><span class="hs-identifier hs-var">CType</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679223998"><span class="hs-identifier hs-var">ty</span></a></span><span> </span><span class="annot"><span class="annottext">CType -&gt; CType -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; CType
</span><span class="hs-identifier hs-var">CType</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679223914"><span class="hs-identifier hs-var">op</span></a></span><span>
</span><span id="line-502"></span><span>                       </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">EvTerm -&gt; Maybe EvTerm
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">(EvTerm -&gt; Maybe EvTerm)
-&gt; (EvExpr -&gt; EvTerm) -&gt; EvExpr -&gt; Maybe EvTerm
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">EvExpr -&gt; EvTerm
</span><span class="hs-identifier hs-var">EvExpr</span></span><span>
</span><span id="line-503"></span><span>                       </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">Class -&gt; Type -&gt; Type -&gt; EvExpr -&gt; Maybe EvTerm
</span><a href="GHC.TypeLits.KnownNat.Solver.html#makeKnCoercion"><span class="hs-identifier hs-var">makeKnCoercion</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679223913"><span class="hs-identifier hs-var">cls</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679223998"><span class="hs-identifier hs-var">ty</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679223914"><span class="hs-identifier hs-var">op</span></a></span><span>
</span><span id="line-504"></span><span>      </span><span class="hs-keyword">in</span><span>  </span><span class="annot"><span class="annottext">EvExpr -&gt; Maybe EvTerm
</span><a href="#local-6989586621679224002"><span class="hs-identifier hs-var">cast</span></a></span><span> </span><span class="annot"><span class="annottext">(EvExpr -&gt; Maybe EvTerm) -&gt; Maybe EvExpr -&gt; Maybe EvTerm
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b
</span><span class="hs-operator hs-var">=&lt;&lt;</span></span><span> </span><span class="annot"><span class="annottext">CType -&gt; [(CType, EvExpr)] -&gt; Maybe EvExpr
forall a b. Eq a =&gt; a -&gt; [(a, b)] -&gt; Maybe b
</span><span class="hs-identifier hs-var">lookup</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; CType
</span><span class="hs-identifier hs-var">CType</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224000"><span class="hs-identifier hs-var">kn</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[(CType, EvExpr)]
</span><a href="#local-6989586621679223911"><span class="hs-identifier hs-var">givens</span></a></span><span>
</span><span id="line-505"></span><span>
</span><span id="line-506"></span><span>    </span><span class="hs-comment">-- Find a known constraint for a wanted, so that (modulo normalization)</span><span>
</span><span id="line-507"></span><span>    </span><span class="hs-comment">-- the two are a constant offset apart.</span><span>
</span><span id="line-508"></span><span>    </span><span class="annot"><a href="#local-6989586621679223917"><span class="hs-identifier hs-type">offset</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TcPluginM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">EvTerm</span></span><span class="hs-special">,</span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Ct</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-509"></span><span>    </span><span id="local-6989586621679223917"><span class="annot"><span class="annottext">offset :: Type -&gt; TcPluginM (Maybe (EvTerm, [Ct]))
</span><a href="#local-6989586621679223917"><span class="hs-identifier hs-var hs-var">offset</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">LitTy</span></span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe (EvTerm, [Ct]) -&gt; TcPluginM (Maybe (EvTerm, [Ct]))
forall a. a -&gt; TcPluginM a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Maybe (EvTerm, [Ct])
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-510"></span><span>    </span><span class="annot"><a href="#local-6989586621679223917"><span class="hs-identifier hs-var">offset</span></a></span><span> </span><span id="local-6989586621679224006"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224006"><span class="hs-identifier hs-var">want</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">MaybeT TcPluginM (EvTerm, [Ct]) -&gt; TcPluginM (Maybe (EvTerm, [Ct]))
forall (m :: * -&gt; *) a. MaybeT m a -&gt; m (Maybe a)
</span><span class="hs-identifier hs-var">runMaybeT</span></span><span> </span><span class="annot"><span class="annottext">(MaybeT TcPluginM (EvTerm, [Ct])
 -&gt; TcPluginM (Maybe (EvTerm, [Ct])))
-&gt; MaybeT TcPluginM (EvTerm, [Ct])
-&gt; TcPluginM (Maybe (EvTerm, [Ct]))
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-511"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span class="hs-comment">-- Get the knownnat contraints</span><span>
</span><span id="line-512"></span><span>          </span><span id="local-6989586621679224009"><span class="annot"><span class="annottext">unKn :: Type -&gt; Maybe Type
</span><a href="#local-6989586621679224009"><span class="hs-identifier hs-var hs-var hs-var">unKn</span></a></span></span><span> </span><span id="local-6989586621679224010"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224010"><span class="hs-identifier hs-var">ty'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Pred
</span><span class="hs-identifier hs-var">classifyPredType</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224010"><span class="hs-identifier hs-var">ty'</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-513"></span><span>                       </span><span class="annot"><span class="hs-identifier hs-type">ClassPred</span></span><span> </span><span id="local-6989586621679224011"><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679224011"><span class="hs-identifier hs-var">cls'</span></a></span></span><span> </span><span class="hs-special">[</span><span id="local-6989586621679224012"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224012"><span class="hs-identifier hs-var">ty''</span></a></span></span><span class="hs-special">]</span><span>
</span><span id="line-514"></span><span>                         </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Class -&gt; Name
</span><span class="hs-identifier hs-var">className</span></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679224011"><span class="hs-identifier hs-var">cls'</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><span class="hs-identifier hs-var">knownNatClassName</span></span><span>
</span><span id="line-515"></span><span>                         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Maybe Type
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224012"><span class="hs-identifier hs-var">ty''</span></a></span><span>
</span><span id="line-516"></span><span>                       </span><span class="annot"><span class="annottext">Pred
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe Type
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-517"></span><span>          </span><span class="hs-comment">-- Get the rewrites</span><span>
</span><span id="line-518"></span><span>          </span><span id="local-6989586621679224013"><span class="annot"><span class="annottext">unEq :: (Type, c) -&gt; Maybe (Type, Type, c)
</span><a href="#local-6989586621679224013"><span class="hs-identifier hs-var hs-var hs-var">unEq</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679224014"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224014"><span class="hs-identifier hs-var">ty'</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679224015"><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679224015"><span class="hs-identifier hs-var">ev</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Pred
</span><span class="hs-identifier hs-var">classifyPredType</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224014"><span class="hs-identifier hs-var">ty'</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-519"></span><span>                            </span><span class="annot"><span class="hs-identifier hs-type">EqPred</span></span><span> </span><span class="annot"><span class="annottext">EqRel
</span><span class="hs-identifier hs-var">NomEq</span></span><span> </span><span id="local-6989586621679224016"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224016"><span class="hs-identifier hs-var">ty1</span></a></span></span><span> </span><span id="local-6989586621679224017"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224017"><span class="hs-identifier hs-var">ty2</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Type, Type, c) -&gt; Maybe (Type, Type, c)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224016"><span class="hs-identifier hs-var">ty1</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224017"><span class="hs-identifier hs-var">ty2</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679224015"><span class="hs-identifier hs-var">ev</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-520"></span><span>                            </span><span class="annot"><span class="annottext">Pred
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe (Type, Type, c)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-521"></span><span>          </span><span class="annot"><a href="#local-6989586621679224018"><span class="hs-identifier hs-type">rewrites</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">EvExpr</span></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-522"></span><span>          </span><span id="local-6989586621679224018"><span class="annot"><span class="annottext">rewrites :: [(Type, Type, EvExpr)]
</span><a href="#local-6989586621679224018"><span class="hs-identifier hs-var hs-var hs-var">rewrites</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">((CType, EvExpr) -&gt; Maybe (Type, Type, EvExpr))
-&gt; [(CType, EvExpr)] -&gt; [(Type, Type, EvExpr)]
forall a b. (a -&gt; Maybe b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">mapMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Type, EvExpr) -&gt; Maybe (Type, Type, EvExpr)
forall {c}. (Type, c) -&gt; Maybe (Type, Type, c)
</span><a href="#local-6989586621679224013"><span class="hs-identifier hs-var">unEq</span></a></span><span> </span><span class="annot"><span class="annottext">((Type, EvExpr) -&gt; Maybe (Type, Type, EvExpr))
-&gt; ((CType, EvExpr) -&gt; (Type, EvExpr))
-&gt; (CType, EvExpr)
-&gt; Maybe (Type, Type, EvExpr)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(CType -&gt; Type) -&gt; (CType, EvExpr) -&gt; (Type, EvExpr)
forall b c d. (b -&gt; c) -&gt; (b, d) -&gt; (c, d)
forall (a :: * -&gt; * -&gt; *) b c d.
Arrow a =&gt;
a b c -&gt; a (b, d) (c, d)
</span><span class="hs-identifier hs-var">first</span></span><span> </span><span class="annot"><span class="annottext">CType -&gt; Type
</span><span class="hs-identifier hs-var">unCType</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[(CType, EvExpr)]
</span><a href="#local-6989586621679223911"><span class="hs-identifier hs-var">givens</span></a></span><span>
</span><span id="line-523"></span><span>          </span><span class="hs-comment">-- Rewrite</span><span>
</span><span id="line-524"></span><span>          </span><span id="local-6989586621679224021"><span class="annot"><span class="annottext">rewriteTy :: Type
-&gt; (Type, Type, EvExpr)
-&gt; Maybe (Type, Maybe (Type, Maybe Coercion))
</span><a href="#local-6989586621679224021"><span class="hs-identifier hs-var hs-var hs-var">rewriteTy</span></a></span></span><span> </span><span id="local-6989586621679224022"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224022"><span class="hs-identifier hs-var">tyK</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679224023"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224023"><span class="hs-identifier hs-var">ty1</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679224024"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224024"><span class="hs-identifier hs-var">ty2</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679224025"><span class="annot"><span class="annottext">EvExpr
</span><a href="#local-6989586621679224025"><span class="hs-identifier hs-var">ev</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-525"></span><span>            </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224023"><span class="hs-identifier hs-var">ty1</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Bool
</span><span class="hs-operator hs-var">`eqType`</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224022"><span class="hs-identifier hs-var">tyK</span></a></span><span>
</span><span id="line-526"></span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Type, Maybe (Type, Maybe Coercion))
-&gt; Maybe (Type, Maybe (Type, Maybe Coercion))
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224024"><span class="hs-identifier hs-var">ty2</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">(Type, Maybe Coercion) -&gt; Maybe (Type, Maybe Coercion)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224022"><span class="hs-identifier hs-var">tyK</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">EvTerm -&gt; Maybe Coercion
</span><span class="hs-identifier hs-var">evTermCoercion_maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">EvExpr -&gt; EvTerm
</span><span class="hs-identifier hs-var">EvExpr</span></span><span> </span><span class="annot"><span class="annottext">EvExpr
</span><a href="#local-6989586621679224025"><span class="hs-identifier hs-var">ev</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-527"></span><span>            </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224024"><span class="hs-identifier hs-var">ty2</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Bool
</span><span class="hs-operator hs-var">`eqType`</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224022"><span class="hs-identifier hs-var">tyK</span></a></span><span>
</span><span id="line-528"></span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Type, Maybe (Type, Maybe Coercion))
-&gt; Maybe (Type, Maybe (Type, Maybe Coercion))
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224023"><span class="hs-identifier hs-var">ty1</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">(Type, Maybe Coercion) -&gt; Maybe (Type, Maybe Coercion)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224022"><span class="hs-identifier hs-var">tyK</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">(Coercion -&gt; Coercion) -&gt; Maybe Coercion -&gt; Maybe Coercion
forall a b. (a -&gt; b) -&gt; Maybe a -&gt; Maybe b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">Coercion -&gt; Coercion
</span><a href="GHC.TypeLits.KnownNat.Solver.html#mkTcSymCo"><span class="hs-identifier hs-var">mkTcSymCo</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">EvTerm -&gt; Maybe Coercion
</span><span class="hs-identifier hs-var">evTermCoercion_maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">EvExpr -&gt; EvTerm
</span><span class="hs-identifier hs-var">EvExpr</span></span><span> </span><span class="annot"><span class="annottext">EvExpr
</span><a href="#local-6989586621679224025"><span class="hs-identifier hs-var">ev</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-529"></span><span>            </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-530"></span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe (Type, Maybe (Type, Maybe Coercion))
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-531"></span><span>          </span><span class="hs-comment">-- Get only the [G]iven KnownNat constraints</span><span>
</span><span id="line-532"></span><span>          </span><span id="local-6989586621679224026"><span class="annot"><span class="annottext">knowns :: [Type]
</span><a href="#local-6989586621679224026"><span class="hs-identifier hs-var hs-var hs-var">knowns</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">((CType, EvExpr) -&gt; Maybe Type) -&gt; [(CType, EvExpr)] -&gt; [Type]
forall a b. (a -&gt; Maybe b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">mapMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Maybe Type
</span><a href="#local-6989586621679224009"><span class="hs-identifier hs-var">unKn</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Maybe Type)
-&gt; ((CType, EvExpr) -&gt; Type) -&gt; (CType, EvExpr) -&gt; Maybe Type
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">CType -&gt; Type
</span><span class="hs-identifier hs-var">unCType</span></span><span> </span><span class="annot"><span class="annottext">(CType -&gt; Type)
-&gt; ((CType, EvExpr) -&gt; CType) -&gt; (CType, EvExpr) -&gt; Type
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(CType, EvExpr) -&gt; CType
forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[(CType, EvExpr)]
</span><a href="#local-6989586621679223911"><span class="hs-identifier hs-var">givens</span></a></span><span>
</span><span id="line-533"></span><span>          </span><span class="hs-comment">-- Get all the rewritten KNs</span><span>
</span><span id="line-534"></span><span>          </span><span id="local-6989586621679224028"><span class="annot"><span class="annottext">knownsR :: [(Type, Maybe (Type, Maybe Coercion))]
</span><a href="#local-6989586621679224028"><span class="hs-identifier hs-var hs-var hs-var">knownsR</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Maybe (Type, Maybe (Type, Maybe Coercion))]
-&gt; [(Type, Maybe (Type, Maybe Coercion))]
forall a. [Maybe a] -&gt; [a]
</span><span class="hs-identifier hs-var">catMaybes</span></span><span> </span><span class="annot"><span class="annottext">([Maybe (Type, Maybe (Type, Maybe Coercion))]
 -&gt; [(Type, Maybe (Type, Maybe Coercion))])
-&gt; [Maybe (Type, Maybe (Type, Maybe Coercion))]
-&gt; [(Type, Maybe (Type, Maybe Coercion))]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; [Maybe (Type, Maybe (Type, Maybe Coercion))])
-&gt; [Type] -&gt; [Maybe (Type, Maybe (Type, Maybe Coercion))]
forall (t :: * -&gt; *) a b. Foldable t =&gt; (a -&gt; [b]) -&gt; t a -&gt; [b]
</span><span class="hs-identifier hs-var">concatMap</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679224030"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224030"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">((Type, Type, EvExpr)
 -&gt; Maybe (Type, Maybe (Type, Maybe Coercion)))
-&gt; [(Type, Type, EvExpr)]
-&gt; [Maybe (Type, Maybe (Type, Maybe Coercion))]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
-&gt; (Type, Type, EvExpr)
-&gt; Maybe (Type, Maybe (Type, Maybe Coercion))
</span><a href="#local-6989586621679224021"><span class="hs-identifier hs-var">rewriteTy</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224030"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[(Type, Type, EvExpr)]
</span><a href="#local-6989586621679224018"><span class="hs-identifier hs-var">rewrites</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679224026"><span class="hs-identifier hs-var">knowns</span></a></span><span>
</span><span id="line-535"></span><span>          </span><span class="annot"><a href="#local-6989586621679224031"><span class="hs-identifier hs-type">knownsX</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Coercion</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-536"></span><span>          </span><span id="local-6989586621679224031"><span class="annot"><span class="annottext">knownsX :: [(Type, Maybe (Type, Maybe Coercion))]
</span><a href="#local-6989586621679224031"><span class="hs-identifier hs-var hs-var hs-var">knownsX</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; (Type, Maybe (Type, Maybe Coercion)))
-&gt; [Type] -&gt; [(Type, Maybe (Type, Maybe Coercion))]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">,</span><span class="annot"><span class="annottext">Maybe (Type, Maybe Coercion)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679224026"><span class="hs-identifier hs-var">knowns</span></a></span><span> </span><span class="annot"><span class="annottext">[(Type, Maybe (Type, Maybe Coercion))]
-&gt; [(Type, Maybe (Type, Maybe Coercion))]
-&gt; [(Type, Maybe (Type, Maybe Coercion))]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">[(Type, Maybe (Type, Maybe Coercion))]
</span><a href="#local-6989586621679224028"><span class="hs-identifier hs-var">knownsR</span></a></span><span>
</span><span id="line-537"></span><span>          </span><span class="hs-comment">-- pair up the sum-of-products KnownNat constraints</span><span>
</span><span id="line-538"></span><span>          </span><span class="hs-comment">-- with the original Nat operation</span><span>
</span><span id="line-539"></span><span>          </span><span id="local-6989586621679224032"><span class="annot"><span class="annottext">subWant :: Type -&gt; Type
</span><a href="#local-6989586621679224032"><span class="hs-identifier hs-var hs-var hs-var">subWant</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TyCon -&gt; [Type] -&gt; Type
</span><span class="hs-identifier hs-var">mkTyConApp</span></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><span class="hs-identifier hs-var">typeNatSubTyCon</span></span><span> </span><span class="annot"><span class="annottext">([Type] -&gt; Type) -&gt; (Type -&gt; [Type]) -&gt; Type -&gt; Type
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; [Type] -&gt; [Type]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="hs-special">[</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224006"><span class="hs-identifier hs-var">want</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-540"></span><span>          </span><span class="hs-comment">-- exploded :: [()]</span><span>
</span><span id="line-541"></span><span>          </span><span id="local-6989586621679224034"><span class="annot"><span class="annottext">exploded :: [(CoreSOP, (Type, Maybe (Type, Maybe Coercion)))]
</span><a href="#local-6989586621679224034"><span class="hs-identifier hs-var hs-var hs-var">exploded</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">((Type, Maybe (Type, Maybe Coercion))
 -&gt; (CoreSOP, (Type, Maybe (Type, Maybe Coercion))))
-&gt; [(Type, Maybe (Type, Maybe Coercion))]
-&gt; [(CoreSOP, (Type, Maybe (Type, Maybe Coercion)))]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(CoreSOP, [(Type, Type)]) -&gt; CoreSOP
forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span> </span><span class="annot"><span class="annottext">((CoreSOP, [(Type, Type)]) -&gt; CoreSOP)
-&gt; ((Type, Maybe (Type, Maybe Coercion))
    -&gt; (CoreSOP, [(Type, Type)]))
-&gt; (Type, Maybe (Type, Maybe Coercion))
-&gt; CoreSOP
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Writer [(Type, Type)] CoreSOP -&gt; (CoreSOP, [(Type, Type)])
forall w a. Writer w a -&gt; (a, w)
</span><span class="hs-identifier hs-var">runWriter</span></span><span> </span><span class="annot"><span class="annottext">(Writer [(Type, Type)] CoreSOP -&gt; (CoreSOP, [(Type, Type)]))
-&gt; ((Type, Maybe (Type, Maybe Coercion))
    -&gt; Writer [(Type, Type)] CoreSOP)
-&gt; (Type, Maybe (Type, Maybe Coercion))
-&gt; (CoreSOP, [(Type, Type)])
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Writer [(Type, Type)] CoreSOP
</span><span class="hs-identifier hs-var">normaliseNat</span></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Writer [(Type, Type)] CoreSOP)
-&gt; ((Type, Maybe (Type, Maybe Coercion)) -&gt; Type)
-&gt; (Type, Maybe (Type, Maybe Coercion))
-&gt; Writer [(Type, Type)] CoreSOP
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="#local-6989586621679224032"><span class="hs-identifier hs-var">subWant</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Type)
-&gt; ((Type, Maybe (Type, Maybe Coercion)) -&gt; Type)
-&gt; (Type, Maybe (Type, Maybe Coercion))
-&gt; Type
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(Type, Maybe (Type, Maybe Coercion)) -&gt; Type
forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span> </span><span class="annot"><span class="annottext">((Type, Maybe (Type, Maybe Coercion)) -&gt; CoreSOP)
-&gt; ((Type, Maybe (Type, Maybe Coercion))
    -&gt; (Type, Maybe (Type, Maybe Coercion)))
-&gt; (Type, Maybe (Type, Maybe Coercion))
-&gt; (CoreSOP, (Type, Maybe (Type, Maybe Coercion)))
forall b c c'. (b -&gt; c) -&gt; (b -&gt; c') -&gt; b -&gt; (c, c')
forall (a :: * -&gt; * -&gt; *) b c c'.
Arrow a =&gt;
a b c -&gt; a b c' -&gt; a b (c, c')
</span><span class="hs-operator hs-var">&amp;&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">(Type, Maybe (Type, Maybe Coercion))
-&gt; (Type, Maybe (Type, Maybe Coercion))
forall a. a -&gt; a
</span><span class="hs-identifier hs-var">id</span></span><span class="hs-special">)</span><span>
</span><span id="line-542"></span><span>                         </span><span class="annot"><span class="annottext">[(Type, Maybe (Type, Maybe Coercion))]
</span><a href="#local-6989586621679224031"><span class="hs-identifier hs-var">knownsX</span></a></span><span>
</span><span id="line-543"></span><span>          </span><span class="hs-comment">-- interesting cases for us are those where</span><span>
</span><span id="line-544"></span><span>          </span><span class="hs-comment">-- wanted and given only differ by a constant</span><span>
</span><span id="line-545"></span><span>          </span><span id="local-6989586621679224037"><span class="annot"><span class="annottext">examineDiff :: SOP v c -&gt; a -&gt; Maybe (a, Symbol v c)
</span><a href="#local-6989586621679224037"><span class="hs-identifier hs-var hs-var hs-var">examineDiff</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">S</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">P</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">I</span></span><span> </span><span id="local-6989586621679224041"><span class="annot"><span class="annottext">Integer
</span><a href="#local-6989586621679224041"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">]</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span id="local-6989586621679224042"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679224042"><span class="hs-identifier hs-var">entire</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a, Symbol v c) -&gt; Maybe (a, Symbol v c)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679224042"><span class="hs-identifier hs-var">entire</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Integer -&gt; Symbol v c
forall v c. Integer -&gt; Symbol v c
</span><span class="hs-identifier hs-var">I</span></span><span> </span><span class="annot"><span class="annottext">Integer
</span><a href="#local-6989586621679224041"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-546"></span><span>          </span><span class="annot"><a href="#local-6989586621679224037"><span class="hs-identifier hs-var">examineDiff</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">S</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">P</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">V</span></span><span> </span><span id="local-6989586621679224044"><span class="annot"><span class="annottext">v
</span><a href="#local-6989586621679224044"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-special">]</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span id="local-6989586621679224045"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679224045"><span class="hs-identifier hs-var">entire</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a, Symbol v c) -&gt; Maybe (a, Symbol v c)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679224045"><span class="hs-identifier hs-var">entire</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">v -&gt; Symbol v c
forall v c. v -&gt; Symbol v c
</span><span class="hs-identifier hs-var">V</span></span><span> </span><span class="annot"><span class="annottext">v
</span><a href="#local-6989586621679224044"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-547"></span><span>          </span><span class="annot"><a href="#local-6989586621679224037"><span class="hs-identifier hs-var">examineDiff</span></a></span><span> </span><span class="annot"><span class="annottext">SOP v c
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe (a, Symbol v c)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-548"></span><span>          </span><span id="local-6989586621679224046"><span class="annot"><span class="annottext">interesting :: [((Type, Maybe (Type, Maybe Coercion)), Symbol DFunId c)]
</span><a href="#local-6989586621679224046"><span class="hs-identifier hs-var hs-var hs-var">interesting</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">((CoreSOP, (Type, Maybe (Type, Maybe Coercion)))
 -&gt; Maybe ((Type, Maybe (Type, Maybe Coercion)), Symbol DFunId c))
-&gt; [(CoreSOP, (Type, Maybe (Type, Maybe Coercion)))]
-&gt; [((Type, Maybe (Type, Maybe Coercion)), Symbol DFunId c)]
forall a b. (a -&gt; Maybe b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">mapMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(CoreSOP
 -&gt; (Type, Maybe (Type, Maybe Coercion))
 -&gt; Maybe ((Type, Maybe (Type, Maybe Coercion)), Symbol DFunId c))
-&gt; (CoreSOP, (Type, Maybe (Type, Maybe Coercion)))
-&gt; Maybe ((Type, Maybe (Type, Maybe Coercion)), Symbol DFunId c)
forall a b c. (a -&gt; b -&gt; c) -&gt; (a, b) -&gt; c
</span><span class="hs-identifier hs-var">uncurry</span></span><span> </span><span class="annot"><span class="annottext">CoreSOP
-&gt; (Type, Maybe (Type, Maybe Coercion))
-&gt; Maybe ((Type, Maybe (Type, Maybe Coercion)), Symbol DFunId c)
forall {v} {c} {a} {c}. SOP v c -&gt; a -&gt; Maybe (a, Symbol v c)
</span><a href="#local-6989586621679224037"><span class="hs-identifier hs-var">examineDiff</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[(CoreSOP, (Type, Maybe (Type, Maybe Coercion)))]
</span><a href="#local-6989586621679224034"><span class="hs-identifier hs-var">exploded</span></a></span><span>
</span><span id="line-549"></span><span>      </span><span class="hs-comment">-- convert the first suitable evidence</span><span>
</span><span id="line-550"></span><span>      </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-special">(</span><span id="local-6989586621679224048"><span class="annot"><a href="#local-6989586621679224048"><span class="hs-identifier hs-var">h</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679224049"><span class="annot"><a href="#local-6989586621679224049"><span class="hs-identifier hs-var">sM</span></a></span></span><span class="hs-special">)</span><span class="hs-special">,</span><span id="local-6989586621679224050"><span class="annot"><a href="#local-6989586621679224050"><span class="hs-identifier hs-var">corr</span></a></span></span><span class="hs-special">)</span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span class="annot"><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[((Type, Maybe (Type, Maybe Coercion)), Symbol DFunId CType)]
-&gt; MaybeT
     TcPluginM
     [((Type, Maybe (Type, Maybe Coercion)), Symbol DFunId CType)]
forall a. a -&gt; MaybeT TcPluginM a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">[((Type, Maybe (Type, Maybe Coercion)), Symbol DFunId CType)]
forall {c}.
[((Type, Maybe (Type, Maybe Coercion)), Symbol DFunId c)]
</span><a href="#local-6989586621679224046"><span class="hs-identifier hs-var">interesting</span></a></span><span>
</span><span id="line-551"></span><span>      </span><span id="local-6989586621679224051"><span class="annot"><a href="#local-6989586621679224051"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><a href="#local-6989586621679224050"><span class="hs-identifier hs-type">corr</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-552"></span><span>                </span><span class="annot"><span class="hs-identifier hs-type">I</span></span><span> </span><span class="annot"><span class="annottext">Integer
</span><span class="hs-number">0</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Type, Maybe Coercion) -&gt; MaybeT TcPluginM (Type, Maybe Coercion)
forall a. a -&gt; MaybeT TcPluginM a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Type, Maybe Coercion)
-&gt; Maybe (Type, Maybe Coercion) -&gt; (Type, Maybe Coercion)
forall a. a -&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224048"><span class="hs-identifier hs-var">h</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Maybe Coercion
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Maybe (Type, Maybe Coercion)
</span><a href="#local-6989586621679224049"><span class="hs-identifier hs-var">sM</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-553"></span><span>                </span><span class="annot"><span class="hs-identifier hs-type">I</span></span><span> </span><span id="local-6989586621679224052"><span class="annot"><span class="annottext">Integer
</span><a href="#local-6989586621679224052"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Integer
</span><a href="#local-6989586621679224052"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">Integer -&gt; Integer -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&lt;</span></span><span> </span><span class="annot"><span class="annottext">Integer
</span><span class="hs-number">0</span></span><span>
</span><span id="line-554"></span><span>                    </span><span class="hs-special">,</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679224055"><span class="annot"><span class="annottext">l1 :: Type
</span><a href="#local-6989586621679224055"><span class="hs-identifier hs-var hs-var">l1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Integer -&gt; Type
</span><span class="hs-identifier hs-var">mkNumLitTy</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Integer -&gt; Integer
forall a. Num a =&gt; a -&gt; a
</span><span class="hs-identifier hs-var">negate</span></span><span> </span><span class="annot"><span class="annottext">Integer
</span><a href="#local-6989586621679224052"><span class="hs-identifier hs-var">i</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-555"></span><span>                    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Maybe (Type, Maybe Coercion)
</span><a href="#local-6989586621679224049"><span class="hs-identifier hs-var">sM</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-556"></span><span>                        </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679224056"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224056"><span class="hs-identifier hs-var">q</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679224057"><span class="annot"><span class="annottext">Maybe Coercion
</span><a href="#local-6989586621679224057"><span class="hs-identifier hs-var">cM</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Type, Maybe Coercion) -&gt; MaybeT TcPluginM (Type, Maybe Coercion)
forall a. a -&gt; MaybeT TcPluginM a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span>
</span><span id="line-557"></span><span>                          </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="annottext">TyCon -&gt; [Type] -&gt; Type
</span><span class="hs-identifier hs-var">mkTyConApp</span></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><span class="hs-identifier hs-var">typeNatAddTyCon</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224056"><span class="hs-identifier hs-var">q</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224055"><span class="hs-identifier hs-var">l1</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-558"></span><span>                          </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(Coercion -&gt; Coercion) -&gt; Maybe Coercion -&gt; Maybe Coercion
forall a b. (a -&gt; b) -&gt; Maybe a -&gt; Maybe b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">HasDebugCallStack =&gt; Role -&gt; TyCon -&gt; [Coercion] -&gt; Coercion
Role -&gt; TyCon -&gt; [Coercion] -&gt; Coercion
</span><span class="hs-identifier hs-var">mkTyConAppCo</span></span><span> </span><span class="annot"><span class="annottext">Role
</span><span class="hs-identifier hs-var">Nominal</span></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><span class="hs-identifier hs-var">typeNatAddTyCon</span></span><span> </span><span class="annot"><span class="annottext">([Coercion] -&gt; Coercion)
-&gt; (Coercion -&gt; [Coercion]) -&gt; Coercion -&gt; Coercion
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Coercion -&gt; [Coercion] -&gt; [Coercion]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="hs-special">[</span><span class="annot"><span class="annottext">Type -&gt; Coercion
</span><span class="hs-identifier hs-var">mkNomReflCo</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224055"><span class="hs-identifier hs-var">l1</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Maybe Coercion
</span><a href="#local-6989586621679224057"><span class="hs-identifier hs-var">cM</span></a></span><span>
</span><span id="line-559"></span><span>                          </span><span class="hs-special">)</span><span>
</span><span id="line-560"></span><span>                        </span><span class="annot"><span class="annottext">Maybe (Type, Maybe Coercion)
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Type, Maybe Coercion) -&gt; MaybeT TcPluginM (Type, Maybe Coercion)
forall a. a -&gt; MaybeT TcPluginM a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span>
</span><span id="line-561"></span><span>                          </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="annottext">TyCon -&gt; [Type] -&gt; Type
</span><span class="hs-identifier hs-var">mkTyConApp</span></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><span class="hs-identifier hs-var">typeNatAddTyCon</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224048"><span class="hs-identifier hs-var">h</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224055"><span class="hs-identifier hs-var">l1</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-562"></span><span>                          </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Maybe Coercion
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-563"></span><span>                          </span><span class="hs-special">)</span><span>
</span><span id="line-564"></span><span>                    </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-565"></span><span>                    </span><span class="hs-special">,</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679224058"><span class="annot"><span class="annottext">l1 :: Type
</span><a href="#local-6989586621679224058"><span class="hs-identifier hs-var hs-var">l1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Integer -&gt; Type
</span><span class="hs-identifier hs-var">mkNumLitTy</span></span><span> </span><span class="annot"><span class="annottext">Integer
</span><a href="#local-6989586621679224052"><span class="hs-identifier hs-var">i</span></a></span><span>
</span><span id="line-566"></span><span>                    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Maybe (Type, Maybe Coercion)
</span><a href="#local-6989586621679224049"><span class="hs-identifier hs-var">sM</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-567"></span><span>                        </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679224059"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224059"><span class="hs-identifier hs-var">q</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679224060"><span class="annot"><span class="annottext">Maybe Coercion
</span><a href="#local-6989586621679224060"><span class="hs-identifier hs-var">cM</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Type, Maybe Coercion) -&gt; MaybeT TcPluginM (Type, Maybe Coercion)
forall a. a -&gt; MaybeT TcPluginM a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span>
</span><span id="line-568"></span><span>                          </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="annottext">TyCon -&gt; [Type] -&gt; Type
</span><span class="hs-identifier hs-var">mkTyConApp</span></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><span class="hs-identifier hs-var">typeNatSubTyCon</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224059"><span class="hs-identifier hs-var">q</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224058"><span class="hs-identifier hs-var">l1</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-569"></span><span>                          </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(Coercion -&gt; Coercion) -&gt; Maybe Coercion -&gt; Maybe Coercion
forall a b. (a -&gt; b) -&gt; Maybe a -&gt; Maybe b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">HasDebugCallStack =&gt; Role -&gt; TyCon -&gt; [Coercion] -&gt; Coercion
Role -&gt; TyCon -&gt; [Coercion] -&gt; Coercion
</span><span class="hs-identifier hs-var">mkTyConAppCo</span></span><span> </span><span class="annot"><span class="annottext">Role
</span><span class="hs-identifier hs-var">Nominal</span></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><span class="hs-identifier hs-var">typeNatSubTyCon</span></span><span> </span><span class="annot"><span class="annottext">([Coercion] -&gt; Coercion)
-&gt; (Coercion -&gt; [Coercion]) -&gt; Coercion -&gt; Coercion
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Coercion -&gt; [Coercion] -&gt; [Coercion]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="hs-special">[</span><span class="annot"><span class="annottext">Type -&gt; Coercion
</span><span class="hs-identifier hs-var">mkNomReflCo</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224058"><span class="hs-identifier hs-var">l1</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Maybe Coercion
</span><a href="#local-6989586621679224060"><span class="hs-identifier hs-var">cM</span></a></span><span>
</span><span id="line-570"></span><span>                          </span><span class="hs-special">)</span><span>
</span><span id="line-571"></span><span>                        </span><span class="annot"><span class="annottext">Maybe (Type, Maybe Coercion)
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Type, Maybe Coercion) -&gt; MaybeT TcPluginM (Type, Maybe Coercion)
forall a. a -&gt; MaybeT TcPluginM a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span>
</span><span id="line-572"></span><span>                          </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="annottext">TyCon -&gt; [Type] -&gt; Type
</span><span class="hs-identifier hs-var">mkTyConApp</span></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><span class="hs-identifier hs-var">typeNatSubTyCon</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224048"><span class="hs-identifier hs-var">h</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224058"><span class="hs-identifier hs-var">l1</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-573"></span><span>                          </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Maybe Coercion
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-574"></span><span>                          </span><span class="hs-special">)</span><span>
</span><span id="line-575"></span><span>                </span><span class="hs-comment">-- If the offset between a given and a wanted is again the wanted</span><span>
</span><span id="line-576"></span><span>                </span><span class="hs-comment">-- then the given is twice the wanted; so we can just divide</span><span>
</span><span id="line-577"></span><span>                </span><span class="hs-comment">-- the given by two. Only possible in GHC 8.4+; for 8.2 we simply</span><span>
</span><span id="line-578"></span><span>                </span><span class="hs-comment">-- fail because we don't know how to divide.</span><span>
</span><span id="line-579"></span><span>                </span><span id="local-6989586621679224061"><span class="annot"><span class="annottext">Symbol DFunId CType
</span><a href="#local-6989586621679224061"><span class="hs-identifier hs-var">c</span></a></span></span><span>   </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Type -&gt; CType
</span><span class="hs-identifier hs-var">CType</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CoreSOP -&gt; Type
</span><span class="hs-identifier hs-var">reifySOP</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Product DFunId CType] -&gt; CoreSOP
forall v c. [Product v c] -&gt; SOP v c
</span><span class="hs-identifier hs-var">S</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">[Symbol DFunId CType] -&gt; Product DFunId CType
forall v c. [Symbol v c] -&gt; Product v c
</span><span class="hs-identifier hs-var">P</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Symbol DFunId CType
</span><a href="#local-6989586621679224061"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">]</span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">CType -&gt; CType -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; CType
</span><span class="hs-identifier hs-var">CType</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224006"><span class="hs-identifier hs-var">want</span></a></span><span>
</span><span id="line-580"></span><span>                    </span><span class="hs-special">,</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679224062"><span class="annot"><span class="annottext">l2 :: Type
</span><a href="#local-6989586621679224062"><span class="hs-identifier hs-var hs-var">l2</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Integer -&gt; Type
</span><span class="hs-identifier hs-var">mkNumLitTy</span></span><span> </span><span class="annot"><span class="annottext">Integer
</span><span class="hs-number">2</span></span><span>
</span><span id="line-581"></span><span>                    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Maybe (Type, Maybe Coercion)
</span><a href="#local-6989586621679224049"><span class="hs-identifier hs-var">sM</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-582"></span><span>                        </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679224063"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224063"><span class="hs-identifier hs-var">q</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679224064"><span class="annot"><span class="annottext">Maybe Coercion
</span><a href="#local-6989586621679224064"><span class="hs-identifier hs-var">cM</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Type, Maybe Coercion) -&gt; MaybeT TcPluginM (Type, Maybe Coercion)
forall a. a -&gt; MaybeT TcPluginM a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span>
</span><span id="line-583"></span><span>                          </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="annottext">TyCon -&gt; [Type] -&gt; Type
</span><span class="hs-identifier hs-var">mkTyConApp</span></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><span class="hs-identifier hs-var">typeNatDivTyCon</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224063"><span class="hs-identifier hs-var">q</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224062"><span class="hs-identifier hs-var">l2</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-584"></span><span>                          </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(Coercion -&gt; Coercion) -&gt; Maybe Coercion -&gt; Maybe Coercion
forall a b. (a -&gt; b) -&gt; Maybe a -&gt; Maybe b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">HasDebugCallStack =&gt; Role -&gt; TyCon -&gt; [Coercion] -&gt; Coercion
Role -&gt; TyCon -&gt; [Coercion] -&gt; Coercion
</span><span class="hs-identifier hs-var">mkTyConAppCo</span></span><span> </span><span class="annot"><span class="annottext">Role
</span><span class="hs-identifier hs-var">Nominal</span></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><span class="hs-identifier hs-var">typeNatDivTyCon</span></span><span> </span><span class="annot"><span class="annottext">([Coercion] -&gt; Coercion)
-&gt; (Coercion -&gt; [Coercion]) -&gt; Coercion -&gt; Coercion
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Coercion -&gt; [Coercion] -&gt; [Coercion]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="hs-special">[</span><span class="annot"><span class="annottext">Type -&gt; Coercion
</span><span class="hs-identifier hs-var">mkNomReflCo</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224062"><span class="hs-identifier hs-var">l2</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Maybe Coercion
</span><a href="#local-6989586621679224064"><span class="hs-identifier hs-var">cM</span></a></span><span>
</span><span id="line-585"></span><span>                          </span><span class="hs-special">)</span><span>
</span><span id="line-586"></span><span>                        </span><span class="annot"><span class="annottext">Maybe (Type, Maybe Coercion)
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Type, Maybe Coercion) -&gt; MaybeT TcPluginM (Type, Maybe Coercion)
forall a. a -&gt; MaybeT TcPluginM a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span>
</span><span id="line-587"></span><span>                          </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="annottext">TyCon -&gt; [Type] -&gt; Type
</span><span class="hs-identifier hs-var">mkTyConApp</span></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><span class="hs-identifier hs-var">typeNatDivTyCon</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224048"><span class="hs-identifier hs-var">h</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224062"><span class="hs-identifier hs-var">l2</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-588"></span><span>                          </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Maybe Coercion
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-589"></span><span>                          </span><span class="hs-special">)</span><span>
</span><span id="line-590"></span><span>                </span><span class="hs-comment">-- Only solve with a variable offset if we have [G]iven knownnat for it</span><span>
</span><span id="line-591"></span><span>                </span><span class="hs-comment">-- Failing to do this check results in #30</span><span>
</span><span id="line-592"></span><span>                </span><span class="annot"><span class="hs-identifier hs-type">V</span></span><span> </span><span id="local-6989586621679224065"><span class="annot"><span class="annottext">DFunId
</span><a href="#local-6989586621679224065"><span class="hs-identifier hs-var">v</span></a></span></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">((Type, Maybe (Type, Maybe Coercion)) -&gt; Bool)
-&gt; [(Type, Maybe (Type, Maybe Coercion))] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">all</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="annot"><span class="annottext">(Bool -&gt; Bool)
-&gt; ((Type, Maybe (Type, Maybe Coercion)) -&gt; Bool)
-&gt; (Type, Maybe (Type, Maybe Coercion))
-&gt; Bool
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Bool
</span><span class="hs-identifier hs-var">eqType</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DFunId -&gt; Type
</span><span class="hs-identifier hs-var">TyVarTy</span></span><span> </span><span class="annot"><span class="annottext">DFunId
</span><a href="#local-6989586621679224065"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Bool)
-&gt; ((Type, Maybe (Type, Maybe Coercion)) -&gt; Type)
-&gt; (Type, Maybe (Type, Maybe Coercion))
-&gt; Bool
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(Type, Maybe (Type, Maybe Coercion)) -&gt; Type
forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[(Type, Maybe (Type, Maybe Coercion))]
</span><a href="#local-6989586621679224031"><span class="hs-identifier hs-var">knownsX</span></a></span><span>
</span><span id="line-593"></span><span>                     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">TcPluginM (Maybe (Type, Maybe Coercion))
-&gt; MaybeT TcPluginM (Type, Maybe Coercion)
forall (m :: * -&gt; *) a. m (Maybe a) -&gt; MaybeT m a
</span><span class="hs-identifier hs-var">MaybeT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe (Type, Maybe Coercion)
-&gt; TcPluginM (Maybe (Type, Maybe Coercion))
forall a. a -&gt; TcPluginM a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Type, Maybe Coercion)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">)</span><span>
</span><span id="line-594"></span><span>                </span><span class="annot"><span class="annottext">Symbol DFunId CType
</span><span class="hs-identifier">_</span></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679224070"><span class="annot"><span class="annottext">lC :: Type
</span><a href="#local-6989586621679224070"><span class="hs-identifier hs-var hs-var">lC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CoreSOP -&gt; Type
</span><span class="hs-identifier hs-var">reifySOP</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Product DFunId CType] -&gt; CoreSOP
forall v c. [Product v c] -&gt; SOP v c
</span><span class="hs-identifier hs-var">S</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">[Symbol DFunId CType] -&gt; Product DFunId CType
forall v c. [Symbol v c] -&gt; Product v c
</span><span class="hs-identifier hs-var">P</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Symbol DFunId CType
</span><a href="#local-6989586621679224050"><span class="hs-identifier hs-var">corr</span></a></span><span class="hs-special">]</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-keyword">in</span><span>
</span><span id="line-595"></span><span>                        </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Maybe (Type, Maybe Coercion)
</span><a href="#local-6989586621679224049"><span class="hs-identifier hs-var">sM</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-596"></span><span>                          </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679224071"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224071"><span class="hs-identifier hs-var">q</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679224072"><span class="annot"><span class="annottext">Maybe Coercion
</span><a href="#local-6989586621679224072"><span class="hs-identifier hs-var">cM</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Type, Maybe Coercion) -&gt; MaybeT TcPluginM (Type, Maybe Coercion)
forall a. a -&gt; MaybeT TcPluginM a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span>
</span><span id="line-597"></span><span>                            </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="annottext">TyCon -&gt; [Type] -&gt; Type
</span><span class="hs-identifier hs-var">mkTyConApp</span></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><span class="hs-identifier hs-var">typeNatSubTyCon</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224071"><span class="hs-identifier hs-var">q</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224070"><span class="hs-identifier hs-var">lC</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-598"></span><span>                            </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(Coercion -&gt; Coercion) -&gt; Maybe Coercion -&gt; Maybe Coercion
forall a b. (a -&gt; b) -&gt; Maybe a -&gt; Maybe b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">HasDebugCallStack =&gt; Role -&gt; TyCon -&gt; [Coercion] -&gt; Coercion
Role -&gt; TyCon -&gt; [Coercion] -&gt; Coercion
</span><span class="hs-identifier hs-var">mkTyConAppCo</span></span><span> </span><span class="annot"><span class="annottext">Role
</span><span class="hs-identifier hs-var">Nominal</span></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><span class="hs-identifier hs-var">typeNatSubTyCon</span></span><span> </span><span class="annot"><span class="annottext">([Coercion] -&gt; Coercion)
-&gt; (Coercion -&gt; [Coercion]) -&gt; Coercion -&gt; Coercion
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Coercion -&gt; [Coercion] -&gt; [Coercion]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="hs-special">[</span><span class="annot"><span class="annottext">Type -&gt; Coercion
</span><span class="hs-identifier hs-var">mkNomReflCo</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224070"><span class="hs-identifier hs-var">lC</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Maybe Coercion
</span><a href="#local-6989586621679224072"><span class="hs-identifier hs-var">cM</span></a></span><span>
</span><span id="line-599"></span><span>                            </span><span class="hs-special">)</span><span>
</span><span id="line-600"></span><span>                          </span><span class="annot"><span class="annottext">Maybe (Type, Maybe Coercion)
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Type, Maybe Coercion) -&gt; MaybeT TcPluginM (Type, Maybe Coercion)
forall a. a -&gt; MaybeT TcPluginM a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span>
</span><span id="line-601"></span><span>                            </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="annottext">TyCon -&gt; [Type] -&gt; Type
</span><span class="hs-identifier hs-var">mkTyConApp</span></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><span class="hs-identifier hs-var">typeNatSubTyCon</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224048"><span class="hs-identifier hs-var">h</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224070"><span class="hs-identifier hs-var">lC</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-602"></span><span>                            </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Maybe Coercion
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-603"></span><span>                            </span><span class="hs-special">)</span><span>
</span><span id="line-604"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">MaybeT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679223920"><span class="hs-identifier hs-type">go</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679224051"><span class="hs-identifier hs-type">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-605"></span><span>
</span><span id="line-606"></span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#makeWantedEv"><span class="hs-identifier hs-type">makeWantedEv</span></a></span><span>
</span><span id="line-607"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ct</span></span><span>
</span><span id="line-608"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-609"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TcPluginM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">EvExpr</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Ct</span></span><span class="hs-special">)</span><span>
</span><span id="line-610"></span><span id="makeWantedEv"><span class="annot"><span class="annottext">makeWantedEv :: Ct -&gt; Type -&gt; TcPluginM (EvExpr, Ct)
</span><a href="GHC.TypeLits.KnownNat.Solver.html#makeWantedEv"><span class="hs-identifier hs-var hs-var">makeWantedEv</span></a></span></span><span> </span><span id="local-6989586621679224073"><span class="annot"><span class="annottext">Ct
</span><a href="#local-6989586621679224073"><span class="hs-identifier hs-var">ct</span></a></span></span><span> </span><span id="local-6989586621679224074"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224074"><span class="hs-identifier hs-var">ty</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-611"></span><span>  </span><span class="hs-comment">-- Create a new wanted constraint</span><span>
</span><span id="line-612"></span><span>  </span><span id="local-6989586621679224075"><span class="annot"><a href="#local-6989586621679224075"><span class="hs-identifier hs-var">wantedCtEv</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">CtLoc -&gt; Type -&gt; TcPluginM CtEvidence
</span><span class="hs-identifier hs-var">newWanted</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Ct -&gt; CtLoc
</span><span class="hs-identifier hs-var">ctLoc</span></span><span> </span><span class="annot"><span class="annottext">Ct
</span><a href="#local-6989586621679224073"><span class="hs-identifier hs-var">ct</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224074"><span class="hs-identifier hs-var">ty</span></a></span><span>
</span><span id="line-613"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679224077"><span class="annot"><a href="#local-6989586621679224077"><span class="hs-identifier hs-var hs-var">ev</span></a></span></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">HasDebugCallStack =&gt; CtEvidence -&gt; EvExpr
CtEvidence -&gt; EvExpr
</span><span class="hs-identifier hs-var">ctEvExpr</span></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621679224075"><span class="hs-identifier hs-var">wantedCtEv</span></a></span><span>
</span><span id="line-614"></span><span>      </span><span id="local-6989586621679224078"><span class="annot"><a href="#local-6989586621679224078"><span class="hs-identifier hs-var hs-var">wanted</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; Ct
</span><span class="hs-identifier hs-var">mkNonCanonical</span></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621679224075"><span class="hs-identifier hs-var">wantedCtEv</span></a></span><span>
</span><span id="line-615"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679224077"><span class="hs-identifier hs-type">ev</span></a></span><span class="hs-special">,</span><span class="annot"><a href="#local-6989586621679224078"><span class="hs-identifier hs-type">wanted</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-616"></span><span>
</span><span id="line-617"></span><span class="annot"><span class="hs-comment">{- |
Given:

* A &quot;magic&quot; class, and corresponding instance dictionary function, for a
  type-level arithmetic operation
* Two KnownNat dictionaries

makeOpDict instantiates the dictionary function with the KnownNat dictionaries,
and coerces it to a KnownNat dictionary. i.e. for KnownNat2, the &quot;magic&quot;
dictionary for binary functions, the coercion happens in the following steps:

1. KnownNat2 &quot;+&quot; a b           -&gt; SNatKn (KnownNatF2 &quot;+&quot; a b)
2. SNatKn (KnownNatF2 &quot;+&quot; a b) -&gt; Integer
3. Integer                     -&gt; SNat (a + b)
4. SNat (a + b)                -&gt; KnownNat (a + b)

this process is mirrored for the dictionary functions of a higher arity
-}</span></span><span>
</span><span id="line-635"></span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#makeOpDict"><span class="hs-identifier hs-type">makeOpDict</span></a></span><span>
</span><span id="line-636"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Class</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">DFunId</span></span><span class="hs-special">)</span><span>
</span><span id="line-637"></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ &quot;magic&quot; class function and dictionary function id</span></span><span>
</span><span id="line-638"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Class</span></span><span>
</span><span id="line-639"></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ KnownNat class</span></span><span>
</span><span id="line-640"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span>
</span><span id="line-641"></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ Argument types for the Class</span></span><span>
</span><span id="line-642"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span>
</span><span id="line-643"></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ Argument types for the Instance</span></span><span>
</span><span id="line-644"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-645"></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ Type of the result</span></span><span>
</span><span id="line-646"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">EvExpr</span></span><span class="hs-special">]</span><span>
</span><span id="line-647"></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ Evidence arguments</span></span><span>
</span><span id="line-648"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Coercion</span></span><span class="hs-special">)</span><span>
</span><span id="line-649"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">EvTerm</span></span><span>
</span><span id="line-650"></span><span id="makeOpDict"><span class="annot"><span class="annottext">makeOpDict :: (Class, DFunId)
-&gt; Class
-&gt; [Type]
-&gt; [Type]
-&gt; Type
-&gt; [EvExpr]
-&gt; Maybe (Type, Coercion)
-&gt; Maybe EvTerm
</span><a href="GHC.TypeLits.KnownNat.Solver.html#makeOpDict"><span class="hs-identifier hs-var hs-var">makeOpDict</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679224079"><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679224079"><span class="hs-identifier hs-var">opCls</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679224080"><span class="annot"><span class="annottext">DFunId
</span><a href="#local-6989586621679224080"><span class="hs-identifier hs-var">dfid</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679224081"><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679224081"><span class="hs-identifier hs-var">knCls</span></a></span></span><span> </span><span id="local-6989586621679224082"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679224082"><span class="hs-identifier hs-var">tyArgsC</span></a></span></span><span> </span><span id="local-6989586621679224083"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679224083"><span class="hs-identifier hs-var">tyArgsI</span></a></span></span><span> </span><span id="local-6989586621679224084"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224084"><span class="hs-identifier hs-var">z</span></a></span></span><span> </span><span id="local-6989586621679224085"><span class="annot"><span class="annottext">[EvExpr]
</span><a href="#local-6989586621679224085"><span class="hs-identifier hs-var">evArgs</span></a></span></span><span> </span><span id="local-6989586621679224086"><span class="annot"><span class="annottext">Maybe (Type, Coercion)
</span><a href="#local-6989586621679224086"><span class="hs-identifier hs-var">sM</span></a></span></span><span>
</span><span id="line-651"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679224087"><span class="annot"><span class="annottext">z1 :: Type
</span><a href="#local-6989586621679224087"><span class="hs-identifier hs-var hs-var">z1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type
-&gt; ((Type, Coercion) -&gt; Type) -&gt; Maybe (Type, Coercion) -&gt; Type
forall b a. b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b
</span><span class="hs-identifier hs-var">maybe</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224084"><span class="hs-identifier hs-var">z</span></a></span><span> </span><span class="annot"><span class="annottext">(Type, Coercion) -&gt; Type
forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Type, Coercion)
</span><a href="#local-6989586621679224086"><span class="hs-identifier hs-var">sM</span></a></span><span>
</span><span id="line-652"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679224088"><span class="annot"><span class="annottext">Coercion
</span><a href="#local-6989586621679224088"><span class="hs-identifier hs-var">kn_co_dict</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">TyCon -&gt; [Type] -&gt; Maybe (Type, Coercion)
</span><span class="hs-identifier hs-var">tcInstNewTyCon_maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Class -&gt; TyCon
</span><span class="hs-identifier hs-var">classTyCon</span></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679224081"><span class="hs-identifier hs-var">knCls</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224087"><span class="hs-identifier hs-var">z1</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-653"></span><span>    </span><span class="hs-comment">-- KnownNat n ~ SNat n</span><span>
</span><span id="line-654"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span> </span><span id="local-6989586621679224089"><span class="annot"><span class="annottext">DFunId
</span><a href="#local-6989586621679224089"><span class="hs-identifier hs-var">kn_meth</span></a></span></span><span> </span><span class="hs-special">]</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Class -&gt; [DFunId]
</span><span class="hs-identifier hs-var">classMethods</span></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679224081"><span class="hs-identifier hs-var">knCls</span></a></span><span>
</span><span id="line-655"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679224090"><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621679224090"><span class="hs-identifier hs-var">kn_tcRep</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Maybe TyCon
</span><span class="hs-identifier hs-var">tyConAppTyCon_maybe</span></span><span> </span><span class="hs-comment">-- SNat</span><span>
</span><span id="line-656"></span><span>                      </span><span class="annot"><span class="annottext">(Type -&gt; Maybe TyCon) -&gt; Type -&gt; Maybe TyCon
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">HasDebugCallStack =&gt; Type -&gt; Type
Type -&gt; Type
</span><span class="hs-identifier hs-var">funResultTy</span></span><span>      </span><span class="hs-comment">-- SNat n</span><span>
</span><span id="line-657"></span><span>                      </span><span class="annot"><span class="annottext">(Type -&gt; Type) -&gt; Type -&gt; Type
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type
</span><span class="hs-identifier hs-var">dropForAlls</span></span><span>      </span><span class="hs-comment">-- KnownNat n =&gt; SNat n</span><span>
</span><span id="line-658"></span><span>                      </span><span class="annot"><span class="annottext">(Type -&gt; Type) -&gt; Type -&gt; Type
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">DFunId -&gt; Type
</span><span class="hs-identifier hs-var">idType</span></span><span> </span><span class="annot"><span class="annottext">DFunId
</span><a href="#local-6989586621679224089"><span class="hs-identifier hs-var">kn_meth</span></a></span><span>   </span><span class="hs-comment">-- forall n. KnownNat n =&gt; SNat n</span><span>
</span><span id="line-659"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679224091"><span class="annot"><span class="annottext">Coercion
</span><a href="#local-6989586621679224091"><span class="hs-identifier hs-var">kn_co_rep</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">TyCon -&gt; [Type] -&gt; Maybe (Type, Coercion)
</span><span class="hs-identifier hs-var">tcInstNewTyCon_maybe</span></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621679224090"><span class="hs-identifier hs-var">kn_tcRep</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224087"><span class="hs-identifier hs-var">z1</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-660"></span><span>    </span><span class="hs-comment">-- SNat n ~ Integer</span><span>
</span><span id="line-661"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679224092"><span class="annot"><span class="annottext">Coercion
</span><a href="#local-6989586621679224092"><span class="hs-identifier hs-var">op_co_dict</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">TyCon -&gt; [Type] -&gt; Maybe (Type, Coercion)
</span><span class="hs-identifier hs-var">tcInstNewTyCon_maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Class -&gt; TyCon
</span><span class="hs-identifier hs-var">classTyCon</span></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679224079"><span class="hs-identifier hs-var">opCls</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679224082"><span class="hs-identifier hs-var">tyArgsC</span></a></span><span>
</span><span id="line-662"></span><span>    </span><span class="hs-comment">-- KnownNatAdd a b ~ SNatKn (a+b)</span><span>
</span><span id="line-663"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span> </span><span id="local-6989586621679224093"><span class="annot"><span class="annottext">DFunId
</span><a href="#local-6989586621679224093"><span class="hs-identifier hs-var">op_meth</span></a></span></span><span> </span><span class="hs-special">]</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Class -&gt; [DFunId]
</span><span class="hs-identifier hs-var">classMethods</span></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679224079"><span class="hs-identifier hs-var">opCls</span></a></span><span>
</span><span id="line-664"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679224094"><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621679224094"><span class="hs-identifier hs-var">op_tcRep</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679224095"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679224095"><span class="hs-identifier hs-var">op_args</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">HasDebugCallStack =&gt; Type -&gt; Maybe (TyCon, [Type])
Type -&gt; Maybe (TyCon, [Type])
</span><span class="hs-identifier hs-var">splitTyConApp_maybe</span></span><span>        </span><span class="hs-comment">-- (SNatKn, [KnownNatF2 f x y])</span><span>
</span><span id="line-665"></span><span>                                 </span><span class="annot"><span class="annottext">(Type -&gt; Maybe (TyCon, [Type])) -&gt; Type -&gt; Maybe (TyCon, [Type])
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">HasDebugCallStack =&gt; Type -&gt; Type
Type -&gt; Type
</span><span class="hs-identifier hs-var">funResultTy</span></span><span>            </span><span class="hs-comment">-- SNatKn (KnownNatF2 f x y)</span><span>
</span><span id="line-666"></span><span>                                 </span><span class="annot"><span class="annottext">(Type -&gt; Type) -&gt; Type -&gt; Type
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">HasDebugCallStack =&gt; Type -&gt; [Type] -&gt; Type
Type -&gt; [Type] -&gt; Type
</span><span class="hs-operator hs-var">`piResultTys`</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679224082"><span class="hs-identifier hs-var">tyArgsC</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- KnownNatAdd f x y =&gt; SNatKn (KnownNatF2 f x y)</span><span>
</span><span id="line-667"></span><span>                                 </span><span class="annot"><span class="annottext">(Type -&gt; Type) -&gt; Type -&gt; Type
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">DFunId -&gt; Type
</span><span class="hs-identifier hs-var">idType</span></span><span> </span><span class="annot"><span class="annottext">DFunId
</span><a href="#local-6989586621679224093"><span class="hs-identifier hs-var">op_meth</span></a></span><span>         </span><span class="hs-comment">-- forall f a b . KnownNat2 f a b =&gt; SNatKn (KnownNatF2 f a b)</span><span>
</span><span id="line-668"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679224096"><span class="annot"><span class="annottext">Coercion
</span><a href="#local-6989586621679224096"><span class="hs-identifier hs-var">op_co_rep</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">TyCon -&gt; [Type] -&gt; Maybe (Type, Coercion)
</span><span class="hs-identifier hs-var">tcInstNewTyCon_maybe</span></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621679224094"><span class="hs-identifier hs-var">op_tcRep</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679224095"><span class="hs-identifier hs-var">op_args</span></a></span><span>
</span><span id="line-669"></span><span>    </span><span class="hs-comment">-- SNatKn (a+b) ~ Integer</span><span>
</span><span id="line-670"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">EvExpr</span></span><span> </span><span id="local-6989586621679224097"><span class="annot"><span class="annottext">EvExpr
</span><a href="#local-6989586621679224097"><span class="hs-identifier hs-var">dfun_inst</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">DFunId -&gt; [Type] -&gt; [EvExpr] -&gt; EvTerm
</span><span class="hs-identifier hs-var">evDFunApp</span></span><span> </span><span class="annot"><span class="annottext">DFunId
</span><a href="#local-6989586621679224080"><span class="hs-identifier hs-var">dfid</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679224083"><span class="hs-identifier hs-var">tyArgsI</span></a></span><span> </span><span class="annot"><span class="annottext">[EvExpr]
</span><a href="#local-6989586621679224085"><span class="hs-identifier hs-var">evArgs</span></a></span><span>
</span><span id="line-671"></span><span>        </span><span class="hs-comment">-- KnownNatAdd a b</span><span>
</span><span id="line-672"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679224098"><span class="annot"><span class="annottext">op_to_kn :: Coercion
</span><a href="#local-6989586621679224098"><span class="hs-identifier hs-var hs-var">op_to_kn</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Coercion -&gt; Coercion -&gt; Coercion
</span><a href="GHC.TypeLits.KnownNat.Solver.html#mkTcTransCo"><span class="hs-identifier hs-var">mkTcTransCo</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Coercion -&gt; Coercion -&gt; Coercion
</span><a href="GHC.TypeLits.KnownNat.Solver.html#mkTcTransCo"><span class="hs-identifier hs-var">mkTcTransCo</span></a></span><span> </span><span class="annot"><span class="annottext">Coercion
</span><a href="#local-6989586621679224092"><span class="hs-identifier hs-var">op_co_dict</span></a></span><span> </span><span class="annot"><span class="annottext">Coercion
</span><a href="#local-6989586621679224096"><span class="hs-identifier hs-var">op_co_rep</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-673"></span><span>                                </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Coercion -&gt; Coercion
</span><a href="GHC.TypeLits.KnownNat.Solver.html#mkTcSymCo"><span class="hs-identifier hs-var">mkTcSymCo</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Coercion -&gt; Coercion -&gt; Coercion
</span><a href="GHC.TypeLits.KnownNat.Solver.html#mkTcTransCo"><span class="hs-identifier hs-var">mkTcTransCo</span></a></span><span> </span><span class="annot"><span class="annottext">Coercion
</span><a href="#local-6989586621679224088"><span class="hs-identifier hs-var">kn_co_dict</span></a></span><span> </span><span class="annot"><span class="annottext">Coercion
</span><a href="#local-6989586621679224091"><span class="hs-identifier hs-var">kn_co_rep</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-674"></span><span>        </span><span class="hs-comment">-- KnownNatAdd a b ~ KnownNat (a+b)</span><span>
</span><span id="line-675"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679224099"><span class="annot"><span class="annottext">op_to_kn1 :: Coercion
</span><a href="#local-6989586621679224099"><span class="hs-identifier hs-var hs-var">op_to_kn1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Maybe (Type, Coercion)
</span><a href="#local-6989586621679224086"><span class="hs-identifier hs-var">sM</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-676"></span><span>          </span><span class="annot"><span class="annottext">Maybe (Type, Coercion)
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Coercion
</span><a href="#local-6989586621679224098"><span class="hs-identifier hs-var">op_to_kn</span></a></span><span>
</span><span id="line-677"></span><span>          </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span id="local-6989586621679224100"><span class="annot"><span class="annottext">Coercion
</span><a href="#local-6989586621679224100"><span class="hs-identifier hs-var">rw</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-678"></span><span>            </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679224102"><span class="annot"><span class="annottext">kn_co_rw :: Coercion
</span><a href="#local-6989586621679224102"><span class="hs-identifier hs-var hs-var">kn_co_rw</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">HasDebugCallStack =&gt; Role -&gt; TyCon -&gt; [Coercion] -&gt; Coercion
Role -&gt; TyCon -&gt; [Coercion] -&gt; Coercion
</span><span class="hs-identifier hs-var">mkTyConAppCo</span></span><span> </span><span class="annot"><span class="annottext">Role
</span><span class="hs-identifier hs-var">Representational</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Class -&gt; TyCon
</span><span class="hs-identifier hs-var">classTyCon</span></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679224081"><span class="hs-identifier hs-var">knCls</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Coercion
</span><a href="#local-6989586621679224100"><span class="hs-identifier hs-var">rw</span></a></span><span class="hs-special">]</span><span class="hs-cpp">
#if MIN_VERSION_ghc(9,11,0)
</span><span>                </span><span class="hs-identifier">kn_co_co</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">mkUnivCo</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">PluginProv</span><span> </span><span class="hs-string">&quot;ghc-typelits-knownnat&quot;</span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-cpp">
#else
</span><span>                </span><span id="local-6989586621679224103"><span class="annot"><span class="annottext">kn_co_co :: Coercion
</span><a href="#local-6989586621679224103"><span class="hs-identifier hs-var hs-var">kn_co_co</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">UnivCoProvenance -&gt; Role -&gt; Type -&gt; Type -&gt; Coercion
</span><span class="hs-identifier hs-var">mkUnivCo</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CommandLineOption -&gt; UnivCoProvenance
</span><span class="hs-identifier hs-var">PluginProv</span></span><span> </span><span class="annot"><span class="annottext">CommandLineOption
</span><span class="hs-string">&quot;ghc-typelits-knownnat&quot;</span></span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span>                            </span><span class="annot"><span class="annottext">Role
</span><span class="hs-identifier hs-var">Representational</span></span><span>
</span><span id="line-685"></span><span>                              </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Coercion -&gt; Type
</span><span class="hs-identifier hs-var">coercionRKind</span></span><span> </span><span class="annot"><span class="annottext">Coercion
</span><a href="#local-6989586621679224102"><span class="hs-identifier hs-var">kn_co_rw</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-686"></span><span>                              </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TyCon -&gt; [Type] -&gt; Type
</span><span class="hs-identifier hs-var">mkTyConApp</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Class -&gt; TyCon
</span><span class="hs-identifier hs-var">classTyCon</span></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679224081"><span class="hs-identifier hs-var">knCls</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224084"><span class="hs-identifier hs-var">z</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-687"></span><span>              </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Coercion -&gt; Coercion -&gt; Coercion
</span><a href="GHC.TypeLits.KnownNat.Solver.html#mkTcTransCo"><span class="hs-identifier hs-var">mkTcTransCo</span></a></span><span> </span><span class="annot"><span class="annottext">Coercion
</span><a href="#local-6989586621679224098"><span class="hs-identifier hs-var">op_to_kn</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Coercion -&gt; Coercion -&gt; Coercion
</span><a href="GHC.TypeLits.KnownNat.Solver.html#mkTcTransCo"><span class="hs-identifier hs-var">mkTcTransCo</span></a></span><span> </span><span class="annot"><span class="annottext">Coercion
</span><a href="#local-6989586621679224102"><span class="hs-identifier hs-var">kn_co_rw</span></a></span><span> </span><span class="annot"><span class="annottext">Coercion
</span><a href="#local-6989586621679224103"><span class="hs-identifier hs-var">kn_co_co</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-688"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679224104"><span class="annot"><span class="annottext">ev_tm :: EvTerm
</span><a href="#local-6989586621679224104"><span class="hs-identifier hs-var hs-var">ev_tm</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">EvExpr -&gt; Coercion -&gt; EvTerm
</span><span class="hs-identifier hs-var">mkEvCast</span></span><span> </span><span class="annot"><span class="annottext">EvExpr
</span><a href="#local-6989586621679224097"><span class="hs-identifier hs-var">dfun_inst</span></a></span><span> </span><span class="annot"><span class="annottext">Coercion
</span><a href="#local-6989586621679224099"><span class="hs-identifier hs-var">op_to_kn1</span></a></span><span>
</span><span id="line-689"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">EvTerm -&gt; Maybe EvTerm
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">EvTerm
</span><a href="#local-6989586621679224104"><span class="hs-identifier hs-var">ev_tm</span></a></span><span>
</span><span id="line-690"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-691"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe EvTerm
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-692"></span><span>
</span><span id="line-693"></span><span class="hs-comment">{-
Given:
* A KnownNat dictionary evidence over a type x
* a desired type z
makeKnCoercion assembles a coercion from a KnownNat x
dictionary to a KnownNat z dictionary and applies it
to the passed-in evidence.
The coercion happens in the following steps:
1. KnownNat x -&gt; SNat x
2. SNat x     -&gt; Integer
3. Integer    -&gt; SNat z
4. SNat z     -&gt; KnownNat z
-}</span><span>
</span><span id="line-706"></span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#makeKnCoercion"><span class="hs-identifier hs-type">makeKnCoercion</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Class</span></span><span>          </span><span class="annot"><span class="hs-comment">-- ^ KnownNat class</span></span><span>
</span><span id="line-707"></span><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>           </span><span class="annot"><span class="hs-comment">-- ^ Type of the argument</span></span><span>
</span><span id="line-708"></span><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>           </span><span class="annot"><span class="hs-comment">-- ^ Type of the result</span></span><span>
</span><span id="line-709"></span><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">EvExpr</span></span><span>
</span><span id="line-710"></span><span>               </span><span class="annot"><span class="hs-comment">-- ^ KnownNat dictionary for the argument</span></span><span>
</span><span id="line-711"></span><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">EvTerm</span></span><span>
</span><span id="line-712"></span><span id="makeKnCoercion"><span class="annot"><span class="annottext">makeKnCoercion :: Class -&gt; Type -&gt; Type -&gt; EvExpr -&gt; Maybe EvTerm
</span><a href="GHC.TypeLits.KnownNat.Solver.html#makeKnCoercion"><span class="hs-identifier hs-var hs-var">makeKnCoercion</span></a></span></span><span> </span><span id="local-6989586621679224105"><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679224105"><span class="hs-identifier hs-var">knCls</span></a></span></span><span> </span><span id="local-6989586621679224106"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224106"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679224107"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224107"><span class="hs-identifier hs-var">z</span></a></span></span><span> </span><span id="local-6989586621679224108"><span class="annot"><span class="annottext">EvExpr
</span><a href="#local-6989586621679224108"><span class="hs-identifier hs-var">xEv</span></a></span></span><span>
</span><span id="line-713"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679224109"><span class="annot"><span class="annottext">Coercion
</span><a href="#local-6989586621679224109"><span class="hs-identifier hs-var">kn_co_dict_z</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">TyCon -&gt; [Type] -&gt; Maybe (Type, Coercion)
</span><span class="hs-identifier hs-var">tcInstNewTyCon_maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Class -&gt; TyCon
</span><span class="hs-identifier hs-var">classTyCon</span></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679224105"><span class="hs-identifier hs-var">knCls</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224107"><span class="hs-identifier hs-var">z</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-714"></span><span>    </span><span class="hs-comment">-- KnownNat z ~ SNat z</span><span>
</span><span id="line-715"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span> </span><span id="local-6989586621679224110"><span class="annot"><span class="annottext">DFunId
</span><a href="#local-6989586621679224110"><span class="hs-identifier hs-var">kn_meth</span></a></span></span><span> </span><span class="hs-special">]</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Class -&gt; [DFunId]
</span><span class="hs-identifier hs-var">classMethods</span></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679224105"><span class="hs-identifier hs-var">knCls</span></a></span><span>
</span><span id="line-716"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679224111"><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621679224111"><span class="hs-identifier hs-var">kn_tcRep</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Maybe TyCon
</span><span class="hs-identifier hs-var">tyConAppTyCon_maybe</span></span><span> </span><span class="hs-comment">-- SNat</span><span>
</span><span id="line-717"></span><span>                      </span><span class="annot"><span class="annottext">(Type -&gt; Maybe TyCon) -&gt; Type -&gt; Maybe TyCon
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">HasDebugCallStack =&gt; Type -&gt; Type
Type -&gt; Type
</span><span class="hs-identifier hs-var">funResultTy</span></span><span>      </span><span class="hs-comment">-- SNat n</span><span>
</span><span id="line-718"></span><span>                      </span><span class="annot"><span class="annottext">(Type -&gt; Type) -&gt; Type -&gt; Type
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type
</span><span class="hs-identifier hs-var">dropForAlls</span></span><span>      </span><span class="hs-comment">-- KnownNat n =&gt; SNat n</span><span>
</span><span id="line-719"></span><span>                      </span><span class="annot"><span class="annottext">(Type -&gt; Type) -&gt; Type -&gt; Type
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">DFunId -&gt; Type
</span><span class="hs-identifier hs-var">idType</span></span><span> </span><span class="annot"><span class="annottext">DFunId
</span><a href="#local-6989586621679224110"><span class="hs-identifier hs-var">kn_meth</span></a></span><span>   </span><span class="hs-comment">-- forall n. KnownNat n =&gt; SNat n</span><span>
</span><span id="line-720"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679224112"><span class="annot"><span class="annottext">Coercion
</span><a href="#local-6989586621679224112"><span class="hs-identifier hs-var">kn_co_rep_z</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">TyCon -&gt; [Type] -&gt; Maybe (Type, Coercion)
</span><span class="hs-identifier hs-var">tcInstNewTyCon_maybe</span></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621679224111"><span class="hs-identifier hs-var">kn_tcRep</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224107"><span class="hs-identifier hs-var">z</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-721"></span><span>    </span><span class="hs-comment">-- SNat z ~ Integer</span><span>
</span><span id="line-722"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679224113"><span class="annot"><span class="annottext">Coercion
</span><a href="#local-6989586621679224113"><span class="hs-identifier hs-var">kn_co_rep_x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">TyCon -&gt; [Type] -&gt; Maybe (Type, Coercion)
</span><span class="hs-identifier hs-var">tcInstNewTyCon_maybe</span></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621679224111"><span class="hs-identifier hs-var">kn_tcRep</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224106"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-723"></span><span>    </span><span class="hs-comment">-- Integer ~ SNat x</span><span>
</span><span id="line-724"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679224114"><span class="annot"><span class="annottext">Coercion
</span><a href="#local-6989586621679224114"><span class="hs-identifier hs-var">kn_co_dict_x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">TyCon -&gt; [Type] -&gt; Maybe (Type, Coercion)
</span><span class="hs-identifier hs-var">tcInstNewTyCon_maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Class -&gt; TyCon
</span><span class="hs-identifier hs-var">classTyCon</span></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679224105"><span class="hs-identifier hs-var">knCls</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224106"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-725"></span><span>    </span><span class="hs-comment">-- SNat x ~ KnownNat x</span><span>
</span><span id="line-726"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">EvTerm -&gt; Maybe EvTerm
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">(EvTerm -&gt; Maybe EvTerm)
-&gt; (Coercion -&gt; EvTerm) -&gt; Coercion -&gt; Maybe EvTerm
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">EvExpr -&gt; Coercion -&gt; EvTerm
</span><span class="hs-identifier hs-var">mkEvCast</span></span><span> </span><span class="annot"><span class="annottext">EvExpr
</span><a href="#local-6989586621679224108"><span class="hs-identifier hs-var">xEv</span></a></span><span> </span><span class="annot"><span class="annottext">(Coercion -&gt; Maybe EvTerm) -&gt; Coercion -&gt; Maybe EvTerm
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Coercion
</span><a href="#local-6989586621679224114"><span class="hs-identifier hs-var">kn_co_dict_x</span></a></span><span> </span><span class="annot"><span class="annottext">Coercion -&gt; Coercion -&gt; Coercion
</span><a href="GHC.TypeLits.KnownNat.Solver.html#mkTcTransCo"><span class="hs-operator hs-var">`mkTcTransCo`</span></a></span><span> </span><span class="annot"><span class="annottext">Coercion
</span><a href="#local-6989586621679224113"><span class="hs-identifier hs-var">kn_co_rep_x</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Coercion -&gt; Coercion -&gt; Coercion
</span><a href="GHC.TypeLits.KnownNat.Solver.html#mkTcTransCo"><span class="hs-operator hs-var">`mkTcTransCo`</span></a></span><span> </span><span class="annot"><span class="annottext">Coercion -&gt; Coercion
</span><a href="GHC.TypeLits.KnownNat.Solver.html#mkTcSymCo"><span class="hs-identifier hs-var">mkTcSymCo</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Coercion
</span><a href="#local-6989586621679224109"><span class="hs-identifier hs-var">kn_co_dict_z</span></a></span><span> </span><span class="annot"><span class="annottext">Coercion -&gt; Coercion -&gt; Coercion
</span><a href="GHC.TypeLits.KnownNat.Solver.html#mkTcTransCo"><span class="hs-operator hs-var">`mkTcTransCo`</span></a></span><span> </span><span class="annot"><span class="annottext">Coercion
</span><a href="#local-6989586621679224112"><span class="hs-identifier hs-var">kn_co_rep_z</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-727"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe EvTerm
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-728"></span><span>
</span><span id="line-729"></span><span class="hs-comment">-- | THIS CODE IS COPIED FROM:</span><span>
</span><span id="line-730"></span><span class="hs-comment">-- https://github.com/ghc/ghc/blob/8035d1a5dc7290e8d3d61446ee4861e0b460214e/compiler/typecheck/TcInteract.hs#L1973</span><span>
</span><span id="line-731"></span><span class="hs-comment">--</span><span>
</span><span id="line-732"></span><span class="hs-comment">-- makeLitDict adds a coercion that will convert the literal into a dictionary</span><span>
</span><span id="line-733"></span><span class="hs-comment">-- of the appropriate type.  See Note [KnownNat &amp; KnownSymbol and EvLit]</span><span>
</span><span id="line-734"></span><span class="hs-comment">-- in TcEvidence.  The coercion happens in 2 steps:</span><span>
</span><span id="line-735"></span><span class="hs-comment">--</span><span>
</span><span id="line-736"></span><span class="hs-comment">--     Integer -&gt; SNat n     -- representation of literal to singleton</span><span>
</span><span id="line-737"></span><span class="hs-comment">--     SNat n  -&gt; KnownNat n -- singleton to dictionary</span><span>
</span><span id="line-738"></span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#makeLitDict"><span class="hs-identifier hs-type">makeLitDict</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Class</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Integer</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TcPluginM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">EvTerm</span></span><span class="hs-special">)</span><span>
</span><span id="line-739"></span><span id="makeLitDict"><span class="annot"><span class="annottext">makeLitDict :: Class -&gt; Type -&gt; Integer -&gt; TcPluginM (Maybe EvTerm)
</span><a href="GHC.TypeLits.KnownNat.Solver.html#makeLitDict"><span class="hs-identifier hs-var hs-var">makeLitDict</span></a></span></span><span> </span><span id="local-6989586621679224115"><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679224115"><span class="hs-identifier hs-var">clas</span></a></span></span><span> </span><span id="local-6989586621679224116"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224116"><span class="hs-identifier hs-var">ty</span></a></span></span><span> </span><span id="local-6989586621679224117"><span class="annot"><span class="annottext">Integer
</span><a href="#local-6989586621679224117"><span class="hs-identifier hs-var">i</span></a></span></span><span>
</span><span id="line-740"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679224118"><span class="annot"><span class="annottext">Coercion
</span><a href="#local-6989586621679224118"><span class="hs-identifier hs-var">co_dict</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">TyCon -&gt; [Type] -&gt; Maybe (Type, Coercion)
</span><span class="hs-identifier hs-var">tcInstNewTyCon_maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Class -&gt; TyCon
</span><span class="hs-identifier hs-var">classTyCon</span></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679224115"><span class="hs-identifier hs-var">clas</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224116"><span class="hs-identifier hs-var">ty</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-741"></span><span>    </span><span class="hs-comment">-- co_dict :: KnownNat n ~ SNat n</span><span>
</span><span id="line-742"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span> </span><span id="local-6989586621679224119"><span class="annot"><span class="annottext">DFunId
</span><a href="#local-6989586621679224119"><span class="hs-identifier hs-var">meth</span></a></span></span><span> </span><span class="hs-special">]</span><span>   </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Class -&gt; [DFunId]
</span><span class="hs-identifier hs-var">classMethods</span></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679224115"><span class="hs-identifier hs-var">clas</span></a></span><span>
</span><span id="line-743"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679224120"><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621679224120"><span class="hs-identifier hs-var">tcRep</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Maybe TyCon
</span><span class="hs-identifier hs-var">tyConAppTyCon_maybe</span></span><span> </span><span class="hs-comment">-- SNat</span><span>
</span><span id="line-744"></span><span>                    </span><span class="annot"><span class="annottext">(Type -&gt; Maybe TyCon) -&gt; Type -&gt; Maybe TyCon
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">HasDebugCallStack =&gt; Type -&gt; Type
Type -&gt; Type
</span><span class="hs-identifier hs-var">funResultTy</span></span><span>     </span><span class="hs-comment">-- SNat n</span><span>
</span><span id="line-745"></span><span>                    </span><span class="annot"><span class="annottext">(Type -&gt; Type) -&gt; Type -&gt; Type
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type
</span><span class="hs-identifier hs-var">dropForAlls</span></span><span>     </span><span class="hs-comment">-- KnownNat n =&gt; SNat n</span><span>
</span><span id="line-746"></span><span>                    </span><span class="annot"><span class="annottext">(Type -&gt; Type) -&gt; Type -&gt; Type
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">DFunId -&gt; Type
</span><span class="hs-identifier hs-var">idType</span></span><span> </span><span class="annot"><span class="annottext">DFunId
</span><a href="#local-6989586621679224119"><span class="hs-identifier hs-var">meth</span></a></span><span>     </span><span class="hs-comment">-- forall n. KnownNat n =&gt; SNat n</span><span>
</span><span id="line-747"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679224121"><span class="annot"><span class="annottext">Coercion
</span><a href="#local-6989586621679224121"><span class="hs-identifier hs-var">co_rep</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">TyCon -&gt; [Type] -&gt; Maybe (Type, Coercion)
</span><span class="hs-identifier hs-var">tcInstNewTyCon_maybe</span></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621679224120"><span class="hs-identifier hs-var">tcRep</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224116"><span class="hs-identifier hs-var">ty</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-748"></span><span>        </span><span class="hs-comment">-- SNat n ~ Integer</span><span>
</span><span id="line-749"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-750"></span><span>    </span><span id="local-6989586621679224122"><span class="annot"><a href="#local-6989586621679224122"><span class="hs-identifier hs-var">platform</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">TcM Platform -&gt; TcPluginM Platform
forall a. TcM a -&gt; TcPluginM a
</span><span class="hs-identifier hs-var">unsafeTcPluginTcM</span></span><span> </span><span class="annot"><span class="annottext">TcM Platform
forall a b. TcRnIf a b Platform
</span><span class="hs-identifier hs-var">getPlatform</span></span><span>
</span><span id="line-751"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679224123"><span class="annot"><a href="#local-6989586621679224123"><span class="hs-identifier hs-var hs-var">et</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Platform -&gt; Integer -&gt; EvExpr
</span><span class="hs-identifier hs-var">mkNaturalExpr</span></span><span> </span><span class="annot"><span class="annottext">Platform
</span><a href="#local-6989586621679224122"><span class="hs-identifier hs-var">platform</span></a></span><span> </span><span class="annot"><span class="annottext">Integer
</span><a href="#local-6989586621679224117"><span class="hs-identifier hs-var">i</span></a></span><span>
</span><span id="line-752"></span><span>        </span><span id="local-6989586621679224124"><span class="annot"><a href="#local-6989586621679224124"><span class="hs-identifier hs-var hs-var">ev_tm</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">EvExpr -&gt; Coercion -&gt; EvTerm
</span><span class="hs-identifier hs-var">mkEvCast</span></span><span> </span><span class="annot"><span class="annottext">EvExpr
</span><a href="#local-6989586621679224123"><span class="hs-identifier hs-var">et</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Coercion -&gt; Coercion
</span><a href="GHC.TypeLits.KnownNat.Solver.html#mkTcSymCo"><span class="hs-identifier hs-var">mkTcSymCo</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Coercion -&gt; Coercion -&gt; Coercion
</span><a href="GHC.TypeLits.KnownNat.Solver.html#mkTcTransCo"><span class="hs-identifier hs-var">mkTcTransCo</span></a></span><span> </span><span class="annot"><span class="annottext">Coercion
</span><a href="#local-6989586621679224118"><span class="hs-identifier hs-var">co_dict</span></a></span><span> </span><span class="annot"><span class="annottext">Coercion
</span><a href="#local-6989586621679224121"><span class="hs-identifier hs-var">co_rep</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-753"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="annot"><a href="#local-6989586621679224124"><span class="hs-identifier hs-type">ev_tm</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-754"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-755"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe EvTerm -&gt; TcPluginM (Maybe EvTerm)
forall a. a -&gt; TcPluginM a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Maybe EvTerm
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-756"></span><span>
</span><span id="line-757"></span><span class="annot"><span class="hs-comment">{- |
Given:

* A &quot;magic&quot; class, and corresponding instance dictionary function, for a
  type-level boolean operation
* Two KnownBool dictionaries

makeOpDictByFiat instantiates the dictionary function with the KnownBool
dictionaries, and coerces it to a KnownBool dictionary. i.e. for KnownBoolNat2,
the &quot;magic&quot; dictionary for binary functions, the coercion happens in the
following steps:

1. KnownBoolNat2 &quot;&lt;=?&quot; x y     -&gt; SBoolF &quot;&lt;=?&quot;
2. SBoolF &quot;&lt;=?&quot;                -&gt; Bool
3. Bool                        -&gt; SNat (x &lt;=? y)  THE BY FIAT PART!
4. SBool (x &lt;=? y)             -&gt; KnownBool (x &lt;=? y)

this process is mirrored for the dictionary functions of a higher arity
-}</span></span><span>
</span><span id="line-776"></span><span class="annot"><a href="GHC.TypeLits.KnownNat.Solver.html#makeOpDictByFiat"><span class="hs-identifier hs-type">makeOpDictByFiat</span></a></span><span>
</span><span id="line-777"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Class</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">DFunId</span></span><span class="hs-special">)</span><span>
</span><span id="line-778"></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ &quot;magic&quot; class function and dictionary function id</span></span><span>
</span><span id="line-779"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Class</span></span><span>
</span><span id="line-780"></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ KnownNat class</span></span><span>
</span><span id="line-781"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span>
</span><span id="line-782"></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ Argument types for the Class</span></span><span>
</span><span id="line-783"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span>
</span><span id="line-784"></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ Argument types for the Instance</span></span><span>
</span><span id="line-785"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-786"></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ Type of the result</span></span><span>
</span><span id="line-787"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">EvExpr</span></span><span class="hs-special">]</span><span>
</span><span id="line-788"></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ Evidence arguments</span></span><span>
</span><span id="line-789"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">EvTerm</span></span><span>
</span><span id="line-790"></span><span id="makeOpDictByFiat"><span class="annot"><span class="annottext">makeOpDictByFiat :: (Class, DFunId)
-&gt; Class -&gt; [Type] -&gt; [Type] -&gt; Type -&gt; [EvExpr] -&gt; Maybe EvTerm
</span><a href="GHC.TypeLits.KnownNat.Solver.html#makeOpDictByFiat"><span class="hs-identifier hs-var hs-var">makeOpDictByFiat</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679224125"><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679224125"><span class="hs-identifier hs-var">opCls</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679224126"><span class="annot"><span class="annottext">DFunId
</span><a href="#local-6989586621679224126"><span class="hs-identifier hs-var">dfid</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679224127"><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679224127"><span class="hs-identifier hs-var">knCls</span></a></span></span><span> </span><span id="local-6989586621679224128"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679224128"><span class="hs-identifier hs-var">tyArgsC</span></a></span></span><span> </span><span id="local-6989586621679224129"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679224129"><span class="hs-identifier hs-var">tyArgsI</span></a></span></span><span> </span><span id="local-6989586621679224130"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224130"><span class="hs-identifier hs-var">z</span></a></span></span><span> </span><span id="local-6989586621679224131"><span class="annot"><span class="annottext">[EvExpr]
</span><a href="#local-6989586621679224131"><span class="hs-identifier hs-var">evArgs</span></a></span></span><span>
</span><span id="line-791"></span><span>    </span><span class="hs-comment">-- KnownBool b ~ SBool b</span><span>
</span><span id="line-792"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679224132"><span class="annot"><span class="annottext">Coercion
</span><a href="#local-6989586621679224132"><span class="hs-identifier hs-var">kn_co_dict</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">TyCon -&gt; [Type] -&gt; Maybe (Type, Coercion)
</span><span class="hs-identifier hs-var">tcInstNewTyCon_maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Class -&gt; TyCon
</span><span class="hs-identifier hs-var">classTyCon</span></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679224127"><span class="hs-identifier hs-var">knCls</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224130"><span class="hs-identifier hs-var">z</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-793"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span> </span><span id="local-6989586621679224133"><span class="annot"><span class="annottext">DFunId
</span><a href="#local-6989586621679224133"><span class="hs-identifier hs-var">kn_meth</span></a></span></span><span> </span><span class="hs-special">]</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Class -&gt; [DFunId]
</span><span class="hs-identifier hs-var">classMethods</span></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679224127"><span class="hs-identifier hs-var">knCls</span></a></span><span>
</span><span id="line-794"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679224134"><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621679224134"><span class="hs-identifier hs-var">kn_tcRep</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Maybe TyCon
</span><span class="hs-identifier hs-var">tyConAppTyCon_maybe</span></span><span> </span><span class="hs-comment">-- SBool</span><span>
</span><span id="line-795"></span><span>                       </span><span class="annot"><span class="annottext">(Type -&gt; Maybe TyCon) -&gt; Type -&gt; Maybe TyCon
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">HasDebugCallStack =&gt; Type -&gt; Type
Type -&gt; Type
</span><span class="hs-identifier hs-var">funResultTy</span></span><span>     </span><span class="hs-comment">-- SBool b</span><span>
</span><span id="line-796"></span><span>                       </span><span class="annot"><span class="annottext">(Type -&gt; Type) -&gt; Type -&gt; Type
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type
</span><span class="hs-identifier hs-var">dropForAlls</span></span><span>     </span><span class="hs-comment">-- KnownBool b =&gt; SBool b</span><span>
</span><span id="line-797"></span><span>                       </span><span class="annot"><span class="annottext">(Type -&gt; Type) -&gt; Type -&gt; Type
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">DFunId -&gt; Type
</span><span class="hs-identifier hs-var">idType</span></span><span> </span><span class="annot"><span class="annottext">DFunId
</span><a href="#local-6989586621679224133"><span class="hs-identifier hs-var">kn_meth</span></a></span><span>  </span><span class="hs-comment">-- forall b. KnownBool b =&gt; SBool b</span><span>
</span><span id="line-798"></span><span>    </span><span class="hs-comment">-- SBool b R~ Bool (The &quot;Lie&quot;)</span><span class="hs-cpp">
#if MIN_VERSION_ghc(9,11,0)
</span><span>  </span><span class="hs-special">,</span><span> </span><span class="hs-keyword">let</span><span> </span><span class="hs-identifier">kn_co_rep</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">mkUnivCo</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">PluginProv</span><span> </span><span class="hs-string">&quot;ghc-typelits-knownnat&quot;</span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-cpp">
#else
</span><span>  </span><span class="hs-special">,</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679224135"><span class="annot"><span class="annottext">kn_co_rep :: Coercion
</span><a href="#local-6989586621679224135"><span class="hs-identifier hs-var hs-var">kn_co_rep</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">UnivCoProvenance -&gt; Role -&gt; Type -&gt; Type -&gt; Coercion
</span><span class="hs-identifier hs-var">mkUnivCo</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CommandLineOption -&gt; UnivCoProvenance
</span><span class="hs-identifier hs-var">PluginProv</span></span><span> </span><span class="annot"><span class="annottext">CommandLineOption
</span><span class="hs-string">&quot;ghc-typelits-knownnat&quot;</span></span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span>                             </span><span class="annot"><span class="annottext">Role
</span><span class="hs-identifier hs-var">Representational</span></span><span>
</span><span id="line-805"></span><span>                             </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TyCon -&gt; [Type] -&gt; Type
</span><span class="hs-identifier hs-var">mkTyConApp</span></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621679224134"><span class="hs-identifier hs-var">kn_tcRep</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679224130"><span class="hs-identifier hs-var">z</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier hs-var">boolTy</span></span><span>
</span><span id="line-806"></span><span>    </span><span class="hs-comment">-- KnownBoolNat2 f a b ~ SBool f</span><span>
</span><span id="line-807"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679224136"><span class="annot"><span class="annottext">Coercion
</span><a href="#local-6989586621679224136"><span class="hs-identifier hs-var">op_co_dict</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">TyCon -&gt; [Type] -&gt; Maybe (Type, Coercion)
</span><span class="hs-identifier hs-var">tcInstNewTyCon_maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Class -&gt; TyCon
</span><span class="hs-identifier hs-var">classTyCon</span></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679224125"><span class="hs-identifier hs-var">opCls</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679224128"><span class="hs-identifier hs-var">tyArgsC</span></a></span><span>
</span><span id="line-808"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span> </span><span id="local-6989586621679224137"><span class="annot"><span class="annottext">DFunId
</span><a href="#local-6989586621679224137"><span class="hs-identifier hs-var">op_meth</span></a></span></span><span> </span><span class="hs-special">]</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Class -&gt; [DFunId]
</span><span class="hs-identifier hs-var">classMethods</span></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621679224125"><span class="hs-identifier hs-var">opCls</span></a></span><span>
</span><span id="line-809"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679224138"><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621679224138"><span class="hs-identifier hs-var">op_tcRep</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679224139"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679224139"><span class="hs-identifier hs-var">op_args</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">HasDebugCallStack =&gt; Type -&gt; Maybe (TyCon, [Type])
Type -&gt; Maybe (TyCon, [Type])
</span><span class="hs-identifier hs-var">splitTyConApp_maybe</span></span><span>        </span><span class="hs-comment">-- (SBool, [f])</span><span>
</span><span id="line-810"></span><span>                                 </span><span class="annot"><span class="annottext">(Type -&gt; Maybe (TyCon, [Type])) -&gt; Type -&gt; Maybe (TyCon, [Type])
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">HasDebugCallStack =&gt; Type -&gt; Type
Type -&gt; Type
</span><span class="hs-identifier hs-var">funResultTy</span></span><span>            </span><span class="hs-comment">-- SBool f</span><span>
</span><span id="line-811"></span><span>                                 </span><span class="annot"><span class="annottext">(Type -&gt; Type) -&gt; Type -&gt; Type
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">HasDebugCallStack =&gt; Type -&gt; [Type] -&gt; Type
Type -&gt; [Type] -&gt; Type
</span><span class="hs-operator hs-var">`piResultTys`</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679224128"><span class="hs-identifier hs-var">tyArgsC</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- KnownBoolNat2 f x y =&gt; SBool f</span><span>
</span><span id="line-812"></span><span>                                 </span><span class="annot"><span class="annottext">(Type -&gt; Type) -&gt; Type -&gt; Type
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">DFunId -&gt; Type
</span><span class="hs-identifier hs-var">idType</span></span><span> </span><span class="annot"><span class="annottext">DFunId
</span><a href="#local-6989586621679224137"><span class="hs-identifier hs-var">op_meth</span></a></span><span>         </span><span class="hs-comment">-- forall f x y . KnownBoolNat2 f a b =&gt; SBoolf f</span><span>
</span><span id="line-813"></span><span>    </span><span class="hs-comment">-- SBoolF f ~ Bool</span><span>
</span><span id="line-814"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679224140"><span class="annot"><span class="annottext">Coercion
</span><a href="#local-6989586621679224140"><span class="hs-identifier hs-var">op_co_rep</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">TyCon -&gt; [Type] -&gt; Maybe (Type, Coercion)
</span><span class="hs-identifier hs-var">tcInstNewTyCon_maybe</span></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621679224138"><span class="hs-identifier hs-var">op_tcRep</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679224139"><span class="hs-identifier hs-var">op_args</span></a></span><span>
</span><span id="line-815"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">EvExpr</span></span><span> </span><span id="local-6989586621679224141"><span class="annot"><span class="annottext">EvExpr
</span><a href="#local-6989586621679224141"><span class="hs-identifier hs-var">dfun_inst</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">DFunId -&gt; [Type] -&gt; [EvExpr] -&gt; EvTerm
</span><span class="hs-identifier hs-var">evDFunApp</span></span><span> </span><span class="annot"><span class="annottext">DFunId
</span><a href="#local-6989586621679224126"><span class="hs-identifier hs-var">dfid</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679224129"><span class="hs-identifier hs-var">tyArgsI</span></a></span><span> </span><span class="annot"><span class="annottext">[EvExpr]
</span><a href="#local-6989586621679224131"><span class="hs-identifier hs-var">evArgs</span></a></span><span>
</span><span id="line-816"></span><span>    </span><span class="hs-comment">-- KnownBoolNat2 f x y ~ KnownBool b</span><span>
</span><span id="line-817"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679224142"><span class="annot"><span class="annottext">op_to_kn :: Coercion
</span><a href="#local-6989586621679224142"><span class="hs-identifier hs-var hs-var">op_to_kn</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Coercion -&gt; Coercion -&gt; Coercion
</span><a href="GHC.TypeLits.KnownNat.Solver.html#mkTcTransCo"><span class="hs-identifier hs-var">mkTcTransCo</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Coercion -&gt; Coercion -&gt; Coercion
</span><a href="GHC.TypeLits.KnownNat.Solver.html#mkTcTransCo"><span class="hs-identifier hs-var">mkTcTransCo</span></a></span><span> </span><span class="annot"><span class="annottext">Coercion
</span><a href="#local-6989586621679224136"><span class="hs-identifier hs-var">op_co_dict</span></a></span><span> </span><span class="annot"><span class="annottext">Coercion
</span><a href="#local-6989586621679224140"><span class="hs-identifier hs-var">op_co_rep</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-818"></span><span>                                </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Coercion -&gt; Coercion
</span><a href="GHC.TypeLits.KnownNat.Solver.html#mkTcSymCo"><span class="hs-identifier hs-var">mkTcSymCo</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Coercion -&gt; Coercion -&gt; Coercion
</span><a href="GHC.TypeLits.KnownNat.Solver.html#mkTcTransCo"><span class="hs-identifier hs-var">mkTcTransCo</span></a></span><span> </span><span class="annot"><span class="annottext">Coercion
</span><a href="#local-6989586621679224132"><span class="hs-identifier hs-var">kn_co_dict</span></a></span><span> </span><span class="annot"><span class="annottext">Coercion
</span><a href="#local-6989586621679224135"><span class="hs-identifier hs-var">kn_co_rep</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-819"></span><span>        </span><span id="local-6989586621679224143"><span class="annot"><span class="annottext">ev_tm :: EvTerm
</span><a href="#local-6989586621679224143"><span class="hs-identifier hs-var hs-var">ev_tm</span></a></span></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">EvExpr -&gt; Coercion -&gt; EvTerm
</span><span class="hs-identifier hs-var">mkEvCast</span></span><span> </span><span class="annot"><span class="annottext">EvExpr
</span><a href="#local-6989586621679224141"><span class="hs-identifier hs-var">dfun_inst</span></a></span><span> </span><span class="annot"><span class="annottext">Coercion
</span><a href="#local-6989586621679224142"><span class="hs-identifier hs-var">op_to_kn</span></a></span><span>
</span><span id="line-820"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">EvTerm -&gt; Maybe EvTerm
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">EvTerm
</span><a href="#local-6989586621679224143"><span class="hs-identifier hs-var">ev_tm</span></a></span><span>
</span><span id="line-821"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-822"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe EvTerm
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-823"></span></pre></body></html>