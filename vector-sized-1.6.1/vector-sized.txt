-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Size tagged vectors
--   
--   Please see README.md
@package vector-sized
@version 1.6.1

module Data.Vector.Generic.Mutable.Sized.Internal

-- | A wrapper to tag mutable vectors with a type level length.
--   
--   Be careful when using the constructor here to not construct sized
--   vectors which have a different length than that specified in the type
--   parameter!
newtype MVector (v :: Type -> Type -> Type) (n :: Nat) s a
MVector :: v s a -> MVector (v :: Type -> Type -> Type) (n :: Nat) s a
instance (GHC.Internal.TypeNats.KnownNat n, GHC.Internal.Data.Typeable.Internal.Typeable v, GHC.Internal.Data.Typeable.Internal.Typeable s, GHC.Internal.Data.Typeable.Internal.Typeable a, GHC.Internal.Data.Data.Data (v s a)) => GHC.Internal.Data.Data.Data (Data.Vector.Generic.Mutable.Sized.Internal.MVector v n s a)
instance Control.DeepSeq.NFData (v s a) => Control.DeepSeq.NFData (Data.Vector.Generic.Mutable.Sized.Internal.MVector v n s a)
instance GHC.Internal.Foreign.Storable.Storable (v s a) => GHC.Internal.Foreign.Storable.Storable (Data.Vector.Generic.Mutable.Sized.Internal.MVector v n s a)


-- | This module reexports the functionality in <a>Mutable</a> which maps
--   well to explicitly sized vectors.
--   
--   Functions returning a vector determine the size from the type context
--   unless they have a <tt>'</tt> suffix in which case they take an
--   explicit <a>Proxy</a> argument.
--   
--   Functions where the resultant vector size is not known until runtime
--   are not exported.
module Data.Vector.Generic.Mutable.Sized

-- | A wrapper to tag mutable vectors with a type level length.
--   
--   Be careful when using the constructor here to not construct sized
--   vectors which have a different length than that specified in the type
--   parameter!
data MVector (v :: Type -> Type -> Type) (n :: Nat) s a

-- | <i>O(1)</i> Yield the length of the mutable vector as an <a>Int</a>.
length :: forall (v :: Type -> Type -> Type) (n :: Nat) s a. KnownNat n => MVector v n s a -> Int

-- | <i>O(1)</i> Yield the length of the mutable vector as a <a>Proxy</a>.
length' :: forall (v :: Type -> Type -> Type) (n :: Nat) s a. MVector v n s a -> Proxy n

-- | <i>O(1)</i> Check whether the mutable vector is empty.
null :: forall (v :: Type -> Type -> Type) (n :: Nat) s a. KnownNat n => MVector v n s a -> Bool

-- | <i>O(1)</i> Yield a slice of the mutable vector without copying it
--   with an inferred length argument.
slice :: forall (v :: Type -> Type -> Type) (i :: Nat) (n :: Nat) (k :: Natural) s a p. (KnownNat i, KnownNat n, MVector v a) => p i -> MVector v ((i + n) + k) s a -> MVector v n s a

-- | <i>O(1)</i> Yield a slice of the mutable vector without copying it
--   with an explicit length argument.
slice' :: forall (v :: Type -> Type -> Type) (i :: Nat) (n :: Nat) (k :: Natural) s a p. (KnownNat i, KnownNat n, MVector v a) => p i -> p n -> MVector v ((i + n) + k) s a -> MVector v n s a

-- | <i>O(1)</i> Yield all but the last element of a non-empty mutable
--   vector without copying.
init :: forall (v :: Type -> Type -> Type) (n :: Natural) s a. MVector v a => MVector v (n + 1) s a -> MVector v n s a

-- | <i>O(1)</i> Yield all but the first element of a non-empty mutable
--   vector without copying.
tail :: forall (v :: Type -> Type -> Type) (n :: Natural) s a. MVector v a => MVector v (1 + n) s a -> MVector v n s a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements. The resulting vector
--   always contains this many elements. The length of the resulting vector
--   is inferred from the type.
take :: forall (v :: Type -> Type -> Type) (n :: Nat) (k :: Natural) s a. (KnownNat n, MVector v a) => MVector v (n + k) s a -> MVector v n s a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements. The resulting vector
--   always contains this many elements. The length of the resulting vector
--   is given explicitly as a <a>Proxy</a> argument.
take' :: forall (v :: Type -> Type -> Type) (n :: Nat) (k :: Natural) s a p. (KnownNat n, MVector v a) => p n -> MVector v (n + k) s a -> MVector v n s a

-- | <i>O(1)</i> Yield all but the the first <tt>n</tt> elements. The given
--   vector must contain at least this many elements. The length of the
--   resulting vector is inferred from the type.
drop :: forall (v :: Type -> Type -> Type) (n :: Nat) (k :: Natural) s a. (KnownNat n, MVector v a) => MVector v (n + k) s a -> MVector v k s a

-- | <i>O(1)</i> Yield all but the the first <tt>n</tt> elements. The given
--   vector must contain at least this many elements. The length of the
--   resulting vector is given explicitly as a <a>Proxy</a> argument.
drop' :: forall (v :: Type -> Type -> Type) (n :: Nat) (k :: Natural) s a p. (KnownNat n, MVector v a) => p n -> MVector v (n + k) s a -> MVector v k s a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements, paired with the rest,
--   without copying. The lengths of the resulting vectors are inferred
--   from the type.
splitAt :: forall (v :: Type -> Type -> Type) (n :: Nat) (m :: Natural) s a. (KnownNat n, MVector v a) => MVector v (n + m) s a -> (MVector v n s a, MVector v m s a)

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements, paired with the rest,
--   without copying. The length of the first resulting vector is passed
--   explicitly as a <a>Proxy</a> argument.
splitAt' :: forall (v :: Type -> Type -> Type) (n :: Nat) (m :: Natural) s a p. (KnownNat n, MVector v a) => p n -> MVector v (n + m) s a -> (MVector v n s a, MVector v m s a)

-- | <i>O(1)</i> Check whether two vectors overlap.
overlaps :: forall (v :: Type -> Type -> Type) (n :: Nat) (k :: Nat) s a. MVector v a => MVector v n s a -> MVector v k s a -> Bool

-- | Create a mutable vector where the length is inferred from the type.
new :: forall (v :: Type -> Type -> Type) (n :: Nat) m a. (KnownNat n, PrimMonad m, MVector v a) => m (MVector v n (PrimState m) a)

-- | Create a mutable vector where the length is inferred from the type.
--   The memory is not initialized.
unsafeNew :: forall (v :: Type -> Type -> Type) (n :: Nat) m a. (KnownNat n, PrimMonad m, MVector v a) => m (MVector v n (PrimState m) a)

-- | Create a mutable vector where the length is inferred from the type and
--   fill it with an initial value.
replicate :: forall (v :: Type -> Type -> Type) (n :: Nat) m a. (KnownNat n, PrimMonad m, MVector v a) => a -> m (MVector v n (PrimState m) a)

-- | Create a mutable vector where the length is given explicitly as a
--   <a>Proxy</a> argument and fill it with an initial value.
replicate' :: forall (v :: Type -> Type -> Type) (n :: Nat) m a p. (KnownNat n, PrimMonad m, MVector v a) => p n -> a -> m (MVector v n (PrimState m) a)

-- | Create a mutable vector where the length is inferred from the type and
--   fill it with values produced by repeatedly executing the monadic
--   action.
replicateM :: forall (v :: Type -> Type -> Type) (n :: Nat) m a. (KnownNat n, PrimMonad m, MVector v a) => m a -> m (MVector v n (PrimState m) a)

-- | Create a mutable vector where the length is given explicitly as a
--   <a>Proxy</a> argument and fill it with values produced by repeatedly
--   executing the monadic action.
replicateM' :: forall (v :: Type -> Type -> Type) (n :: Nat) m a p. (KnownNat n, PrimMonad m, MVector v a) => p n -> m a -> m (MVector v n (PrimState m) a)

-- | Create a copy of a mutable vector.
clone :: forall (v :: Type -> Type -> Type) (n :: Nat) m a. (PrimMonad m, MVector v a) => MVector v n (PrimState m) a -> m (MVector v n (PrimState m) a)

-- | Grow a mutable vector by an amount given explicitly as a <a>Proxy</a>
--   argument.
grow :: forall (v :: Type -> Type -> Type) (n :: Nat) (k :: Nat) m a p. (KnownNat k, PrimMonad m, MVector v a) => p k -> MVector v n (PrimState m) a -> m (MVector v (n + k) (PrimState m) a)

-- | Grow a mutable vector (from the front) by an amount given explicitly
--   as a <a>Proxy</a> argument.
growFront :: forall (v :: Type -> Type -> Type) (n :: Nat) (k :: Nat) m a p. (KnownNat k, PrimMonad m, MVector v a) => p k -> MVector v n (PrimState m) a -> m (MVector v (n + k) (PrimState m) a)

-- | Reset all elements of the vector to some undefined value, clearing all
--   references to external objects.
clear :: forall m (v :: Type -> Type -> Type) a (n :: Nat). (PrimMonad m, MVector v a) => MVector v n (PrimState m) a -> m ()

-- | <i>O(1)</i> Yield the element at a given type-safe position using
--   <a>Finite</a>.
read :: forall (v :: Type -> Type -> Type) (n :: Nat) m a. (PrimMonad m, MVector v a) => MVector v n (PrimState m) a -> Finite n -> m a

-- | <i>O(1)</i> Yield the element at a given type-safe position using
--   <a>Proxy</a>.
read' :: forall (v :: Type -> Type -> Type) (n :: Natural) (k :: Nat) a m p. (KnownNat k, PrimMonad m, MVector v a) => MVector v ((n + k) + 1) (PrimState m) a -> p k -> m a

-- | <i>O(1)</i> Replace the element at a given type-safe position using
--   <a>Finite</a>.
write :: forall (v :: Type -> Type -> Type) (n :: Nat) m a. (PrimMonad m, MVector v a) => MVector v n (PrimState m) a -> Finite n -> a -> m ()

-- | <i>O(1)</i> Replace the element at a given type-safe position using
--   <a>Proxy</a>.
write' :: forall (v :: Type -> Type -> Type) (n :: Natural) (k :: Nat) a m p. (KnownNat k, PrimMonad m, MVector v a) => MVector v ((n + k) + 1) (PrimState m) a -> p k -> a -> m ()

-- | <i>O(1)</i> Modify the element at a given type-safe position using
--   <a>Finite</a>.
modify :: forall (v :: Type -> Type -> Type) (n :: Nat) m a. (PrimMonad m, MVector v a) => MVector v n (PrimState m) a -> (a -> a) -> Finite n -> m ()

-- | <i>O(1)</i> Modify the element at a given type-safe position using
--   <a>Proxy</a>.
modify' :: forall (v :: Type -> Type -> Type) (n :: Natural) (k :: Nat) a m p. (KnownNat k, PrimMonad m, MVector v a) => MVector v ((n + k) + 1) (PrimState m) a -> (a -> a) -> p k -> m ()

-- | <i>O(1)</i> Swap the elements at given type-safe positions using
--   <a>Finite</a>s.
swap :: forall (v :: Type -> Type -> Type) (n :: Nat) m a. (PrimMonad m, MVector v a) => MVector v n (PrimState m) a -> Finite n -> Finite n -> m ()

-- | <i>O(1)</i> Replace the element at a given type-safe position and
--   return the old element, using <a>Finite</a>.
exchange :: forall (v :: Type -> Type -> Type) (n :: Nat) m a. (PrimMonad m, MVector v a) => MVector v n (PrimState m) a -> Finite n -> a -> m a

-- | <i>O(1)</i> Replace the element at a given type-safe position and
--   return the old element, using <a>Finite</a>.
exchange' :: forall (v :: Type -> Type -> Type) (n :: Natural) (k :: Nat) a m p. (KnownNat k, PrimMonad m, MVector v a) => MVector v ((n + k) + 1) (PrimState m) a -> p k -> a -> m a

-- | <i>O(1)</i> Yield the element at a given <a>Int</a> position without
--   bounds checking.
unsafeRead :: forall (v :: Type -> Type -> Type) (n :: Nat) a m. (PrimMonad m, MVector v a) => MVector v n (PrimState m) a -> Int -> m a

-- | <i>O(1)</i> Replace the element at a given <a>Int</a> position without
--   bounds checking.
unsafeWrite :: forall (v :: Type -> Type -> Type) (n :: Nat) m a. (PrimMonad m, MVector v a) => MVector v n (PrimState m) a -> Int -> a -> m ()

-- | <i>O(1)</i> Modify the element at a given <a>Int</a> position without
--   bounds checking.
unsafeModify :: forall (v :: Type -> Type -> Type) (n :: Nat) m a. (PrimMonad m, MVector v a) => MVector v n (PrimState m) a -> (a -> a) -> Int -> m ()

-- | <i>O(1)</i> Swap the elements at given <a>Int</a> positions without
--   bounds checking.
unsafeSwap :: forall (v :: Type -> Type -> Type) (n :: Nat) m a. (PrimMonad m, MVector v a) => MVector v n (PrimState m) a -> Int -> Int -> m ()

-- | <i>O(1)</i> Replace the element at a given <a>Int</a> position and
--   return the old element. No bounds checks are performed.
unsafeExchange :: forall (v :: Type -> Type -> Type) (n :: Nat) m a. (PrimMonad m, MVector v a) => MVector v n (PrimState m) a -> Int -> a -> m a

-- | Compute the next permutation (in lexicographic order) of a given
--   vector in-place. Returns <a>False</a> when the input is the last
--   permutation.
nextPermutation :: forall (v :: Type -> Type -> Type) (n :: Nat) e m. (Ord e, PrimMonad m, MVector v e) => MVector v n (PrimState m) e -> m Bool

-- | Set all elements of the vector to the given value.
set :: forall m (v :: Type -> Type -> Type) a (n :: Nat). (PrimMonad m, MVector v a) => MVector v n (PrimState m) a -> a -> m ()

-- | Copy a vector. The two vectors may not overlap.
copy :: forall m (v :: Type -> Type -> Type) a (n :: Nat). (PrimMonad m, MVector v a) => MVector v n (PrimState m) a -> MVector v n (PrimState m) a -> m ()

-- | Move the contents of a vector. If the two vectors do not overlap, this
--   is equivalent to <a>copy</a>. Otherwise, the copying is performed as
--   if the source vector were copied to a temporary vector and then the
--   temporary vector was copied to the target vector.
move :: forall m (v :: Type -> Type -> Type) a (n :: Nat). (PrimMonad m, MVector v a) => MVector v n (PrimState m) a -> MVector v n (PrimState m) a -> m ()

-- | Copy a vector. The two vectors may not overlap. This is not checked.
unsafeCopy :: forall m (v :: Type -> Type -> Type) a (n :: Nat). (PrimMonad m, MVector v a) => MVector v n (PrimState m) a -> MVector v n (PrimState m) a -> m ()

-- | Convert a <a>MVector</a> into a <a>MVector</a> if it has the correct
--   size, otherwise return Nothing.
--   
--   Note that this does no copying; the returned <a>MVector</a> is a
--   reference to the exact same vector in memory as the given one, and any
--   modifications to it are also reflected in the given <a>MVector</a>.
toSized :: forall v (n :: Nat) s a. (MVector v a, KnownNat n) => v s a -> Maybe (MVector v n s a)

-- | Takes a <a>MVector</a> and returns a continuation providing a
--   <a>MVector</a> with a size parameter <tt>n</tt> that is determined at
--   runtime based on the length of the input vector.
--   
--   Essentially converts a <a>MVector</a> into a <a>MVector</a> with the
--   correct size parameter <tt>n</tt>.
--   
--   Note that this does no copying; the returned <a>MVector</a> is a
--   reference to the exact same vector in memory as the given one, and any
--   modifications to it are also reflected in the given <a>MVector</a>.
withSized :: forall v s a r. MVector v a => v s a -> (forall (n :: Nat). KnownNat n => MVector v n s a -> r) -> r

-- | Convert a <a>MVector</a> into a <a>MVector</a>.
--   
--   Note that this does no copying; the returned <a>MVector</a> is a
--   reference to the exact same vector in memory as the given one, and any
--   modifications to it are also reflected in the given <a>MVector</a>.
fromSized :: forall v (n :: Nat) s a. MVector v n s a -> v s a

module Data.Vector.Generic.Sized.Internal

-- | A wrapper to tag vectors with a type level length.
--   
--   Be careful when using the constructor here to not construct sized
--   vectors which have a different length than that specified in the type
--   parameter!
newtype Vector (v :: Type -> Type) (n :: Nat) a
Vector :: v a -> Vector (v :: Type -> Type) (n :: Nat) a
instance (GHC.Internal.TypeNats.KnownNat n, GHC.Internal.Data.Typeable.Internal.Typeable v, GHC.Internal.Data.Typeable.Internal.Typeable a, GHC.Internal.Data.Data.Data (v a)) => GHC.Internal.Data.Data.Data (Data.Vector.Generic.Sized.Internal.Vector v n a)
instance Data.Functor.Classes.Eq1 v => Data.Functor.Classes.Eq1 (Data.Vector.Generic.Sized.Internal.Vector v n)
instance GHC.Classes.Eq (v a) => GHC.Classes.Eq (Data.Vector.Generic.Sized.Internal.Vector v n a)
instance GHC.Internal.Data.Foldable.Foldable v => GHC.Internal.Data.Foldable.Foldable (Data.Vector.Generic.Sized.Internal.Vector v n)
instance GHC.Internal.Base.Functor v => GHC.Internal.Base.Functor (Data.Vector.Generic.Sized.Internal.Vector v n)
instance (GHC.Internal.Ix.Ix a, GHC.Classes.Ord (v a), Data.Vector.Generic.Base.Vector v a) => GHC.Internal.Ix.Ix (Data.Vector.Generic.Sized.Internal.Vector v n a)
instance Control.DeepSeq.NFData (v a) => Control.DeepSeq.NFData (Data.Vector.Generic.Sized.Internal.Vector v n a)
instance Data.Functor.Classes.Ord1 v => Data.Functor.Classes.Ord1 (Data.Vector.Generic.Sized.Internal.Vector v n)
instance GHC.Classes.Ord (v a) => GHC.Classes.Ord (Data.Vector.Generic.Sized.Internal.Vector v n a)
instance Data.Functor.Classes.Show1 v => Data.Functor.Classes.Show1 (Data.Vector.Generic.Sized.Internal.Vector v n)
instance GHC.Internal.Show.Show (v a) => GHC.Internal.Show.Show (Data.Vector.Generic.Sized.Internal.Vector v n a)
instance GHC.Internal.Data.Traversable.Traversable v => GHC.Internal.Data.Traversable.Traversable (Data.Vector.Generic.Sized.Internal.Vector v n)


-- | This module reexports the functionality in <a>Generic</a> which maps
--   well to explicity sized vectors.
--   
--   Functions returning a vector determine the size from the type context
--   unless they have a <tt>'</tt> suffix in which case they take an
--   explicit <a>Proxy</a> argument.
--   
--   Functions where the resultant vector size is not know until compile
--   time are not exported.
module Data.Vector.Generic.Sized

-- | A wrapper to tag vectors with a type level length.
--   
--   Be careful when using the constructor here to not construct sized
--   vectors which have a different length than that specified in the type
--   parameter!
data Vector (v :: Type -> Type) (n :: Nat) a

-- | Pattern synonym that lets you treat an unsized vector as if it
--   "contained" a sized vector. If you pattern match on an unsized vector,
--   its contents will be the <i>sized</i> vector counterpart.
--   
--   <pre>
--   testFunc :: Unsized.Vector Int -&gt; Int
--   testFunc (<a>SomeSized</a> v) =
--       <a>sum</a> (<a>zipWith</a> (+) v (<a>replicate</a> 1))
--           -- ^ here, v is `Sized.Vector n Int`, and we have
--                       `<a>KnownNat</a> n`
--   </pre>
--   
--   The <tt>n</tt> type variable will be properly instantiated to whatever
--   the length of the vector is, and you will also have a
--   <tt><a>KnownNat</a> n</tt> instance available. You can get <tt>n</tt>
--   in scope by turning on ScopedTypeVariables and matching on
--   <tt><a>SomeSized</a> (v :: Sized.Vector n Int)</tt>.
--   
--   Without this, you would otherwise have to use <a>withSized</a> to do
--   the same thing:
--   
--   <pre>
--   testFunc :: Unsized.Vector Int -&gt; Int
--   testFunc u = <a>withSized</a> u $ \v -&gt;
--       <a>sum</a> (<a>zipWith</a> (+) v (<a>replicate</a> 1))
--   </pre>
--   
--   Remember that the type of final result of your function (the
--   <tt>Int</tt>, here) must <i>not</i> depend on <tt>n</tt>. However, the
--   types of the intermediate values are allowed to depend on <tt>n</tt>.
--   
--   This is <i>especially</i> useful in do blocks, where you can pattern
--   match on the unsized results of actions, to use the sized vector in
--   the rest of the do block. You also get a <tt><a>KnownNat</a> n</tt>
--   constraint for the remainder of the do block.
--   
--   <pre>
--   -- If you had:
--   getAVector :: IO (Unsized.Vector Int)
--   
--   main :: IO ()
--   main = do
--       SomeSized v &lt;- getAVector -- v is `Sized.Vector n Int`
--       print v
--   
--       -- alternatively, get n in scope
--       SomeSized (v2 :: Sized.Vector n Int) &lt;- getAVector
--       print v2
--   </pre>
--   
--   Remember that the final type of the result of the do block
--   (<tt>()</tt>, here) must not depend on <tt>n</tt>. However, the
--   
--   Also useful in ghci, where you can pattern match to get sized vectors
--   from unsized vectors.
--   
--   <pre>
--   ghci&gt; SomeSized v &lt;- pure (myUnsizedVector :: Unsized.Vector Int)
--                -- ^ v is `Sized.Vector n Int`
--   </pre>
--   
--   This enables interactive exploration with sized vectors in ghci, and
--   is useful for using with other libraries and functions that expect
--   sized vectors in an interactive setting.
--   
--   (Note that as of GHC 8.6, you cannot get the <tt>n</tt> in scope in
--   your ghci session using ScopedTypeVariables, like you can with do
--   blocks)
--   
--   You can also use this as a constructor, to take a sized vector and
--   "hide" the size, to produce an unsized vector:
--   
--   <pre>
--   SomeSized :: Sized.Vector n a -&gt; Unsized.Vector a
--   </pre>
--   
--   Note that due to quirks in GHC pattern synonym completeness checking,
--   you will get incomplete pattern matches if you use this
--   polymorphically over different vector types, or you use any vector
--   type other than the three supported by this library (normal, storable,
--   unboxed).
pattern SomeSized :: forall v a (n :: Nat). Vector v a => KnownNat n => Vector v n a -> v a

-- | A wrapper to tag mutable vectors with a type level length.
--   
--   Be careful when using the constructor here to not construct sized
--   vectors which have a different length than that specified in the type
--   parameter!
data MVector (v :: Type -> Type -> Type) (n :: Nat) s a

-- | <i>O(1)</i> Yield the length of the vector as an <a>Int</a>. This is
--   more like <a>natVal</a> than <a>length</a>, extracting the value from
--   the <a>KnownNat</a> instance and not looking at the vector itself.
length :: forall (v :: Type -> Type) (n :: Nat) a. KnownNat n => Vector v n a -> Int

-- | <i>O(1)</i> Yield the length of the vector as a <a>Proxy</a>. This
--   function doesn't <i>do</i> anything; it merely allows the size
--   parameter of the vector to be passed around as a <a>Proxy</a>.
length' :: forall (v :: Type -> Type) (n :: Nat) a. Vector v n a -> Proxy n

-- | <i>O(1)</i> Reveal a <a>KnownNat</a> instance for a vector's length,
--   determined at runtime.
knownLength :: forall (v :: Type -> Type) (n :: Nat) a r. Vector v a => Vector v n a -> (KnownNat n => r) -> r

-- | <i>O(1)</i> Reveal a <a>KnownNat</a> instance and <a>Proxy</a> for a
--   vector's length, determined at runtime.
knownLength' :: forall (v :: Type -> Type) (n :: Nat) a r. Vector v a => Vector v n a -> (KnownNat n => Proxy n -> r) -> r

-- | <i>O(1)</i> Safe indexing using a <a>Finite</a>.
index :: forall (v :: Type -> Type) (n :: Nat) a. Vector v a => Vector v n a -> Finite n -> a

-- | <i>O(1)</i> Safe indexing using a <a>Proxy</a>.
index' :: forall (v :: Type -> Type) (n :: Nat) (m :: Natural) a p. (KnownNat n, Vector v a) => Vector v ((n + m) + 1) a -> p n -> a

-- | <i>O(1)</i> Indexing using an <a>Int</a> without bounds checking.
unsafeIndex :: forall (v :: Type -> Type) (n :: Nat) a. Vector v a => Vector v n a -> Int -> a

-- | <i>O(1)</i> Yield the first element of a non-empty vector.
head :: forall (v :: Type -> Type) (n :: Natural) a. Vector v a => Vector v (1 + n) a -> a

-- | <i>O(1)</i> Yield the last element of a non-empty vector.
last :: forall (v :: Type -> Type) (n :: Natural) a. Vector v a => Vector v (n + 1) a -> a

-- | <i>O(1)</i> Safe indexing in a monad.
--   
--   The monad allows operations to be strict in the vector when necessary.
--   Suppose vector copying is implemented like this:
--   
--   <pre>
--   copy mv v = ... write mv i (v ! i) ...
--   </pre>
--   
--   For lazy vectors, <tt>v ! i</tt> would not be evaluated, which means
--   that <tt>mv</tt> would unnecessarily retain a reference to <tt>v</tt>
--   in each element when written.
--   
--   With <a>indexM</a>, copying can be implemented like this instead:
--   
--   <pre>
--   copy mv v = ... do
--                    x &lt;- indexM v i
--                    write mv i x
--   </pre>
--   
--   Here, no references to <tt>v</tt> are retained, because indexing (but
--   <i>not</i> the elements) are evaluated eagerly.
indexM :: forall (v :: Type -> Type) (n :: Nat) a m. (Vector v a, Monad m) => Vector v n a -> Finite n -> m a

-- | <i>O(1)</i> Safe indexing in a monad using a <a>Proxy</a>. See the
--   documentation for <a>indexM</a> for an explanation of why this is
--   useful.
indexM' :: forall (v :: Type -> Type) (n :: Nat) (k :: Natural) a m p. (KnownNat n, Vector v a, Monad m) => Vector v (n + k) a -> p n -> m a

-- | <i>O(1)</i> Indexing using an Int without bounds checking. See the
--   documentation for <a>indexM</a> for an explanation of why this is
--   useful.
unsafeIndexM :: forall (v :: Type -> Type) (n :: Nat) a m. (Vector v a, Monad m) => Vector v n a -> Int -> m a

-- | <i>O(1)</i> Yield the first element of a non-empty vector in a monad.
--   See the documentation for <a>indexM</a> for an explanation of why this
--   is useful.
headM :: forall (v :: Type -> Type) (n :: Natural) a m. (Vector v a, Monad m) => Vector v (1 + n) a -> m a

-- | <i>O(1)</i> Yield the last element of a non-empty vector in a monad.
--   See the documentation for <a>indexM</a> for an explanation of why this
--   is useful.
lastM :: forall (v :: Type -> Type) (n :: Natural) a m. (Vector v a, Monad m) => Vector v (n + 1) a -> m a

-- | <i>O(1)</i> Yield a slice of the vector without copying it with an
--   inferred length argument.
slice :: forall (v :: Type -> Type) (i :: Nat) (n :: Nat) (m :: Natural) a p. (KnownNat i, KnownNat n, Vector v a) => p i -> Vector v ((i + n) + m) a -> Vector v n a

-- | <i>O(1)</i> Yield a slice of the vector without copying it with an
--   explicit length argument.
slice' :: forall (v :: Type -> Type) (i :: Nat) (n :: Nat) (m :: Natural) a p. (KnownNat i, KnownNat n, Vector v a) => p i -> p n -> Vector v ((i + n) + m) a -> Vector v n a

-- | <i>O(1)</i> Yield all but the last element of a non-empty vector
--   without copying.
init :: forall (v :: Type -> Type) (n :: Natural) a. Vector v a => Vector v (n + 1) a -> Vector v n a

-- | <i>O(1)</i> Yield all but the first element of a non-empty vector
--   without copying.
tail :: forall (v :: Type -> Type) (n :: Natural) a. Vector v a => Vector v (1 + n) a -> Vector v n a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements. The resulting vector
--   always contains this many elements. The length of the resulting vector
--   is inferred from the type.
take :: forall (v :: Type -> Type) (n :: Nat) (m :: Natural) a. (KnownNat n, Vector v a) => Vector v (n + m) a -> Vector v n a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements. The resulting vector
--   always contains this many elements. The length of the resulting vector
--   is given explicitly as a <a>Proxy</a> argument.
take' :: forall (v :: Type -> Type) (n :: Nat) (m :: Natural) a p. (KnownNat n, Vector v a) => p n -> Vector v (n + m) a -> Vector v n a

-- | <i>O(1)</i> Yield all but the the first <tt>n</tt> elements. The given
--   vector must contain at least this many elements. The length of the
--   resulting vector is inferred from the type.
drop :: forall (v :: Type -> Type) (n :: Nat) (m :: Natural) a. (KnownNat n, Vector v a) => Vector v (n + m) a -> Vector v m a

-- | <i>O(1)</i> Yield all but the the first <tt>n</tt> elements. The given
--   vector must contain at least this many elements. The length of the
--   resulting vector is givel explicitly as a <a>Proxy</a> argument.
drop' :: forall (v :: Type -> Type) (n :: Nat) (m :: Natural) a p. (KnownNat n, Vector v a) => p n -> Vector v (n + m) a -> Vector v m a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements, paired with the rest,
--   without copying. The lengths of the resulting vectors are inferred
--   from the type.
splitAt :: forall (v :: Type -> Type) (n :: Nat) (m :: Natural) a. (KnownNat n, Vector v a) => Vector v (n + m) a -> (Vector v n a, Vector v m a)

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements, paired with the rest,
--   without copying. The length of the first resulting vector is passed
--   explicitly as a <a>Proxy</a> argument.
splitAt' :: forall (v :: Type -> Type) (n :: Nat) (m :: Natural) a p. (KnownNat n, Vector v a) => p n -> Vector v (n + m) a -> (Vector v n a, Vector v m a)

-- | <i>O(1)</i> Empty vector.
empty :: forall (v :: Type -> Type) a. Vector v a => Vector v 0 a

-- | <i>O(1)</i> Vector with exactly one element.
singleton :: forall (v :: Type -> Type) a. Vector v a => a -> Vector v 1 a

-- | <i>O(n)</i> Construct a vector in a type-safe manner using a tuple.
--   <tt> fromTuple (1,2) :: Vector v 2 Int fromTuple ("hey", "what's",
--   "going", "on") :: Vector v 4 String </tt>
fromTuple :: forall (v :: Type -> Type) a input (length :: Nat). (Vector v a, IndexedListLiterals input length a, KnownNat length) => input -> Vector v length a

data BuildVector (n :: Nat) a

[Nil] :: forall a. BuildVector 0 a

[:<] :: forall a (n1 :: Natural). a -> BuildVector n1 a -> BuildVector (1 + n1) a
infixr 5 :<

-- | <i>O(n)</i> Construct a vector in a type-safe manner using a sized
--   linked list. <tt> Build (1 :&lt; 2 :&lt; 3 :&lt; Nil) :: Vector v 3
--   Int Build ("not" :&lt; "much" :&lt; Nil) :: Vector v 2 String </tt>
--   Can also be used as a pattern.
pattern Build :: Vector v a => BuildVector n a -> Vector v n a

-- | <i>O(n)</i> Construct a vector with the same element in each position
--   where the length is inferred from the type.
replicate :: forall (v :: Type -> Type) (n :: Nat) a. (KnownNat n, Vector v a) => a -> Vector v n a

-- | <i>O(n)</i> Construct a vector with the same element in each position
--   where the length is given explicitly as a <a>Proxy</a> argument.
replicate' :: forall (v :: Type -> Type) (n :: Nat) a p. (KnownNat n, Vector v a) => p n -> a -> Vector v n a

-- | <i>O(n)</i> Construct a vector of the given length by applying the
--   function to each index where the length is inferred from the type.
generate :: forall (v :: Type -> Type) (n :: Nat) a. (KnownNat n, Vector v a) => (Finite n -> a) -> Vector v n a

-- | <i>O(n)</i> Construct a vector of the given length by applying the
--   function to each index where the length is given explicitly as a
--   <a>Proxy</a> argument.
generate' :: forall (v :: Type -> Type) (n :: Nat) a p. (KnownNat n, Vector v a) => p n -> (Finite n -> a) -> Vector v n a

-- | <i>O(n)</i> Apply the function <tt>n</tt> times to a value. Zeroth
--   element is the original value. The length is inferred from the type.
iterateN :: forall (v :: Type -> Type) (n :: Nat) a. (KnownNat n, Vector v a) => (a -> a) -> a -> Vector v n a

-- | <i>O(n)</i> Apply the function <tt>n</tt> times to a value. Zeroth
--   element is the original value. The length is given explicitly as a
--   <a>Proxy</a> argument.
iterateN' :: forall (v :: Type -> Type) (n :: Nat) a p. (KnownNat n, Vector v a) => p n -> (a -> a) -> a -> Vector v n a

-- | <i>O(n)</i> Execute the monadic action <tt>n</tt> times and store the
--   results in a vector where <tt>n</tt> is inferred from the type.
replicateM :: forall (v :: Type -> Type) (n :: Nat) m a. (KnownNat n, Vector v a, Monad m) => m a -> m (Vector v n a)

-- | <i>O(n)</i> Execute the monadic action <tt>n</tt> times and store the
--   results in a vector where <tt>n</tt> is given explicitly as a
--   <a>Proxy</a> argument.
replicateM' :: forall (v :: Type -> Type) (n :: Nat) m a p. (KnownNat n, Vector v a, Monad m) => p n -> m a -> m (Vector v n a)

-- | <i>O(n)</i> Construct a vector of length <tt>n</tt> by applying the
--   monadic action to each index where <tt>n</tt> is inferred from the
--   type.
generateM :: forall (v :: Type -> Type) (n :: Nat) m a. (KnownNat n, Vector v a, Monad m) => (Finite n -> m a) -> m (Vector v n a)

-- | <i>O(n)</i> Construct a vector of length <tt>n</tt> by applying the
--   monadic action to each index where <tt>n</tt> is given explicitly as a
--   <a>Proxy</a> argument.
generateM' :: forall (v :: Type -> Type) (n :: Nat) m a p. (KnownNat n, Vector v a, Monad m) => p n -> (Finite n -> m a) -> m (Vector v n a)

-- | <i>O(n)</i> Construct a vector with exactly <tt>n</tt> elements by
--   repeatedly applying the generator function to the a seed. The length
--   is inferred from the type.
unfoldrN :: forall (v :: Type -> Type) (n :: Nat) a b. (KnownNat n, Vector v a) => (b -> (a, b)) -> b -> Vector v n a

-- | <i>O(n)</i> Construct a vector with exactly <tt>n</tt> elements by
--   repeatedly applying the generator function to the a seed. The length
--   is given explicitly as a <a>Proxy</a> argument.
unfoldrN' :: forall (v :: Type -> Type) (n :: Nat) a b p. (KnownNat n, Vector v a) => p n -> (b -> (a, b)) -> b -> Vector v n a

-- | <i>O(n)</i> Yield a vector of length <tt>n</tt> containing the values
--   <tt>x</tt>, <tt>x+1</tt>, ... <tt>x + (n - 1)</tt>. The length is
--   inferred from the type.
enumFromN :: forall (v :: Type -> Type) (n :: Nat) a. (KnownNat n, Vector v a, Num a) => a -> Vector v n a

-- | <i>O(n)</i> Yield a vector of length <tt>n</tt> containing the values
--   <tt>x</tt>, <tt>x+1</tt>, ..., <tt>x + (n - 1)</tt> The length is
--   given explicitly as a <a>Proxy</a> argument.
enumFromN' :: forall (v :: Type -> Type) (n :: Nat) a p. (KnownNat n, Vector v a, Num a) => a -> p n -> Vector v n a

-- | <i>O(n)</i> Yield a vector of the given length containing the values
--   <tt>x</tt>, <tt>x+y</tt>, <tt>x+2y</tt>, ... <tt>x + (n - 1)y</tt>.
--   The length is inferred from the type.
enumFromStepN :: forall (v :: Type -> Type) (n :: Nat) a. (KnownNat n, Vector v a, Num a) => a -> a -> Vector v n a

-- | <i>O(n)</i> Yield a vector of the given length containing the values
--   <tt>x</tt>, <tt>x+y</tt>, <tt>x+2y</tt>, ..., <tt>x + (n - 1)y</tt>.
--   The length is given explicitly as a <a>Proxy</a> argument.
enumFromStepN' :: forall (v :: Type -> Type) (n :: Nat) a p. (KnownNat n, Vector v a, Num a) => a -> a -> p n -> Vector v n a

-- | <i>O(n)</i> Prepend an element.
cons :: forall (v :: Type -> Type) (n :: Nat) a. Vector v a => a -> Vector v n a -> Vector v (1 + n) a

-- | <i>O(n)</i> Append an element.
snoc :: forall (v :: Type -> Type) (n :: Nat) a. Vector v a => Vector v n a -> a -> Vector v (n + 1) a

-- | <i>O(m+n)</i> Concatenate two vectors.
(++) :: forall (v :: Type -> Type) (n :: Nat) (m :: Nat) a. Vector v a => Vector v n a -> Vector v m a -> Vector v (n + m) a

-- | <i>O(n)</i> Yield the argument but force it not to retain any extra
--   memory, possibly by copying it.
--   
--   This is especially useful when dealing with slices. For example:
--   
--   <pre>
--   force (slice 0 2 &lt;huge vector&gt;)
--   </pre>
--   
--   Here, the slice retains a reference to the huge vector. Forcing it
--   creates a copy of just the elements that belong to the slice and
--   allows the huge vector to be garbage collected.
force :: forall (v :: Type -> Type) a (n :: Nat). Vector v a => Vector v n a -> Vector v n a

-- | <i>O(m+n)</i> For each pair <tt>(i,a)</tt> from the list, replace the
--   vector element at position <tt>i</tt> by <tt>a</tt>.
--   
--   <pre>
--   &lt;5,9,2,7&gt; // [(2,1),(0,3),(2,8)] = &lt;3,9,8,7&gt;
--   </pre>
(//) :: forall (v :: Type -> Type) a (m :: Nat). Vector v a => Vector v m a -> [(Finite m, a)] -> Vector v m a

-- | <i>O(m+n)</i> For each pair <tt>(i,a)</tt> from the vector of
--   index/value pairs, replace the vector element at position <tt>i</tt>
--   by <tt>a</tt>.
--   
--   <pre>
--   update &lt;5,9,2,7&gt; &lt;(2,1),(0,3),(2,8)&gt; = &lt;3,9,8,7&gt;
--   </pre>
update :: forall (v :: Type -> Type) a (m :: Nat) (n :: Nat). (Vector v a, Vector v (Int, a)) => Vector v m a -> Vector v n (Int, a) -> Vector v m a

-- | <i>O(m+n)</i> For each index <tt>i</tt> from the index vector and the
--   corresponding value <tt>a</tt> from the value vector, replace the
--   element of the initial vector at position <tt>i</tt> by <tt>a</tt>.
--   
--   <pre>
--   update_ &lt;5,9,2,7&gt;  &lt;2,0,2&gt; &lt;1,3,8&gt; = &lt;3,9,8,7&gt;
--   </pre>
--   
--   This function is useful for instances of <a>Vector</a> that cannot
--   store pairs. Otherwise, <a>update</a> is probably more convenient.
--   
--   <pre>
--   update_ xs is ys = <a>update</a> xs (<a>zip</a> is ys)
--   </pre>
update_ :: forall (v :: Type -> Type) a (m :: Nat) (n :: Nat). (Vector v a, Vector v Int) => Vector v m a -> Vector v n Int -> Vector v n a -> Vector v m a

-- | Same as (<a>//</a>) but without bounds checking.
unsafeUpd :: forall (v :: Type -> Type) a (m :: Nat). Vector v a => Vector v m a -> [(Int, a)] -> Vector v m a

-- | Same as <a>update</a> but without bounds checking.
unsafeUpdate :: forall (v :: Type -> Type) a (m :: Nat) (n :: Nat). (Vector v a, Vector v (Int, a)) => Vector v m a -> Vector v n (Int, a) -> Vector v m a

-- | Same as <a>update_</a> but without bounds checking.
unsafeUpdate_ :: forall (v :: Type -> Type) a (m :: Nat) (n :: Nat). (Vector v a, Vector v Int) => Vector v m a -> Vector v n Int -> Vector v n a -> Vector v m a

-- | <i>O(m+n)</i> For each pair <tt>(i,b)</tt> from the list, replace the
--   vector element <tt>a</tt> at position <tt>i</tt> by <tt>f a b</tt>.
--   
--   <pre>
--   accum (+) &lt;5,9,2&gt; [(2,4),(1,6),(0,3),(1,7)] = &lt;5+3, 9+6+7, 2+4&gt;
--   </pre>
accum :: forall (v :: Type -> Type) a b (m :: Nat). Vector v a => (a -> b -> a) -> Vector v m a -> [(Finite m, b)] -> Vector v m a

-- | <i>O(m+n)</i> For each pair <tt>(i,b)</tt> from the vector of pairs,
--   replace the vector element <tt>a</tt> at position <tt>i</tt> by <tt>f
--   a b</tt>.
--   
--   <pre>
--   accumulate (+) &lt;5,9,2&gt; &lt;(2,4),(1,6),(0,3),(1,7)&gt; = &lt;5+3, 9+6+7, 2+4&gt;
--   </pre>
accumulate :: forall (v :: Type -> Type) a b (m :: Nat) (n :: Nat). (Vector v a, Vector v (Int, b)) => (a -> b -> a) -> Vector v m a -> Vector v n (Int, b) -> Vector v m a

-- | <i>O(m+n)</i> For each index <tt>i</tt> from the index vector and the
--   corresponding value <tt>b</tt> from the the value vector, replace the
--   element of the initial vector at position <tt>i</tt> by <tt>f a
--   b</tt>.
--   
--   <pre>
--   accumulate_ (+) &lt;5,9,2&gt; &lt;2,1,0,1&gt; &lt;4,6,3,7&gt; = &lt;5+3, 9+6+7, 2+4&gt;
--   </pre>
--   
--   This function is useful for instances of <a>Vector</a> that cannot
--   store pairs. Otherwise, <a>accumulate</a> is probably more convenient:
--   
--   <pre>
--   accumulate_ f as is bs = <a>accumulate</a> f as (<a>zip</a> is bs)
--   </pre>
accumulate_ :: forall (v :: Type -> Type) a b (m :: Nat) (n :: Nat). (Vector v a, Vector v Int, Vector v b) => (a -> b -> a) -> Vector v m a -> Vector v n Int -> Vector v n b -> Vector v m a

-- | Same as <a>accum</a> but without bounds checking.
unsafeAccum :: forall (v :: Type -> Type) a b (m :: Nat). Vector v a => (a -> b -> a) -> Vector v m a -> [(Int, b)] -> Vector v m a

-- | Same as <a>accumulate</a> but without bounds checking.
unsafeAccumulate :: forall (v :: Type -> Type) a b (m :: Nat) (n :: Nat). (Vector v a, Vector v (Int, b)) => (a -> b -> a) -> Vector v m a -> Vector v n (Int, b) -> Vector v m a

-- | Same as <a>accumulate_</a> but without bounds checking.
unsafeAccumulate_ :: forall (v :: Type -> Type) a b (m :: Nat) (n :: Nat). (Vector v a, Vector v Int, Vector v b) => (a -> b -> a) -> Vector v m a -> Vector v n Int -> Vector v n b -> Vector v m a

-- | <i>O(n)</i> Reverse a vector
reverse :: forall (v :: Type -> Type) a (n :: Nat). Vector v a => Vector v n a -> Vector v n a

-- | <i>O(n)</i> Yield the vector obtained by replacing each element
--   <tt>i</tt> of the index vector by <tt>xs<tt>!</tt>i</tt>. This is
--   equivalent to <tt><a>map</a> (xs<tt>!</tt>) is</tt> but is often much
--   more efficient.
--   
--   <pre>
--   backpermute &lt;a,b,c,d&gt; &lt;0,3,2,3,1,0&gt; = &lt;a,d,c,d,b,a&gt;
--   </pre>
backpermute :: forall (v :: Type -> Type) a (m :: Nat) (n :: Nat). (Vector v a, Vector v Int) => Vector v m a -> Vector v n Int -> Vector v n a

-- | Same as <a>backpermute</a> but without bounds checking.
unsafeBackpermute :: forall (v :: Type -> Type) a (m :: Nat) (n :: Nat). (Vector v a, Vector v Int) => Vector v m a -> Vector v n Int -> Vector v n a

-- | Lens to access (<i>O(1)</i>) and update (<i>O(n)</i>) an arbitrary
--   element by its index.
ix :: forall (v :: Type -> Type) (n :: Nat) a f. (Vector v a, Functor f) => Finite n -> (a -> f a) -> Vector v n a -> f (Vector v n a)

-- | Type-safe lens to access (<i>O(1)</i>) and update (<i>O(n)</i>) an
--   arbitrary element by its index which should be supplied via
--   TypeApplications.
ix' :: forall (i :: Nat) (v :: Type -> Type) (n :: Nat) a f. (Vector v a, Functor f, KnownNat i, KnownNat n, (i + 1) <= n) => (a -> f a) -> Vector v n a -> f (Vector v n a)

-- | Lens to access (<i>O(1)</i>) and update (<i>O(n)</i>) the first
--   element of a non-empty vector.
_head :: forall (v :: Type -> Type) (n :: Natural) a f. (Vector v a, Functor f) => (a -> f a) -> Vector v (1 + n) a -> f (Vector v (1 + n) a)

-- | Lens to access (<i>O(1)</i>) and update (<i>O(n)</i>) the last element
--   of a non-empty vector.
_last :: forall (v :: Type -> Type) (n :: Natural) a f. (Vector v a, Functor f) => (a -> f a) -> Vector v (n + 1) a -> f (Vector v (n + 1) a)

-- | <i>O(n)</i> Pair each element in a vector with its index.
indexed :: forall (v :: Type -> Type) a (n :: Nat). (Vector v a, Vector v (Int, a), Vector v (Finite n, a)) => Vector v n a -> Vector v n (Finite n, a)

-- | <i>O(n)</i> Map a function over a vector.
map :: forall (v :: Type -> Type) a b (n :: Nat). (Vector v a, Vector v b) => (a -> b) -> Vector v n a -> Vector v n b

-- | <i>O(n)</i> Apply a function to every element of a vector and its
--   index.
imap :: forall (v :: Type -> Type) a b (n :: Nat). (Vector v a, Vector v b) => (Finite n -> a -> b) -> Vector v n a -> Vector v n b

-- | <i>O(n*m)</i> Map a function over a vector and concatenate the
--   results. The function is required to always return a vector of the
--   same length.
concatMap :: forall (v :: Type -> Type) a (v' :: Type -> Type) b (m :: Nat) (n :: Nat). (Vector v a, Vector v' b) => (a -> Vector v' m b) -> Vector v n a -> Vector v' (n * m) b

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector,
--   yielding a vector of results.
mapM :: forall m (v :: Type -> Type) a b (n :: Nat). (Monad m, Vector v a, Vector v b) => (a -> m b) -> Vector v n a -> m (Vector v n b)

-- | <i>O(n)</i> Apply the monadic action to every element of a vector and
--   its index, yielding a vector of results.
imapM :: forall m (v :: Type -> Type) a b (n :: Nat). (Monad m, Vector v a, Vector v b) => (Finite n -> a -> m b) -> Vector v n a -> m (Vector v n b)

-- | <i>O(n)</i> Apply the monadic action to all elements of a vector and
--   ignore the results.
mapM_ :: forall m (v :: Type -> Type) a b (n :: Nat). (Monad m, Vector v a) => (a -> m b) -> Vector v n a -> m ()

-- | <i>O(n)</i> Apply the monadic action to every element of a vector and
--   its index, ignoring the results.
imapM_ :: forall m (v :: Type -> Type) a (n :: Nat) b. (Monad m, Vector v a) => (Finite n -> a -> m b) -> Vector v n a -> m ()

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector,
--   yielding a vector of results. Equvalent to <tt>flip <a>mapM</a></tt>.
forM :: forall m (v :: Type -> Type) a b (n :: Nat). (Monad m, Vector v a, Vector v b) => Vector v n a -> (a -> m b) -> m (Vector v n b)

-- | <i>O(n)</i> Apply the monadic action to all elements of a vector and
--   ignore the results. Equivalent to <tt>flip <a>mapM_</a></tt>.
forM_ :: forall m (v :: Type -> Type) a (n :: Nat) b. (Monad m, Vector v a) => Vector v n a -> (a -> m b) -> m ()

-- | <i>O(n)</i> Zip two vectors of the same length with the given
--   function.
zipWith :: forall (v :: Type -> Type) a b c (n :: Nat). (Vector v a, Vector v b, Vector v c) => (a -> b -> c) -> Vector v n a -> Vector v n b -> Vector v n c

-- | Zip three vectors with the given function.
zipWith3 :: forall (v :: Type -> Type) a b c d (n :: Nat). (Vector v a, Vector v b, Vector v c, Vector v d) => (a -> b -> c -> d) -> Vector v n a -> Vector v n b -> Vector v n c -> Vector v n d
zipWith4 :: forall (v :: Type -> Type) a b c d e (n :: Nat). (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e) => (a -> b -> c -> d -> e) -> Vector v n a -> Vector v n b -> Vector v n c -> Vector v n d -> Vector v n e
zipWith5 :: forall (v :: Type -> Type) a b c d e f (n :: Nat). (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f) => (a -> b -> c -> d -> e -> f) -> Vector v n a -> Vector v n b -> Vector v n c -> Vector v n d -> Vector v n e -> Vector v n f
zipWith6 :: forall (v :: Type -> Type) a b c d e f g (n :: Nat). (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f, Vector v g) => (a -> b -> c -> d -> e -> f -> g) -> Vector v n a -> Vector v n b -> Vector v n c -> Vector v n d -> Vector v n e -> Vector v n f -> Vector v n g

-- | <i>O(n)</i> Zip two vectors of the same length with a function that
--   also takes the elements' indices).
izipWith :: forall (v :: Type -> Type) a b c (n :: Nat). (Vector v a, Vector v b, Vector v c) => (Finite n -> a -> b -> c) -> Vector v n a -> Vector v n b -> Vector v n c
izipWith3 :: forall (v :: Type -> Type) a b c d (n :: Nat). (Vector v a, Vector v b, Vector v c, Vector v d) => (Finite n -> a -> b -> c -> d) -> Vector v n a -> Vector v n b -> Vector v n c -> Vector v n d
izipWith4 :: forall (v :: Type -> Type) a b c d e (n :: Nat). (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e) => (Finite n -> a -> b -> c -> d -> e) -> Vector v n a -> Vector v n b -> Vector v n c -> Vector v n d -> Vector v n e
izipWith5 :: forall (v :: Type -> Type) a b c d e f (n :: Nat). (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f) => (Finite n -> a -> b -> c -> d -> e -> f) -> Vector v n a -> Vector v n b -> Vector v n c -> Vector v n d -> Vector v n e -> Vector v n f
izipWith6 :: forall (v :: Type -> Type) a b c d e f g (n :: Nat). (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f, Vector v g) => (Finite n -> a -> b -> c -> d -> e -> f -> g) -> Vector v n a -> Vector v n b -> Vector v n c -> Vector v n d -> Vector v n e -> Vector v n f -> Vector v n g

-- | <i>O(n)</i> Zip two vectors of the same length
zip :: forall (v :: Type -> Type) a b (n :: Nat). (Vector v a, Vector v b, Vector v (a, b)) => Vector v n a -> Vector v n b -> Vector v n (a, b)
zip3 :: forall (v :: Type -> Type) a b c (n :: Nat). (Vector v a, Vector v b, Vector v c, Vector v (a, b, c)) => Vector v n a -> Vector v n b -> Vector v n c -> Vector v n (a, b, c)
zip4 :: forall (v :: Type -> Type) a b c d (n :: Nat). (Vector v a, Vector v b, Vector v c, Vector v d, Vector v (a, b, c, d)) => Vector v n a -> Vector v n b -> Vector v n c -> Vector v n d -> Vector v n (a, b, c, d)
zip5 :: forall (v :: Type -> Type) a b c d e (n :: Nat). (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v (a, b, c, d, e)) => Vector v n a -> Vector v n b -> Vector v n c -> Vector v n d -> Vector v n e -> Vector v n (a, b, c, d, e)
zip6 :: forall (v :: Type -> Type) a b c d e f (n :: Nat). (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f, Vector v (a, b, c, d, e, f)) => Vector v n a -> Vector v n b -> Vector v n c -> Vector v n d -> Vector v n e -> Vector v n f -> Vector v n (a, b, c, d, e, f)

-- | <i>O(n)</i> Zip the two vectors of the same length with the monadic
--   action and yield a vector of results.
zipWithM :: forall m (v :: Type -> Type) a b c (n :: Nat). (Monad m, Vector v a, Vector v b, Vector v c) => (a -> b -> m c) -> Vector v n a -> Vector v n b -> m (Vector v n c)

-- | <i>O(n)</i> Zip the two vectors with a monadic action that also takes
--   the element index and yield a vector of results.
izipWithM :: forall m (v :: Type -> Type) a b c (n :: Nat). (Monad m, Vector v a, Vector v b, Vector v c) => (Finite n -> a -> b -> m c) -> Vector v n a -> Vector v n b -> m (Vector v n c)

-- | <i>O(n)</i> Zip the two vectors with the monadic action and ignore the
--   results.
zipWithM_ :: forall m (v :: Type -> Type) a b c (n :: Nat). (Monad m, Vector v a, Vector v b) => (a -> b -> m c) -> Vector v n a -> Vector v n b -> m ()

-- | <i>O(n)</i> Zip the two vectors with a monadic action that also takes
--   the element index and ignore the results.
izipWithM_ :: forall m (v :: Type -> Type) a b (n :: Nat) c. (Monad m, Vector v a, Vector v b) => (Finite n -> a -> b -> m c) -> Vector v n a -> Vector v n b -> m ()

-- | <i>O(min(m,n))</i> Unzip a vector of pairs.
unzip :: forall (v :: Type -> Type) a b (n :: Nat). (Vector v a, Vector v b, Vector v (a, b)) => Vector v n (a, b) -> (Vector v n a, Vector v n b)
unzip3 :: forall (v :: Type -> Type) a b c (n :: Nat). (Vector v a, Vector v b, Vector v c, Vector v (a, b, c)) => Vector v n (a, b, c) -> (Vector v n a, Vector v n b, Vector v n c)
unzip4 :: forall (v :: Type -> Type) a b c d (n :: Nat). (Vector v a, Vector v b, Vector v c, Vector v d, Vector v (a, b, c, d)) => Vector v n (a, b, c, d) -> (Vector v n a, Vector v n b, Vector v n c, Vector v n d)
unzip5 :: forall (v :: Type -> Type) a b c d e (n :: Nat). (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v (a, b, c, d, e)) => Vector v n (a, b, c, d, e) -> (Vector v n a, Vector v n b, Vector v n c, Vector v n d, Vector v n e)
unzip6 :: forall (v :: Type -> Type) a b c d e f (n :: Nat). (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f, Vector v (a, b, c, d, e, f)) => Vector v n (a, b, c, d, e, f) -> (Vector v n a, Vector v n b, Vector v n c, Vector v n d, Vector v n e, Vector v n f)

-- | <i>O(n)</i> Check if the vector contains an element.
elem :: forall (v :: Type -> Type) a (n :: Nat). (Vector v a, Eq a) => a -> Vector v n a -> Bool
infix 4 `elem`

-- | <i>O(n)</i> Check if the vector does not contain an element (inverse
--   of <a>elem</a>).
notElem :: forall (v :: Type -> Type) a (n :: Nat). (Vector v a, Eq a) => a -> Vector v n a -> Bool
infix 4 `notElem`

-- | <i>O(n)</i> Yield <a>Just</a> the first element matching the predicate
--   or <a>Nothing</a> if no such element exists.
find :: forall (v :: Type -> Type) a (n :: Nat). Vector v a => (a -> Bool) -> Vector v n a -> Maybe a

-- | <i>O(n)</i> Yield <a>Just</a> the index of the first element matching
--   the predicate or <a>Nothing</a> if no such element exists.
findIndex :: forall (v :: Type -> Type) a (n :: Nat). Vector v a => (a -> Bool) -> Vector v n a -> Maybe (Finite n)

-- | <i>O(n)</i> Yield <a>Just</a> the index of the first occurence of the
--   given element or <a>Nothing</a> if the vector does not contain the
--   element. This is a specialised version of <a>findIndex</a>.
elemIndex :: forall (v :: Type -> Type) a (n :: Nat). (Vector v a, Eq a) => a -> Vector v n a -> Maybe (Finite n)

-- | <i>O(n)</i> Left fold.
foldl :: forall (v :: Type -> Type) b a (n :: Nat). Vector v b => (a -> b -> a) -> a -> Vector v n b -> a

-- | <i>O(n)</i> Left fold on non-empty vectors.
foldl1 :: forall (v :: Type -> Type) a (n :: Natural). Vector v a => (a -> a -> a) -> Vector v (1 + n) a -> a

-- | <i>O(n)</i> Left fold with strict accumulator.
foldl' :: forall (v :: Type -> Type) b a (n :: Nat). Vector v b => (a -> b -> a) -> a -> Vector v n b -> a

-- | <i>O(n)</i> Left fold on non-empty vectors with strict accumulator.
foldl1' :: forall (v :: Type -> Type) a (n :: Natural). Vector v a => (a -> a -> a) -> Vector v (1 + n) a -> a

-- | <i>O(n)</i> Right fold.
foldr :: forall (v :: Type -> Type) a b (n :: Nat). Vector v a => (a -> b -> b) -> b -> Vector v n a -> b

-- | <i>O(n)</i> Right fold on non-empty vectors.
foldr1 :: forall (v :: Type -> Type) a (n :: Natural). Vector v a => (a -> a -> a) -> Vector v (n + 1) a -> a

-- | <i>O(n)</i> Right fold with a strict accumulator.
foldr' :: forall (v :: Type -> Type) a b (n :: Nat). Vector v a => (a -> b -> b) -> b -> Vector v n a -> b

-- | <i>O(n)</i> Right fold on non-empty vectors with strict accumulator.
foldr1' :: forall (v :: Type -> Type) a (n :: Natural). Vector v a => (a -> a -> a) -> Vector v (n + 1) a -> a

-- | <i>O(n)</i> Left fold (function applied to each element and its
--   index).
ifoldl :: forall (v :: Type -> Type) b a (n :: Nat). Vector v b => (a -> Finite n -> b -> a) -> a -> Vector v n b -> a

-- | <i>O(n)</i> Left fold with strict accumulator (function applied to
--   each element and its index).
ifoldl' :: forall (v :: Type -> Type) b a (n :: Nat). Vector v b => (a -> Finite n -> b -> a) -> a -> Vector v n b -> a

-- | <i>O(n)</i> Right fold (function applied to each element and its
--   index).
ifoldr :: forall (v :: Type -> Type) a (n :: Nat) b. Vector v a => (Finite n -> a -> b -> b) -> b -> Vector v n a -> b

-- | <i>O(n)</i> Right fold with strict accumulator (function applied to
--   each element and its index).
ifoldr' :: forall (v :: Type -> Type) a (n :: Nat) b. Vector v a => (Finite n -> a -> b -> b) -> b -> Vector v n a -> b

-- | <i>O(n)</i> Check if all elements satisfy the predicate.
all :: forall (v :: Type -> Type) a (n :: Nat). Vector v a => (a -> Bool) -> Vector v n a -> Bool

-- | <i>O(n)</i> Check if any element satisfies the predicate.
any :: forall (v :: Type -> Type) a (n :: Nat). Vector v a => (a -> Bool) -> Vector v n a -> Bool

-- | <i>O(n)</i> Check if all elements are <a>True</a>
and :: forall (v :: Type -> Type) (n :: Nat). Vector v Bool => Vector v n Bool -> Bool

-- | <i>O(n)</i> Check if any element is <a>True</a>
or :: forall (v :: Type -> Type) (n :: Nat). Vector v Bool => Vector v n Bool -> Bool

-- | <i>O(n)</i> Compute the sum of the elements.
sum :: forall (v :: Type -> Type) a (n :: Nat). (Vector v a, Num a) => Vector v n a -> a

-- | <i>O(n)</i> Compute the product of the elements.
product :: forall (v :: Type -> Type) a (n :: Nat). (Vector v a, Num a) => Vector v n a -> a

-- | <i>O(n)</i> Yield the maximum element of the non-empty vector.
maximum :: forall (v :: Type -> Type) a (n :: Natural). (Vector v a, Ord a) => Vector v (n + 1) a -> a

-- | <i>O(n)</i> Yield the maximum element of the non-empty vector
--   according to the given comparison function.
maximumBy :: forall (v :: Type -> Type) a (n :: Natural). Vector v a => (a -> a -> Ordering) -> Vector v (n + 1) a -> a

-- | <i>O(n)</i> Yield the minimum element of the non-empty vector.
minimum :: forall (v :: Type -> Type) a (n :: Natural). (Vector v a, Ord a) => Vector v (n + 1) a -> a

-- | <i>O(n)</i> Yield the minimum element of the non-empty vector
--   according to the given comparison function.
minimumBy :: forall (v :: Type -> Type) a (n :: Natural). Vector v a => (a -> a -> Ordering) -> Vector v (n + 1) a -> a

-- | <i>O(n)</i> Yield the index of the maximum element of the non-empty
--   vector.
maxIndex :: forall (v :: Type -> Type) a (n :: Natural). (Vector v a, Ord a) => Vector v (n + 1) a -> Finite (n + 1)

-- | <i>O(n)</i> Yield the index of the maximum element of the non-empty
--   vector according to the given comparison function.
maxIndexBy :: forall (v :: Type -> Type) a (n :: Natural). Vector v a => (a -> a -> Ordering) -> Vector v (n + 1) a -> Finite (n + 1)

-- | <i>O(n)</i> Yield the index of the minimum element of the non-empty
--   vector.
minIndex :: forall (v :: Type -> Type) a (n :: Natural). (Vector v a, Ord a) => Vector v (n + 1) a -> Finite (n + 1)

-- | <i>O(n)</i> Yield the index of the minimum element of the non-empty
--   vector according to the given comparison function.
minIndexBy :: forall (v :: Type -> Type) a (n :: Natural). Vector v a => (a -> a -> Ordering) -> Vector v (n + 1) a -> Finite (n + 1)

-- | <i>O(n)</i> Monadic fold.
foldM :: forall m (v :: Type -> Type) b a (n :: Nat). (Monad m, Vector v b) => (a -> b -> m a) -> a -> Vector v n b -> m a

-- | <i>O(n)</i> Monadic fold (action applied to each element and its
--   index).
ifoldM :: forall m (v :: Type -> Type) b a (n :: Nat). (Monad m, Vector v b) => (a -> Finite n -> b -> m a) -> a -> Vector v n b -> m a

-- | <i>O(n)</i> Monadic fold over non-empty vectors.
fold1M :: forall m (v :: Type -> Type) a (n :: Natural). (Monad m, Vector v a) => (a -> a -> m a) -> Vector v (1 + n) a -> m a

-- | <i>O(n)</i> Monadic fold with strict accumulator.
foldM' :: forall m (v :: Type -> Type) b a (n :: Nat). (Monad m, Vector v b) => (a -> b -> m a) -> a -> Vector v n b -> m a

-- | <i>O(n)</i> Monadic fold with strict accumulator (action applied to
--   each element and its index).
ifoldM' :: forall m (v :: Type -> Type) b a (n :: Nat). (Monad m, Vector v b) => (a -> Finite n -> b -> m a) -> a -> Vector v n b -> m a

-- | <i>O(n)</i> Monadic fold over non-empty vectors with strict
--   accumulator.
fold1M' :: forall m (v :: Type -> Type) a (n :: Natural). (Monad m, Vector v a) => (a -> a -> m a) -> Vector v (n + 1) a -> m a

-- | <i>O(n)</i> Monadic fold that discards the result.
foldM_ :: forall m (v :: Type -> Type) b a (n :: Nat). (Monad m, Vector v b) => (a -> b -> m a) -> a -> Vector v n b -> m ()

-- | <i>O(n)</i> Monadic fold that discards the result (action applied to
--   each element and its index).
ifoldM_ :: forall m (v :: Type -> Type) b a (n :: Nat). (Monad m, Vector v b) => (a -> Finite n -> b -> m a) -> a -> Vector v n b -> m ()

-- | <i>O(n)</i> Monadic fold over non-empty vectors that discards the
--   result.
fold1M_ :: forall m (v :: Type -> Type) a (n :: Natural). (Monad m, Vector v a) => (a -> a -> m a) -> Vector v (n + 1) a -> m ()

-- | <i>O(n)</i> Monadic fold with strict accumulator that discards the
--   result.
foldM'_ :: forall m (v :: Type -> Type) b a (n :: Nat). (Monad m, Vector v b) => (a -> b -> m a) -> a -> Vector v n b -> m ()

-- | <i>O(n)</i> Monadic fold with strict accumulator that discards the
--   result (action applied to each element and its index).
ifoldM'_ :: forall m (v :: Type -> Type) b a (n :: Nat). (Monad m, Vector v b) => (a -> Finite n -> b -> m a) -> a -> Vector v n b -> m ()

-- | <i>O(n)</i> Monad fold over non-empty vectors with strict accumulator
--   that discards the result.
fold1M'_ :: forall m (v :: Type -> Type) a (n :: Natural). (Monad m, Vector v a) => (a -> a -> m a) -> Vector v (n + 1) a -> m ()

-- | Evaluate each action and collect the results.
sequence :: forall m (v :: Type -> Type) a (n :: Nat). (Monad m, Vector v a, Vector v (m a)) => Vector v n (m a) -> m (Vector v n a)

-- | Evaluate each action and discard the results.
sequence_ :: forall m (v :: Type -> Type) a (n :: Nat). (Monad m, Vector v (m a)) => Vector v n (m a) -> m ()

-- | <i>O(n)</i> Prescan
--   
--   <pre>
--   prescanl f z = <a>init</a> . <a>scanl</a> f z
--   </pre>
--   
--   Example: <tt>prescanl (+) 0 &lt;1,2,3,4&gt; = &lt;0,1,3,6&gt;</tt>
prescanl :: forall (v :: Type -> Type) a b (n :: Nat). (Vector v a, Vector v b) => (a -> b -> a) -> a -> Vector v n b -> Vector v n a

-- | <i>O(n)</i> Prescan with strict accumulator.
prescanl' :: forall (v :: Type -> Type) a b (n :: Nat). (Vector v a, Vector v b) => (a -> b -> a) -> a -> Vector v n b -> Vector v n a

-- | <i>O(n)</i> Scan
postscanl :: forall (v :: Type -> Type) a b (n :: Nat). (Vector v a, Vector v b) => (a -> b -> a) -> a -> Vector v n b -> Vector v n a

-- | <i>O(n)</i> Scan with strict accumulator.
postscanl' :: forall (v :: Type -> Type) a b (n :: Nat). (Vector v a, Vector v b) => (a -> b -> a) -> a -> Vector v n b -> Vector v n a

-- | <i>O(n)</i> Haskell-style scan.
scanl :: forall (v :: Type -> Type) a b (n :: Nat). (Vector v a, Vector v b) => (a -> b -> a) -> a -> Vector v n b -> Vector v (1 + n) a

-- | <i>O(n)</i> Haskell-style scan with strict accumulator.
scanl' :: forall (v :: Type -> Type) a b (n :: Nat). (Vector v a, Vector v b) => (a -> b -> a) -> a -> Vector v n b -> Vector v (1 + n) a

-- | <i>O(n)</i> Scan over a non-empty vector.
scanl1 :: forall (v :: Type -> Type) a (n :: Natural). Vector v a => (a -> a -> a) -> Vector v (1 + n) a -> Vector v (2 + n) a

-- | <i>O(n)</i> Scan over a non-empty vector with a strict accumulator.
scanl1' :: forall (v :: Type -> Type) a (n :: Natural). Vector v a => (a -> a -> a) -> Vector v (1 + n) a -> Vector v (2 + n) a

-- | <i>O(n)</i> Right-to-left prescan.
prescanr :: forall (v :: Type -> Type) a b (n :: Nat). (Vector v a, Vector v b) => (a -> b -> b) -> b -> Vector v n a -> Vector v n b

-- | <i>O(n)</i> Right-to-left prescan with strict accumulator.
prescanr' :: forall (v :: Type -> Type) a b (n :: Nat). (Vector v a, Vector v b) => (a -> b -> b) -> b -> Vector v n a -> Vector v n b

-- | <i>O(n)</i> Right-to-left scan.
postscanr :: forall (v :: Type -> Type) a b (n :: Nat). (Vector v a, Vector v b) => (a -> b -> b) -> b -> Vector v n a -> Vector v n b

-- | <i>O(n)</i> Right-to-left scan with strict accumulator.
postscanr' :: forall (v :: Type -> Type) a b (n :: Nat). (Vector v a, Vector v b) => (a -> b -> b) -> b -> Vector v n a -> Vector v n b

-- | <i>O(n)</i> Right-to-left Haskell-style scan.
scanr :: forall (v :: Type -> Type) a b (n :: Nat). (Vector v a, Vector v b) => (a -> b -> b) -> b -> Vector v n a -> Vector v (n + 1) b

-- | <i>O(n)</i> Right-to-left Haskell-style scan with strict accumulator.
scanr' :: forall (v :: Type -> Type) a b (n :: Nat). (Vector v a, Vector v b) => (a -> b -> b) -> b -> Vector v n a -> Vector v (n + 1) b

-- | <i>O(n)</i> Right-to-left scan over a non-empty vector.
scanr1 :: forall (v :: Type -> Type) a (n :: Natural). Vector v a => (a -> a -> a) -> Vector v (n + 1) a -> Vector v (n + 2) a

-- | <i>O(n)</i> Right-to-left scan over a non-empty vector with a strict
--   accumulator.
scanr1' :: forall (v :: Type -> Type) a (n :: Natural). Vector v a => (a -> a -> a) -> Vector v (n + 1) a -> Vector v (n + 2) a

-- | <i>O(n)</i> Convert a vector to a list.
toList :: forall (v :: Type -> Type) a (n :: Nat). Vector v a => Vector v n a -> [a]

-- | <i>O(n)</i> Convert a list to a vector.
fromList :: forall (v :: Type -> Type) a (n :: Nat). (Vector v a, KnownNat n) => [a] -> Maybe (Vector v n a)

-- | <i>O(n)</i> Convert the first <tt>n</tt> elements of a list to a
--   vector. The length of the resultant vector is inferred from the type.
fromListN :: forall (v :: Type -> Type) (n :: Nat) a. (Vector v a, KnownNat n) => [a] -> Maybe (Vector v n a)

-- | <i>O(n)</i> Convert the first <tt>n</tt> elements of a list to a
--   vector. The length of the resultant vector is given explicitly as a
--   <a>Proxy</a> argument.
fromListN' :: forall (v :: Type -> Type) (n :: Nat) a p. (Vector v a, KnownNat n) => p n -> [a] -> Maybe (Vector v n a)

-- | <i>O(n)</i> Takes a list and returns a continuation providing a vector
--   with a size parameter corresponding to the length of the list.
--   
--   Essentially converts a list into a vector with the proper size
--   parameter, determined at runtime.
--   
--   See <a>withSized</a>
withSizedList :: forall (v :: Type -> Type) a r. Vector v a => [a] -> (forall (n :: Nat). KnownNat n => Vector v n a -> r) -> r

-- | <i>O(n)</i> Convert different vector types.
convert :: forall (v :: Type -> Type) a (w :: Type -> Type) (n :: Nat). (Vector v a, Vector w a) => Vector v n a -> Vector w n a

-- | <i>O(n)</i> Yield an immutable copy of the mutable vector.
freeze :: forall m (v :: Type -> Type) a (n :: Nat). (PrimMonad m, Vector v a) => MVector (Mutable v) n (PrimState m) a -> m (Vector v n a)

-- | <i>O(n)</i> Yield a mutable copy of the immutable vector.
thaw :: forall m (v :: Type -> Type) a (n :: Nat). (PrimMonad m, Vector v a) => Vector v n a -> m (MVector (Mutable v) n (PrimState m) a)

-- | <i>O(n)</i> Copy an immutable vector into a mutable one.
copy :: forall m (v :: Type -> Type) a (n :: Nat). (PrimMonad m, Vector v a) => MVector (Mutable v) n (PrimState m) a -> Vector v n a -> m ()

-- | <i>O(1)</i> Unsafely convert a mutable vector to an immutable one
--   withouy copying. The mutable vector may not be used after this
--   operation.
unsafeFreeze :: forall m (v :: Type -> Type) a (n :: Nat). (PrimMonad m, Vector v a) => MVector (Mutable v) n (PrimState m) a -> m (Vector v n a)

-- | <i>O(n)</i> Unsafely convert an immutable vector to a mutable one
--   without copying. The immutable vector may not be used after this
--   operation.
unsafeThaw :: forall m (v :: Type -> Type) a (n :: Nat). (PrimMonad m, Vector v a) => Vector v n a -> m (MVector (Mutable v) n (PrimState m) a)

-- | Convert a <a>Vector</a> into a <a>Vector</a> if it has the correct
--   size, otherwise return Nothing.
toSized :: forall v (n :: Nat) a. (Vector v a, KnownNat n) => v a -> Maybe (Vector v n a)

-- | Takes a <a>Vector</a> and returns a continuation providing a
--   <a>Sized</a> with a size parameter <tt>n</tt> that is determined at
--   runtime based on the length of the input vector.
--   
--   Essentially converts a <a>Vector</a> into a <a>Vector</a> with the
--   correct size parameter <tt>n</tt>.
withSized :: Vector v a => v a -> (forall (n :: Nat). KnownNat n => Vector v n a -> r) -> r
fromSized :: forall v (n :: Nat) a. Vector v n a -> v a

-- | Apply a function on unsized vectors to a sized vector. The function
--   must preserve the size of the vector, this is not checked.
withVectorUnsafe :: forall v a w b (n :: Nat). (v a -> w b) -> Vector v n a -> Vector w n b

-- | Apply a function on two unsized vectors to sized vectors. The function
--   must preserve the size of the vectors, this is not checked.
zipVectorsUnsafe :: forall u a v b w c (n :: Nat). (u a -> v b -> w c) -> Vector u n a -> Vector v n b -> Vector w n c
instance GHC.Internal.TypeNats.KnownNat n => GHC.Internal.Base.Applicative (Data.Vector.Generic.Sized.Internal.Vector Data.Vector.Vector n)
instance (Data.Vector.Generic.Base.Vector v a, Data.Binary.Class.Binary a, GHC.Internal.TypeNats.KnownNat n) => Data.Binary.Class.Binary (Data.Vector.Generic.Sized.Internal.Vector v n a)
instance (Data.Vector.Generic.Base.Vector v a, GHC.Internal.Bits.Bits (v a), GHC.Internal.Bits.Bits a, GHC.Internal.TypeNats.KnownNat n) => GHC.Internal.Bits.Bits (Data.Vector.Generic.Sized.Internal.Vector v n a)
instance (GHC.Internal.TypeNats.KnownNat n, n GHC.Types.~ (1 GHC.Internal.TypeNats.+ m)) => Control.Comonad.ComonadApply (Data.Vector.Generic.Sized.Internal.Vector Data.Vector.Vector n)
instance (GHC.Internal.TypeNats.KnownNat n, n GHC.Types.~ (1 GHC.Internal.TypeNats.+ m)) => Control.Comonad.Comonad (Data.Vector.Generic.Sized.Internal.Vector Data.Vector.Vector n)
instance GHC.Internal.TypeNats.KnownNat n => Data.Distributive.Distributive (Data.Vector.Generic.Sized.Internal.Vector Data.Vector.Vector n)
instance (Data.Vector.Generic.Base.Vector v a, GHC.Internal.Bits.Bits (v a), GHC.Internal.Bits.FiniteBits a, GHC.Internal.TypeNats.KnownNat n) => GHC.Internal.Bits.FiniteBits (Data.Vector.Generic.Sized.Internal.Vector v n a)
instance (Data.Vector.Generic.Base.Vector v a, GHC.Internal.Float.Floating a, GHC.Internal.TypeNats.KnownNat n) => GHC.Internal.Float.Floating (Data.Vector.Generic.Sized.Internal.Vector v n a)
instance WithIndex.FoldableWithIndex (Data.Finite.Internal.Finite n) (Data.Vector.Generic.Sized.Internal.Vector Data.Vector.Vector n)
instance (Data.Vector.Generic.Base.Vector v a, GHC.Internal.Real.Fractional a, GHC.Internal.TypeNats.KnownNat n) => GHC.Internal.Real.Fractional (Data.Vector.Generic.Sized.Internal.Vector v n a)
instance WithIndex.FunctorWithIndex (Data.Finite.Internal.Finite n) (Data.Vector.Generic.Sized.Internal.Vector Data.Vector.Vector n)
instance (GHC.Classes.Eq a, Data.Hashable.Class.Hashable a) => Data.Hashable.Class.Hashable (Data.Vector.Generic.Sized.Internal.Vector Data.Vector.Vector n a)
instance (GHC.Classes.Eq a, Data.Hashable.Class.Hashable a, GHC.Internal.Foreign.Storable.Storable a) => Data.Hashable.Class.Hashable (Data.Vector.Generic.Sized.Internal.Vector Data.Vector.Storable.Vector n a)
instance (GHC.Classes.Eq a, Data.Hashable.Class.Hashable a, Data.Vector.Unboxed.Base.Unbox a) => Data.Hashable.Class.Hashable (Data.Vector.Generic.Sized.Internal.Vector Data.Vector.Unboxed.Base.Vector n a)
instance GHC.Internal.TypeNats.KnownNat n => GHC.Internal.Base.Monad (Data.Vector.Generic.Sized.Internal.Vector Data.Vector.Vector n)
instance (GHC.Internal.Base.Monoid m, Data.Vector.Generic.Base.Vector v m, GHC.Internal.TypeNats.KnownNat n) => GHC.Internal.Base.Monoid (Data.Vector.Generic.Sized.Internal.Vector v n m)
instance (Data.Vector.Generic.Base.Vector v a, GHC.Internal.Num.Num a, GHC.Internal.TypeNats.KnownNat n) => GHC.Internal.Num.Num (Data.Vector.Generic.Sized.Internal.Vector v n a)
instance (GHC.Internal.TypeNats.KnownNat n, Data.Vector.Generic.Base.Vector v a, GHC.Internal.Read.Read (v a)) => GHC.Internal.Read.Read (Data.Vector.Generic.Sized.Internal.Vector v n a)
instance GHC.Internal.TypeNats.KnownNat n => Data.Functor.Rep.Representable (Data.Vector.Generic.Sized.Internal.Vector Data.Vector.Vector n)
instance (GHC.Internal.Base.Semigroup g, Data.Vector.Generic.Base.Vector v g) => GHC.Internal.Base.Semigroup (Data.Vector.Generic.Sized.Internal.Vector v n g)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Data.Vector.Generic.Sized.BuildVector n a)
instance (GHC.Internal.TypeNats.KnownNat n, GHC.Internal.Foreign.Storable.Storable a, Data.Vector.Generic.Base.Vector v a) => GHC.Internal.Foreign.Storable.Storable (Data.Vector.Generic.Sized.Internal.Vector v n a)
instance WithIndex.TraversableWithIndex (Data.Finite.Internal.Finite n) (Data.Vector.Generic.Sized.Internal.Vector Data.Vector.Vector n)


-- | This module re-exports the functionality in <a>Sized</a> specialized
--   to <a>Mutable</a>.
--   
--   Functions returning a vector determine the size from the type context
--   unless they have a <tt>'</tt> suffix in which case they take an
--   explicit <a>Proxy</a> argument.
--   
--   Functions where the resulting vector size is not known until runtime
--   are not exported.
module Data.Vector.Mutable.Sized

-- | <a>Vector</a> specialized to use <a>Mutable</a>.
type MVector = MVector MVector

-- | <i>O(1)</i> Yield the length of the mutable vector as an <a>Int</a>.
length :: forall (n :: Nat) s a. KnownNat n => MVector n s a -> Int

-- | <i>O(1)</i> Yield the length of the mutable vector as a <a>Proxy</a>.
length' :: forall (n :: Nat) s a. MVector n s a -> Proxy n

-- | <i>O(1)</i> Check whether the mutable vector is empty.
null :: forall (n :: Nat) s a. KnownNat n => MVector n s a -> Bool

-- | <i>O(1)</i> Yield a slice of the mutable vector without copying it
--   with an inferred length argument.
slice :: forall (i :: Nat) (n :: Nat) (k :: Natural) s a p. (KnownNat i, KnownNat n) => p i -> MVector ((i + n) + k) s a -> MVector n s a

-- | <i>O(1)</i> Yield a slice of the mutable vector without copying it
--   with an explicit length argument.
slice' :: forall (i :: Nat) (n :: Nat) (k :: Natural) s a p. (KnownNat i, KnownNat n) => p i -> p n -> MVector ((i + n) + k) s a -> MVector n s a

-- | <i>O(1)</i> Yield all but the last element of a non-empty mutable
--   vector without copying.
init :: forall (n :: Natural) s a. MVector (n + 1) s a -> MVector n s a

-- | <i>O(1)</i> Yield all but the first element of a non-empty mutable
--   vector without copying.
tail :: forall (n :: Natural) s a. MVector (1 + n) s a -> MVector n s a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements. The resulting vector
--   always contains this many elements. The length of the resulting vector
--   is inferred from the type.
take :: forall (n :: Nat) (k :: Natural) s a. KnownNat n => MVector (n + k) s a -> MVector n s a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements. The resulting vector
--   always contains this many elements. The length of the resulting vector
--   is given explicitly as a <a>Proxy</a> argument.
take' :: forall (n :: Nat) (k :: Natural) s a p. KnownNat n => p n -> MVector (n + k) s a -> MVector n s a

-- | <i>O(1)</i> Yield all but the the first <tt>n</tt> elements. The given
--   vector must contain at least this many elements. The length of the
--   resulting vector is inferred from the type.
drop :: forall (n :: Nat) (k :: Natural) s a. KnownNat n => MVector (n + k) s a -> MVector k s a

-- | <i>O(1)</i> Yield all but the the first <tt>n</tt> elements. The given
--   vector must contain at least this many elements. The length of the
--   resulting vector is given explicitly as a <a>Proxy</a> argument.
drop' :: forall (n :: Nat) (k :: Natural) s a p. KnownNat n => p n -> MVector (n + k) s a -> MVector k s a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements, paired with the rest,
--   without copying. The lengths of the resulting vectors are inferred
--   from the type.
splitAt :: forall (n :: Nat) (m :: Natural) s a. KnownNat n => MVector (n + m) s a -> (MVector n s a, MVector m s a)

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements, paired with the rest,
--   without copying. The length of the first resulting vector is passed
--   explicitly as a <a>Proxy</a> argument.
splitAt' :: forall (n :: Nat) (m :: Natural) s a p. KnownNat n => p n -> MVector (n + m) s a -> (MVector n s a, MVector m s a)

-- | <i>O(1)</i> Check if two vectors overlap.
overlaps :: forall (n :: Nat) (k :: Nat) s a. MVector n s a -> MVector k s a -> Bool

-- | Create a mutable vector where the length is inferred from the type.
new :: forall (n :: Nat) m a. (KnownNat n, PrimMonad m) => m (MVector n (PrimState m) a)

-- | Create a mutable vector where the length is inferred from the type.
--   The memory is not initialized.
unsafeNew :: forall (n :: Nat) m a. (KnownNat n, PrimMonad m) => m (MVector n (PrimState m) a)

-- | Create a mutable vector where the length is inferred from the type and
--   fill it with an initial value.
replicate :: forall (n :: Nat) m a. (KnownNat n, PrimMonad m) => a -> m (MVector n (PrimState m) a)

-- | Create a mutable vector where the length is given explicitly as a
--   <a>Proxy</a> argument and fill it with an initial value.
replicate' :: forall (n :: Nat) m a p. (KnownNat n, PrimMonad m) => p n -> a -> m (MVector n (PrimState m) a)

-- | Create a mutable vector where the length is inferred from the type and
--   fill it with values produced by repeatedly executing the monadic
--   action.
replicateM :: forall (n :: Nat) m a. (KnownNat n, PrimMonad m) => m a -> m (MVector n (PrimState m) a)

-- | Create a mutable vector where the length is given explicitly as a
--   <a>Proxy</a> argument and fill it with values produced by repeatedly
--   executing the monadic action.
replicateM' :: forall (n :: Nat) m a p. (KnownNat n, PrimMonad m) => p n -> m a -> m (MVector n (PrimState m) a)

-- | Create a copy of a mutable vector.
clone :: forall (n :: Nat) m a. PrimMonad m => MVector n (PrimState m) a -> m (MVector n (PrimState m) a)

-- | Grow a mutable vector by an amount given explicitly as a <a>Proxy</a>
--   argument.
grow :: forall (n :: Nat) (k :: Nat) m a p. (KnownNat k, PrimMonad m) => p k -> MVector n (PrimState m) a -> m (MVector (n + k) (PrimState m) a)

-- | Grow a mutable vector (from the front) by an amount given explicitly
--   as a <a>Proxy</a> argument.
growFront :: forall (n :: Nat) (k :: Nat) m a p. (KnownNat k, PrimMonad m) => p k -> MVector n (PrimState m) a -> m (MVector (n + k) (PrimState m) a)

-- | Reset all elements of the vector to some undefined value, clearing all
--   references to external objects.
clear :: forall m (n :: Nat) a. PrimMonad m => MVector n (PrimState m) a -> m ()

-- | <i>O(1)</i> Yield the element at a given type-safe position using
--   <a>Finite</a>.
read :: forall (n :: Nat) m a. PrimMonad m => MVector n (PrimState m) a -> Finite n -> m a

-- | <i>O(1)</i> Yield the element at a given type-safe position using
--   <a>Proxy</a>.
read' :: forall (n :: Natural) (k :: Nat) a m p. (KnownNat k, PrimMonad m) => MVector ((n + k) + 1) (PrimState m) a -> p k -> m a

-- | <i>O(1)</i> Replace the element at a given type-safe position using
--   <a>Finite</a>.
write :: forall (n :: Nat) m a. PrimMonad m => MVector n (PrimState m) a -> Finite n -> a -> m ()

-- | <i>O(1)</i> Replace the element at a given type-safe position using
--   <a>Proxy</a>.
write' :: forall (n :: Natural) (k :: Nat) a m p. (KnownNat k, PrimMonad m) => MVector ((n + k) + 1) (PrimState m) a -> p k -> a -> m ()

-- | <i>O(1)</i> Modify the element at a given type-safe position using
--   <a>Finite</a>.
modify :: forall (n :: Nat) m a. PrimMonad m => MVector n (PrimState m) a -> (a -> a) -> Finite n -> m ()

-- | <i>O(1)</i> Modify the element at a given type-safe position using
--   <a>Proxy</a>.
modify' :: forall (n :: Natural) (k :: Nat) a m p. (KnownNat k, PrimMonad m) => MVector ((n + k) + 1) (PrimState m) a -> (a -> a) -> p k -> m ()

-- | <i>O(1)</i> Swap the elements at the given type-safe positions using
--   <a>Finite</a>s.
swap :: forall (n :: Nat) m a. PrimMonad m => MVector n (PrimState m) a -> Finite n -> Finite n -> m ()

-- | <i>O(1)</i> Replace the element at a given type-safe position and
--   return the old element, using <a>Finite</a>.
exchange :: forall (n :: Nat) m a. PrimMonad m => MVector n (PrimState m) a -> Finite n -> a -> m a

-- | <i>O(1)</i> Replace the element at a given type-safe position and
--   return the old element, using <a>Finite</a>.
exchange' :: forall (n :: Natural) (k :: Nat) a m p. (KnownNat k, PrimMonad m) => MVector ((n + k) + 1) (PrimState m) a -> p k -> a -> m a

-- | <i>O(1)</i> Yield the element at a given <a>Int</a> position without
--   bounds checking.
unsafeRead :: forall (n :: Nat) a m. PrimMonad m => MVector n (PrimState m) a -> Int -> m a

-- | <i>O(1)</i> Replace the element at a given <a>Int</a> position without
--   bounds checking.
unsafeWrite :: forall (n :: Nat) m a. PrimMonad m => MVector n (PrimState m) a -> Int -> a -> m ()

-- | <i>O(1)</i> Modify the element at a given <a>Int</a> position without
--   bounds checking.
unsafeModify :: forall (n :: Nat) m a. PrimMonad m => MVector n (PrimState m) a -> (a -> a) -> Int -> m ()

-- | <i>O(1)</i> Swap the elements at the given <a>Int</a> positions
--   without bounds checking.
unsafeSwap :: forall (n :: Nat) m a. PrimMonad m => MVector n (PrimState m) a -> Int -> Int -> m ()

-- | <i>O(1)</i> Replace the element at a given <a>Int</a> position and
--   return the old element. No bounds checks are performed.
unsafeExchange :: forall (n :: Nat) m a. PrimMonad m => MVector n (PrimState m) a -> Int -> a -> m a

-- | Compute the next permutation (lexicographically) of a given vector
--   in-place. Returns <a>False</a> when the input is the last permutation.
nextPermutation :: forall (n :: Nat) e m. (Ord e, PrimMonad m) => MVector n (PrimState m) e -> m Bool

-- | Set all elements of the vector to the given value.
set :: forall m (n :: Nat) a. PrimMonad m => MVector n (PrimState m) a -> a -> m ()

-- | Copy a vector. The two vectors may not overlap.
copy :: forall m (n :: Nat) a. PrimMonad m => MVector n (PrimState m) a -> MVector n (PrimState m) a -> m ()

-- | Move the contents of a vector. If the two vectors do not overlap, this
--   is equivalent to <a>copy</a>. Otherwise, the copying is performed as
--   if the source vector were copied to a temporary vector and then the
--   temporary vector was copied to the target vector.
move :: forall m (n :: Nat) a. PrimMonad m => MVector n (PrimState m) a -> MVector n (PrimState m) a -> m ()

-- | Copy a vector. The two vectors may not overlap. This is not checked.
unsafeCopy :: forall m (n :: Nat) a. PrimMonad m => MVector n (PrimState m) a -> MVector n (PrimState m) a -> m ()

-- | Convert a <a>MVector</a> into a <a>MVector</a> if it has the correct
--   size, otherwise return <a>Nothing</a>.
--   
--   Note that this does no copying; the returned <a>MVector</a> is a
--   reference to the exact same vector in memory as the given one, and any
--   modifications to it are also reflected in the given <a>MVector</a>.
toSized :: forall (n :: Nat) a s. KnownNat n => MVector s a -> Maybe (MVector n s a)

-- | Takes a <a>MVector</a> and returns a continuation providing a
--   <a>MVector</a> with a size parameter <tt>n</tt> that is determined at
--   runtime based on the length of the input vector.
--   
--   Essentially converts a <a>MVector</a> into a <a>MVector</a> with the
--   correct size parameter <tt>n</tt>.
--   
--   Note that this does no copying; the returned <a>MVector</a> is a
--   reference to the exact same vector in memory as the given one, and any
--   modifications to it are also reflected in the given <a>MVector</a>.
withSized :: MVector s a -> (forall (n :: Nat). KnownNat n => MVector n s a -> r) -> r

-- | Convert a <a>MVector</a> into a <a>MVector</a>.
--   
--   Note that this does no copying; the returned <a>MVector</a> is a
--   reference to the exact same vector in memory as the given one, and any
--   modifications to it are also reflected in the given <a>MVector</a>.
fromSized :: forall (n :: Nat) s a. MVector n s a -> MVector s a


-- | This module re-exports the functionality in <a>Sized</a> specialized
--   to <a>Mutable</a>.
--   
--   Functions returning a vector determine the size from the type context
--   unless they have a <tt>'</tt> suffix in which case they take an
--   explicit <a>Proxy</a> argument.
--   
--   Functions where the resulting vector size is not known until runtime
--   are not exported.
module Data.Vector.Primitive.Mutable.Sized

-- | <a>Vector</a> specialized to use <a>Mutable</a>.
type MVector = MVector MVector

-- | <i>O(1)</i> Yield the length of the mutable vector as an <a>Int</a>.
length :: forall (n :: Nat) s a. KnownNat n => MVector n s a -> Int

-- | <i>O(1)</i> Yield the length of the mutable vector as a <a>Proxy</a>.
length' :: forall (n :: Nat) s a. MVector n s a -> Proxy n

-- | <i>O(1)</i> Check whether the mutable vector is empty.
null :: forall (n :: Nat) s a. KnownNat n => MVector n s a -> Bool

-- | <i>O(1)</i> Yield a slice of the mutable vector without copying it
--   with an inferred length argument.
slice :: forall (i :: Nat) (n :: Nat) (k :: Natural) s a p. (KnownNat i, KnownNat n, Prim a) => p i -> MVector ((i + n) + k) s a -> MVector n s a

-- | <i>O(1)</i> Yield a slice of the mutable vector without copying it
--   with an explicit length argument.
slice' :: forall (i :: Nat) (n :: Nat) (k :: Natural) s a p. (KnownNat i, KnownNat n, Prim a) => p i -> p n -> MVector ((i + n) + k) s a -> MVector n s a

-- | <i>O(1)</i> Yield all but the last element of a non-empty mutable
--   vector without copying.
init :: forall (n :: Natural) s a. Prim a => MVector (n + 1) s a -> MVector n s a

-- | <i>O(1)</i> Yield all but the first element of a non-empty mutable
--   vector without copying.
tail :: forall (n :: Natural) s a. Prim a => MVector (1 + n) s a -> MVector n s a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements. The resulting vector
--   always contains this many elements. The length of the resulting vector
--   is inferred from the type.
take :: forall (n :: Nat) (k :: Natural) s a. (KnownNat n, Prim a) => MVector (n + k) s a -> MVector n s a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements. The resulting vector
--   always contains this many elements. The length of the resulting vector
--   is given explicitly as a <a>Proxy</a> argument.
take' :: forall (n :: Nat) (k :: Natural) s a p. (KnownNat n, Prim a) => p n -> MVector (n + k) s a -> MVector n s a

-- | <i>O(1)</i> Yield all but the the first <tt>n</tt> elements. The given
--   vector must contain at least this many elements. The length of the
--   resulting vector is inferred from the type.
drop :: forall (n :: Nat) (k :: Natural) s a. (KnownNat n, Prim a) => MVector (n + k) s a -> MVector k s a

-- | <i>O(1)</i> Yield all but the the first <tt>n</tt> elements. The given
--   vector must contain at least this many elements. The length of the
--   resulting vector is givel explicitly as a <a>Proxy</a> argument.
drop' :: forall (n :: Nat) (k :: Natural) s a p. (KnownNat n, Prim a) => p n -> MVector (n + k) s a -> MVector k s a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements, paired with the rest,
--   without copying. The lengths of the resulting vectors are inferred
--   from the type.
splitAt :: forall (n :: Nat) (m :: Natural) s a. (KnownNat n, Prim a) => MVector (n + m) s a -> (MVector n s a, MVector m s a)

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements, paired with the rest,
--   without copying. The length of the first resulting vector is passed
--   explicitly as a <a>Proxy</a> argument.
splitAt' :: forall (n :: Nat) (m :: Natural) s a p. (KnownNat n, Prim a) => p n -> MVector (n + m) s a -> (MVector n s a, MVector m s a)

-- | <i>O(1)</i> Check if two vectors overlap.
overlaps :: forall (n :: Nat) (k :: Nat) s a. Prim a => MVector n s a -> MVector k s a -> Bool

-- | Create a mutable vector where the length is inferred from the type.
new :: forall (n :: Nat) m a. (KnownNat n, PrimMonad m, Prim a) => m (MVector n (PrimState m) a)

-- | Create a mutable vector where the length is inferred from the type.
--   The memory is not initialized.
unsafeNew :: forall (n :: Nat) m a. (KnownNat n, PrimMonad m, Prim a) => m (MVector n (PrimState m) a)

-- | Create a mutable vector where the length is inferred from the type and
--   fill it with an initial value.
replicate :: forall (n :: Nat) m a. (KnownNat n, PrimMonad m, Prim a) => a -> m (MVector n (PrimState m) a)

-- | Create a mutable vector where the length is given explicitly as a
--   <a>Proxy</a> argument and fill it with an initial value.
replicate' :: forall (n :: Nat) m a p. (KnownNat n, PrimMonad m, Prim a) => p n -> a -> m (MVector n (PrimState m) a)

-- | Create a mutable vector where the length is inferred from the type and
--   fill it with values produced by repeatedly executing the monadic
--   action.
replicateM :: forall (n :: Nat) m a. (KnownNat n, PrimMonad m, Prim a) => m a -> m (MVector n (PrimState m) a)

-- | Create a mutable vector where the length is given explicitly as a
--   <a>Proxy</a> argument and fill it with values produced by repeatedly
--   executing the monadic action.
replicateM' :: forall (n :: Nat) m a p. (KnownNat n, PrimMonad m, Prim a) => p n -> m a -> m (MVector n (PrimState m) a)

-- | Create a copy of a mutable vector.
clone :: forall (n :: Nat) m a. (PrimMonad m, Prim a) => MVector n (PrimState m) a -> m (MVector n (PrimState m) a)

-- | Grow a mutable vector by an amount given explicitly as a <a>Proxy</a>
--   argument.
grow :: forall (n :: Nat) (k :: Nat) m a p. (KnownNat k, PrimMonad m, Prim a) => p k -> MVector n (PrimState m) a -> m (MVector (n + k) (PrimState m) a)

-- | Grow a mutable vector (from the front) by an amount given explicitly
--   as a <a>Proxy</a> argument.
growFront :: forall (n :: Nat) (k :: Nat) m a p. (KnownNat k, PrimMonad m, Prim a) => p k -> MVector n (PrimState m) a -> m (MVector (n + k) (PrimState m) a)

-- | Reset all elements of the vector to some undefined value, clearing all
--   references to external objects.
clear :: forall m a (n :: Nat). (PrimMonad m, Prim a) => MVector n (PrimState m) a -> m ()

-- | <i>O(1)</i> Yield the element at a given type-safe position using
--   <a>Finite</a>.
read :: forall (n :: Nat) m a. (PrimMonad m, Prim a) => MVector n (PrimState m) a -> Finite n -> m a

-- | <i>O(1)</i> Yield the element at a given type-safe position using
--   <a>Proxy</a>.
read' :: forall (n :: Natural) (k :: Nat) a m p. (KnownNat k, PrimMonad m, Prim a) => MVector ((n + k) + 1) (PrimState m) a -> p k -> m a

-- | <i>O(1)</i> Replace the element at a given type-safe position using
--   <a>Finite</a>.
write :: forall (n :: Nat) m a. (PrimMonad m, Prim a) => MVector n (PrimState m) a -> Finite n -> a -> m ()

-- | <i>O(1)</i> Replace the element at a given type-safe position using
--   <a>Proxy</a>.
write' :: forall (n :: Natural) (k :: Nat) a m p. (KnownNat k, PrimMonad m, Prim a) => MVector ((n + k) + 1) (PrimState m) a -> p k -> a -> m ()

-- | <i>O(1)</i> Modify the element at a given type-safe position using
--   <a>Finite</a>.
modify :: forall (n :: Nat) m a. (PrimMonad m, Prim a) => MVector n (PrimState m) a -> (a -> a) -> Finite n -> m ()

-- | <i>O(1)</i> Modify the element at a given type-safe position using
--   <a>Proxy</a>.
modify' :: forall (n :: Natural) (k :: Nat) a m p. (KnownNat k, PrimMonad m, Prim a) => MVector ((n + k) + 1) (PrimState m) a -> (a -> a) -> p k -> m ()

-- | <i>O(1)</i> Swap the elements at the given type-safe positions using
--   <a>Finite</a>s.
swap :: forall (n :: Nat) m a. (PrimMonad m, Prim a) => MVector n (PrimState m) a -> Finite n -> Finite n -> m ()

-- | <i>O(1)</i> Replace the element at a given type-safe position and
--   return the old element, using <a>Finite</a>.
exchange :: forall (n :: Nat) m a. (PrimMonad m, Prim a) => MVector n (PrimState m) a -> Finite n -> a -> m a

-- | <i>O(1)</i> Replace the element at a given type-safe position and
--   return the old element, using <a>Finite</a>.
exchange' :: forall (n :: Natural) (k :: Nat) a m p. (KnownNat k, PrimMonad m, Prim a) => MVector ((n + k) + 1) (PrimState m) a -> p k -> a -> m a

-- | <i>O(1)</i> Yield the element at a given <a>Int</a> position without
--   bounds checking.
unsafeRead :: forall (n :: Nat) a m. (PrimMonad m, Prim a) => MVector n (PrimState m) a -> Int -> m a

-- | <i>O(1)</i> Replace the element at a given <a>Int</a> position without
--   bounds checking.
unsafeWrite :: forall (n :: Nat) m a. (PrimMonad m, Prim a) => MVector n (PrimState m) a -> Int -> a -> m ()

-- | <i>O(1)</i> Modify the element at a given <a>Int</a> position without
--   bounds checking.
unsafeModify :: forall (n :: Nat) m a. (PrimMonad m, Prim a) => MVector n (PrimState m) a -> (a -> a) -> Int -> m ()

-- | <i>O(1)</i> Swap the elements at the given <a>Int</a> positions
--   without bounds checking.
unsafeSwap :: forall (n :: Nat) m a. (PrimMonad m, Prim a) => MVector n (PrimState m) a -> Int -> Int -> m ()

-- | <i>O(1)</i> Replace the element at a given <a>Int</a> position and
--   return the old element. No bounds checks are performed.
unsafeExchange :: forall (n :: Nat) m a. (PrimMonad m, Prim a) => MVector n (PrimState m) a -> Int -> a -> m a

-- | Compute the next permutation (lexicographically) of a given vector
--   in-place. Returns <a>False</a> when the input is the last permutation.
nextPermutation :: forall (n :: Nat) e m. (Ord e, PrimMonad m, Prim e) => MVector n (PrimState m) e -> m Bool

-- | Set all elements of the vector to the given value.
set :: forall m a (n :: Nat). (PrimMonad m, Prim a) => MVector n (PrimState m) a -> a -> m ()

-- | Copy a vector. The two vectors may not overlap.
copy :: forall m a (n :: Nat). (PrimMonad m, Prim a) => MVector n (PrimState m) a -> MVector n (PrimState m) a -> m ()

-- | Move the contents of a vector. If the two vectors do not overlap, this
--   is equivalent to <a>copy</a>. Otherwise, the copying is performed as
--   if the source vector were copied to a temporary vector and then the
--   temporary vector was copied to the target vector.
move :: forall m a (n :: Nat). (PrimMonad m, Prim a) => MVector n (PrimState m) a -> MVector n (PrimState m) a -> m ()

-- | Copy a vector. The two vectors may not overlap. This is not checked.
unsafeCopy :: forall m a (n :: Nat). (PrimMonad m, Prim a) => MVector n (PrimState m) a -> MVector n (PrimState m) a -> m ()

-- | Convert a <a>MVector</a> into a <a>MVector</a> if it has the correct
--   size, otherwise return Nothing.
--   
--   Note that this does no copying; the returned <a>MVector</a> is a
--   reference to the exact same vector in memory as the given one, and any
--   modifications to it are also reflected in the given <a>MVector</a>.
toSized :: forall (n :: Nat) a s. (KnownNat n, Prim a) => MVector s a -> Maybe (MVector n s a)

-- | Takes a <a>MVector</a> and returns a continuation providing a
--   <a>MVector</a> with a size parameter <tt>n</tt> that is determined at
--   runtime based on the length of the input vector.
--   
--   Essentially converts a <a>MVector</a> into a <a>MVector</a> with the
--   correct size parameter <tt>n</tt>.
--   
--   Note that this does no copying; the returned <a>MVector</a> is a
--   reference to the exact same vector in memory as the given one, and any
--   modifications to it are also reflected in the given <a>MVector</a>.
withSized :: forall s a r. Prim a => MVector s a -> (forall (n :: Nat). KnownNat n => MVector n s a -> r) -> r

-- | Convert a <a>MVector</a> into a <a>MVector</a>.
--   
--   Note that this does no copying; the returned <a>MVector</a> is a
--   reference to the exact same vector in memory as the given one, and any
--   modifications to it are also reflected in the given <a>MVector</a>.
fromSized :: forall (n :: Nat) s a. MVector n s a -> MVector s a


-- | This module re-exports the functionality in <a>Sized</a> specialized
--   to <a>Primitive</a>.
--   
--   Functions returning a vector determine the size from the type context
--   unless they have a <tt>'</tt> suffix in which case they take an
--   explicit <a>Proxy</a> argument.
--   
--   Functions where the resulting vector size is not known until runtime
--   are not exported.
module Data.Vector.Primitive.Sized

-- | <a>Vector</a> specialized to use <a>Primitive</a>.
type Vector = Vector Vector

-- | Pattern synonym that lets you treat an unsized vector as if it
--   "contained" a sized vector. If you pattern match on an unsized vector,
--   its contents will be the <i>sized</i> vector counterpart.
--   
--   <pre>
--   testFunc :: Unsized.Vector Int -&gt; Int
--   testFunc (<a>SomeSized</a> v) =
--       <a>sum</a> (<a>zipWith</a> (+) v (<a>replicate</a> 1))
--           -- ^ here, v is `Sized.Vector n Int`, and we have
--                       `<a>KnownNat</a> n`
--   </pre>
--   
--   The <tt>n</tt> type variable will be properly instantiated to whatever
--   the length of the vector is, and you will also have a
--   <tt><a>KnownNat</a> n</tt> instance available. You can get <tt>n</tt>
--   in scope by turning on ScopedTypeVariables and matching on
--   <tt><a>SomeSized</a> (v :: Sized.Vector n Int)</tt>.
--   
--   Without this, you would otherwise have to use <a>withSized</a> to do
--   the same thing:
--   
--   <pre>
--   testFunc :: Unsized.Vector Int -&gt; Int
--   testFunc u = <a>withSized</a> u $ \v -&gt;
--       <a>sum</a> (<a>zipWith</a> (+) v (<a>replicate</a> 1))
--   </pre>
--   
--   Remember that the type of final result of your function (the
--   <tt>Int</tt>, here) must <i>not</i> depend on <tt>n</tt>. However, the
--   types of the intermediate values are allowed to depend on <tt>n</tt>.
--   
--   This is <i>especially</i> useful in do blocks, where you can pattern
--   match on the unsized results of actions, to use the sized vector in
--   the rest of the do block. You also get a <tt><a>KnownNat</a> n</tt>
--   constraint for the remainder of the do block.
--   
--   <pre>
--   -- If you had:
--   getAVector :: IO (Unsized.Vector Int)
--   
--   main :: IO ()
--   main = do
--       SomeSized v &lt;- getAVector -- v is `Sized.Vector n Int`
--       -- get n in scope
--       SomeSized (v :: Sized.Vector n Int) &lt;- getAVector
--       print v
--   </pre>
--   
--   Remember that the final type of the result of the do block
--   (<tt>()</tt>, here) must not depend on <tt>n</tt>. However, the
--   
--   Also useful in ghci, where you can pattern match to get sized vectors
--   from unsized vectors.
--   
--   <pre>
--   ghci&gt; SomeSized v &lt;- pure (myUnsizedVector :: Unsized.Vector Int)
--                -- ^ v is `Sized.Vector n Int`
--   </pre>
--   
--   This enables interactive exploration with sized vectors in ghci, and
--   is useful for using with other libraries and functions that expect
--   sized vectors in an interactive setting.
--   
--   (Note that as of GHC 8.6, you cannot get the <tt>n</tt> in scope in
--   your ghci session using ScopedTypeVariables, like you can with do
--   blocks)
--   
--   You can also use this as a constructor, to take a sized vector and
--   "hide" the size, to produce an unsized vector:
--   
--   <pre>
--   SomeSized :: Sized.Vector n a -&gt; Unsized.Vector a
--   </pre>
pattern SomeSized :: forall a (n :: Nat). Prim a => KnownNat n => Vector n a -> Vector a

-- | <a>Vector</a> specialized to use <a>Mutable</a>.
type MVector = MVector MVector

-- | <i>O(1)</i> Yield the length of the vector as an <a>Int</a>. This is
--   more like <a>natVal</a> than <a>length</a>, extracting the value from
--   the <a>KnownNat</a> instance and not looking at the vector itself.
length :: forall (n :: Nat) a. KnownNat n => Vector n a -> Int

-- | <i>O(1)</i> Yield the length of the vector as a <a>Proxy</a>. This
--   function doesn't <i>do</i> anything; it merely allows the size
--   parameter of the vector to be passed around as a <a>Proxy</a>.
length' :: forall (n :: Nat) a. Vector n a -> Proxy n

-- | <i>O(1)</i> Reveal a <a>KnownNat</a> instance for a vector's length,
--   determined at runtime.
knownLength :: forall (n :: Nat) a r. Prim a => Vector n a -> (KnownNat n => r) -> r

-- | <i>O(1)</i> Reveal a <a>KnownNat</a> instance and <a>Proxy</a> for a
--   vector's length, determined at runtime.
knownLength' :: forall (n :: Nat) a r. Prim a => Vector n a -> (KnownNat n => Proxy n -> r) -> r

-- | <i>O(1)</i> Safe indexing using a <a>Finite</a>.
index :: forall (n :: Nat) a. Prim a => Vector n a -> Finite n -> a

-- | <i>O(1)</i> Safe indexing using a <a>Proxy</a>.
index' :: forall (n :: Nat) (m :: Natural) a p. (KnownNat n, Prim a) => Vector ((n + m) + 1) a -> p n -> a

-- | <i>O(1)</i> Indexing using an <a>Int</a> without bounds checking.
unsafeIndex :: forall (n :: Nat) a. Prim a => Vector n a -> Int -> a

-- | <i>O(1)</i> Yield the first element of a non-empty vector.
head :: forall (n :: Natural) a. Prim a => Vector (1 + n) a -> a

-- | <i>O(1)</i> Yield the last element of a non-empty vector.
last :: forall (n :: Natural) a. Prim a => Vector (n + 1) a -> a

-- | <i>O(1)</i> Safe indexing in a monad. See the documentation for
--   <a>indexM</a> for an explanation of why this is useful.
indexM :: forall (n :: Nat) a m. (Prim a, Monad m) => Vector n a -> Finite n -> m a

-- | <i>O(1)</i> Safe indexing in a monad using a <a>Proxy</a>. See the
--   documentation for <a>indexM</a> for an explanation of why this is
--   useful.
indexM' :: forall (n :: Nat) (k :: Natural) a m p. (KnownNat n, Prim a, Monad m) => Vector (n + k) a -> p n -> m a

-- | <i>O(1)</i> Indexing using an <a>Int</a> without bounds checking. See
--   the documentation for <a>indexM</a> for an explanation of why this is
--   useful.
unsafeIndexM :: forall (n :: Nat) a m. (Prim a, Monad m) => Vector n a -> Int -> m a

-- | <i>O(1)</i> Yield the first element of a non-empty vector in a monad.
--   See the documentation for <a>indexM</a> for an explanation of why this
--   is useful.
headM :: forall (n :: Natural) a m. (Prim a, Monad m) => Vector (1 + n) a -> m a

-- | <i>O(1)</i> Yield the last element of a non-empty vector in a monad.
--   See the documentation for <a>indexM</a> for an explanation of why this
--   is useful.
lastM :: forall (n :: Natural) a m. (Prim a, Monad m) => Vector (n + 1) a -> m a

-- | <i>O(1)</i> Yield a slice of the vector without copying it with an
--   inferred length argument.
slice :: forall (i :: Nat) (n :: Nat) (m :: Natural) a p. (KnownNat i, KnownNat n, Prim a) => p i -> Vector ((i + n) + m) a -> Vector n a

-- | <i>O(1)</i> Yield a slice of the vector without copying it with an
--   explicit length argument.
slice' :: forall (i :: Nat) (n :: Nat) (m :: Natural) a p. (KnownNat i, KnownNat n, Prim a) => p i -> p n -> Vector ((i + n) + m) a -> Vector n a

-- | <i>O(1)</i> Yield all but the last element of a non-empty vector
--   without copying.
init :: forall (n :: Natural) a. Prim a => Vector (n + 1) a -> Vector n a

-- | <i>O(1)</i> Yield all but the first element of a non-empty vector
--   without copying.
tail :: forall (n :: Natural) a. Prim a => Vector (1 + n) a -> Vector n a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements. The resulting vector
--   always contains this many elements. The length of the resulting vector
--   is inferred from the type.
take :: forall (n :: Nat) (m :: Natural) a. (KnownNat n, Prim a) => Vector (n + m) a -> Vector n a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements. The resulting vector
--   always contains this many elements. The length of the resulting vector
--   is given explicitly as a <a>Proxy</a> argument.
take' :: forall (n :: Nat) (m :: Natural) a p. (KnownNat n, Prim a) => p n -> Vector (n + m) a -> Vector n a

-- | <i>O(1)</i> Yield all but the the first <tt>n</tt> elements. The given
--   vector must contain at least this many elements. The length of the
--   resulting vector is inferred from the type.
drop :: forall (n :: Nat) (m :: Natural) a. (KnownNat n, Prim a) => Vector (n + m) a -> Vector m a

-- | <i>O(1)</i> Yield all but the the first <tt>n</tt> elements. The given
--   vector must contain at least this many elements. The length of the
--   resulting vector is givel explicitly as a <a>Proxy</a> argument.
drop' :: forall (n :: Nat) (m :: Natural) a p. (KnownNat n, Prim a) => p n -> Vector (n + m) a -> Vector m a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements, paired with the rest,
--   without copying. The lengths of the resulting vectors are inferred
--   from the type.
splitAt :: forall (n :: Nat) (m :: Natural) a. (KnownNat n, Prim a) => Vector (n + m) a -> (Vector n a, Vector m a)

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements paired with the
--   remainder without copying. The length of the first resulting vector is
--   passed explicitly as a <a>Proxy</a> argument.
splitAt' :: forall (n :: Nat) (m :: Natural) a p. (KnownNat n, Prim a) => p n -> Vector (n + m) a -> (Vector n a, Vector m a)

-- | <i>O(1)</i> Empty vector.
empty :: Prim a => Vector 0 a

-- | <i>O(1)</i> Vector with exactly one element.
singleton :: Prim a => a -> Vector 1 a

-- | <i>O(n)</i> Construct a vector in a type safe manner <tt> fromTuple
--   (1,2) :: Vector 2 Int fromTuple ("hey", "what's", "going", "on") ::
--   Vector 4 String </tt>
fromTuple :: forall a input (length :: Nat). (Prim a, IndexedListLiterals input length a, KnownNat length) => input -> Vector length a

-- | <i>O(n)</i> Construct a vector with the same element in each position
--   where the length is inferred from the type.
replicate :: forall (n :: Nat) a. (KnownNat n, Prim a) => a -> Vector n a

-- | <i>O(n)</i> Construct a vector with the same element in each position
--   where the length is given explicitly as a <a>Proxy</a> argument.
replicate' :: forall (n :: Nat) a p. (KnownNat n, Prim a) => p n -> a -> Vector n a

-- | <i>O(n)</i> construct a vector of the given length by applying the
--   function to each index where the length is inferred from the type.
generate :: forall (n :: Nat) a. (KnownNat n, Prim a) => (Finite n -> a) -> Vector n a

-- | <i>O(n)</i> construct a vector of the given length by applying the
--   function to each index where the length is given explicitly as a
--   <a>Proxy</a> argument.
generate' :: forall (n :: Nat) a p. (KnownNat n, Prim a) => p n -> (Finite n -> a) -> Vector n a

-- | <i>O(n)</i> Apply function <tt>n</tt> times to value. Zeroth element
--   is original value. The length is inferred from the type.
iterateN :: forall (n :: Nat) a. (KnownNat n, Prim a) => (a -> a) -> a -> Vector n a

-- | <i>O(n)</i> Apply function <tt>n</tt> times to value. Zeroth element
--   is original value. The length is given explicitly as a <a>Proxy</a>
--   argument.
iterateN' :: forall (n :: Nat) a p. (KnownNat n, Prim a) => p n -> (a -> a) -> a -> Vector n a

-- | <i>O(n)</i> Execute the monadic action <tt>n</tt> times and store the
--   results in a vector where <tt>n</tt> is inferred from the type.
replicateM :: forall (n :: Nat) m a. (KnownNat n, Prim a, Monad m) => m a -> m (Vector n a)

-- | <i>O(n)</i> Execute the monadic action <tt>n</tt> times and store the
--   results in a vector where <tt>n</tt> is given explicitly as a
--   <a>Proxy</a> argument.
replicateM' :: forall (n :: Nat) m a p. (KnownNat n, Prim a, Monad m) => p n -> m a -> m (Vector n a)

-- | <i>O(n)</i> Construct a vector of length <tt>n</tt> by applying the
--   monadic action to each index where <tt>n</tt> is inferred from the
--   type.
generateM :: forall (n :: Nat) m a. (KnownNat n, Prim a, Monad m) => (Finite n -> m a) -> m (Vector n a)

-- | <i>O(n)</i> Construct a vector of length <tt>n</tt> by applying the
--   monadic action to each index where <tt>n</tt> is given explicitly as a
--   <a>Proxy</a> argument.
generateM' :: forall (n :: Nat) m a p. (KnownNat n, Prim a, Monad m) => p n -> (Finite n -> m a) -> m (Vector n a)

-- | <i>O(n)</i> Construct a vector with exactly <tt>n</tt> elements by
--   repeatedly applying the generator function to the a seed. The length
--   is inferred from the type.
unfoldrN :: forall (n :: Nat) a b. (KnownNat n, Prim a) => (b -> (a, b)) -> b -> Vector n a

-- | <i>O(n)</i> Construct a vector with exactly <tt>n</tt> elements by
--   repeatedly applying the generator function to the a seed. The length
--   is given explicitly as a <a>Proxy</a> argument.
unfoldrN' :: forall (n :: Nat) a b p. (KnownNat n, Prim a) => p n -> (b -> (a, b)) -> b -> Vector n a

-- | <i>O(n)</i> Yield a vector of length <tt>n</tt> containing the values
--   <tt>x</tt>, <tt>x+1</tt>, ..., <tt>x + (n - 1)</tt>. The length is
--   inferred from the type.
enumFromN :: forall (n :: Nat) a. (KnownNat n, Prim a, Num a) => a -> Vector n a

-- | <i>O(n)</i> Yield a vector of length <tt>n</tt> containing the values
--   <tt>x</tt>, <tt>x+1</tt>, ..., <tt>x + (n - 1)</tt>. The length is
--   given explicitly as a <a>Proxy</a> argument.
enumFromN' :: forall (n :: Nat) a p. (KnownNat n, Prim a, Num a) => a -> p n -> Vector n a

-- | <i>O(n)</i> Yield a vector of the given length containing the values
--   <tt>x</tt>, <tt>x+y</tt>, <tt>x+2y</tt>, ..., <tt>x + (n - 1)y</tt>.
--   The length is inferred from the type.
enumFromStepN :: forall (n :: Nat) a. (KnownNat n, Prim a, Num a) => a -> a -> Vector n a

-- | <i>O(n)</i> Yield a vector of the given length containing the values
--   <tt>x</tt>, <tt>x+y</tt>, <tt>x+2y</tt>, ..., <tt>x + (n - 1)y</tt>.
--   The length is given explicitly as a <a>Proxy</a> argument.
enumFromStepN' :: forall (n :: Nat) a p. (KnownNat n, Prim a, Num a) => a -> a -> p n -> Vector n a

-- | <i>O(n)</i> Prepend an element.
cons :: forall (n :: Nat) a. Prim a => a -> Vector n a -> Vector (1 + n) a

-- | <i>O(n)</i> Append an element.
snoc :: forall (n :: Nat) a. Prim a => Vector n a -> a -> Vector (n + 1) a

-- | <i>O(m+n)</i> Concatenate two vectors.
(++) :: forall (n :: Nat) (m :: Nat) a. Prim a => Vector n a -> Vector m a -> Vector (n + m) a

-- | <i>O(n)</i> Yield the argument but force it not to retain any extra
--   memory, possibly by copying it.
--   
--   This is especially useful when dealing with slices. For example:
--   
--   <pre>
--   force (slice 0 2 &lt;huge vector&gt;)
--   </pre>
--   
--   Here, the slice retains a reference to the huge vector. Forcing it
--   creates a copy of just the elements that belong to the slice and
--   allows the huge vector to be garbage collected.
force :: forall a (n :: Nat). Prim a => Vector n a -> Vector n a

-- | <i>O(m+n)</i> For each pair <tt>(i,a)</tt> from the list, replace the
--   vector element at position <tt>i</tt> by <tt>a</tt>.
--   
--   <pre>
--   &lt;5,9,2,7&gt; // [(2,1),(0,3),(2,8)] = &lt;3,9,8,7&gt;
--   </pre>
(//) :: forall a (m :: Nat). Prim a => Vector m a -> [(Finite m, a)] -> Vector m a

-- | <i>O(m+n)</i> For each index <tt>i</tt> from the index vector and the
--   corresponding value <tt>a</tt> from the value vector, replace the
--   element of the initial vector at position <tt>i</tt> by <tt>a</tt>.
--   
--   <pre>
--   update_ &lt;5,9,2,7&gt;  &lt;2,0,2&gt; &lt;1,3,8&gt; = &lt;3,9,8,7&gt;
--   </pre>
--   
--   This function is useful for instances of <a>Vector</a> that cannot
--   store pairs. Otherwise, <tt>update</tt> is probably more convenient.
--   
--   <pre>
--   update_ xs is ys = <tt>update</tt> xs (<tt>zip</tt> is ys)
--   </pre>
update_ :: forall a (m :: Nat) (n :: Nat). Prim a => Vector m a -> Vector n Int -> Vector n a -> Vector m a

-- | Same as (<a>//</a>) but without bounds checking.
unsafeUpd :: forall a (m :: Nat). Prim a => Vector m a -> [(Int, a)] -> Vector m a

-- | Same as <a>update_</a> but without bounds checking.
unsafeUpdate_ :: forall a (m :: Nat) (n :: Nat). Prim a => Vector m a -> Vector n Int -> Vector n a -> Vector m a

-- | <i>O(m+n)</i> For each pair <tt>(i,b)</tt> from the list, replace the
--   vector element <tt>a</tt> at position <tt>i</tt> by <tt>f a b</tt>.
--   
--   <pre>
--   accum (+) &lt;5,9,2&gt; [(2,4),(1,6),(0,3),(1,7)] = &lt;5+3, 9+6+7, 2+4&gt;
--   </pre>
accum :: forall a b (m :: Nat). Prim a => (a -> b -> a) -> Vector m a -> [(Finite m, b)] -> Vector m a

-- | <i>O(m+n)</i> For each index <tt>i</tt> from the index vector and the
--   corresponding value <tt>b</tt> from the the value vector, replace the
--   element of the initial vector at position <tt>i</tt> by <tt>f a
--   b</tt>.
--   
--   <pre>
--   accumulate_ (+) &lt;5,9,2&gt; &lt;2,1,0,1&gt; &lt;4,6,3,7&gt; = &lt;5+3, 9+6+7, 2+4&gt;
--   </pre>
--   
--   This function is useful for instances of <a>Vector</a> that cannot
--   store pairs. Otherwise, <tt>accumulate</tt> is probably more
--   convenient:
--   
--   <pre>
--   accumulate_ f as is bs = <tt>accumulate</tt> f as (<tt>zip</tt> is bs)
--   </pre>
accumulate_ :: forall a b (m :: Nat) (n :: Nat). (Prim a, Prim b) => (a -> b -> a) -> Vector m a -> Vector n Int -> Vector n b -> Vector m a

-- | Same as <a>accum</a> but without bounds checking.
unsafeAccum :: forall a b (m :: Nat). Prim a => (a -> b -> a) -> Vector m a -> [(Int, b)] -> Vector m a

-- | Same as <a>accumulate_</a> but without bounds checking.
unsafeAccumulate_ :: forall a b (m :: Nat) (n :: Nat). (Prim a, Prim b) => (a -> b -> a) -> Vector m a -> Vector n Int -> Vector n b -> Vector m a

-- | <i>O(n)</i> Reverse a vector.
reverse :: forall a (n :: Nat). Prim a => Vector n a -> Vector n a

-- | <i>O(n)</i> Yield the vector obtained by replacing each element
--   <tt>i</tt> of the index vector by <tt>xs<tt>!</tt>i</tt>. This is
--   equivalent to <tt><a>map</a> (xs<tt>!</tt>) is</tt> but is often much
--   more efficient.
--   
--   <pre>
--   backpermute &lt;a,b,c,d&gt; &lt;0,3,2,3,1,0&gt; = &lt;a,d,c,d,b,a&gt;
--   </pre>
backpermute :: forall a (m :: Nat) (n :: Nat). Prim a => Vector m a -> Vector n Int -> Vector n a

-- | Same as <a>backpermute</a> but without bounds checking.
unsafeBackpermute :: forall a (m :: Nat) (n :: Nat). Prim a => Vector m a -> Vector n Int -> Vector n a

-- | Lens to access (<i>O(1)</i>) and update (<i>O(n)</i>) an arbitrary
--   element by its index.
ix :: forall (n :: Nat) a f. (Prim a, Functor f) => Finite n -> (a -> f a) -> Vector n a -> f (Vector n a)

-- | Lens to access (<i>O(1)</i>) and update (<i>O(n)</i>) the first
--   element of a non-empty vector.
_head :: forall (n :: Natural) a f. (Prim a, Functor f) => (a -> f a) -> Vector (1 + n) a -> f (Vector (1 + n) a)

-- | Lens to access (<i>O(1)</i>) and update (<i>O(n)</i>) the last element
--   of a non-empty vector.
_last :: forall (n :: Natural) a f. (Prim a, Functor f) => (a -> f a) -> Vector (n + 1) a -> f (Vector (n + 1) a)

-- | <i>O(n)</i> Map a function over a vector.
map :: forall a b (n :: Nat). (Prim a, Prim b) => (a -> b) -> Vector n a -> Vector n b

-- | <i>O(n)</i> Apply a function to every element of a vector and its
--   index.
imap :: forall a b (n :: Nat). (Prim a, Prim b) => (Finite n -> a -> b) -> Vector n a -> Vector n b

-- | <i>O(n*m)</i> Map a function over a vector and concatenate the
--   results. The function is required to always return the same length
--   vector.
concatMap :: forall a b (m :: Nat) (n :: Nat). (Prim a, Prim b) => (a -> Vector m b) -> Vector n a -> Vector (n * m) b

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector,
--   yielding a vector of results.
mapM :: forall m a b (n :: Nat). (Monad m, Prim a, Prim b) => (a -> m b) -> Vector n a -> m (Vector n b)

-- | <i>O(n)</i> Apply the monadic action to every element of a vector and
--   its index, yielding a vector of results.
imapM :: forall m a b (n :: Nat). (Monad m, Prim a, Prim b) => (Finite n -> a -> m b) -> Vector n a -> m (Vector n b)

-- | <i>O(n)</i> Apply the monadic action to all elements of a vector and
--   ignore the results.
mapM_ :: forall m a b (n :: Nat). (Monad m, Prim a) => (a -> m b) -> Vector n a -> m ()

-- | <i>O(n)</i> Apply the monadic action to every element of a vector and
--   its index, ignoring the results.
imapM_ :: forall m a (n :: Nat) b. (Monad m, Prim a) => (Finite n -> a -> m b) -> Vector n a -> m ()

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector,
--   yielding a vector of results. Equvalent to <tt>flip <a>mapM</a></tt>.
forM :: forall m a b (n :: Nat). (Monad m, Prim a, Prim b) => Vector n a -> (a -> m b) -> m (Vector n b)

-- | <i>O(n)</i> Apply the monadic action to all elements of a vector and
--   ignore the results. Equivalent to <tt>flip <a>mapM_</a></tt>.
forM_ :: forall m a (n :: Nat) b. (Monad m, Prim a) => Vector n a -> (a -> m b) -> m ()

-- | <i>O(n)</i> Zip two vectors of the same length with the given
--   function.
zipWith :: forall a b c (n :: Nat). (Prim a, Prim b, Prim c) => (a -> b -> c) -> Vector n a -> Vector n b -> Vector n c

-- | Zip three vectors with the given function.
zipWith3 :: forall a b c d (n :: Nat). (Prim a, Prim b, Prim c, Prim d) => (a -> b -> c -> d) -> Vector n a -> Vector n b -> Vector n c -> Vector n d
zipWith4 :: forall a b c d e (n :: Nat). (Prim a, Prim b, Prim c, Prim d, Prim e) => (a -> b -> c -> d -> e) -> Vector n a -> Vector n b -> Vector n c -> Vector n d -> Vector n e
zipWith5 :: forall a b c d e f (n :: Nat). (Prim a, Prim b, Prim c, Prim d, Prim e, Prim f) => (a -> b -> c -> d -> e -> f) -> Vector n a -> Vector n b -> Vector n c -> Vector n d -> Vector n e -> Vector n f
zipWith6 :: forall a b c d e f g (n :: Nat). (Prim a, Prim b, Prim c, Prim d, Prim e, Prim f, Prim g) => (a -> b -> c -> d -> e -> f -> g) -> Vector n a -> Vector n b -> Vector n c -> Vector n d -> Vector n e -> Vector n f -> Vector n g

-- | <i>O(n)</i> Zip two vectors of the same length with a function that
--   also takes the elements' indices).
izipWith :: forall a b c (n :: Nat). (Prim a, Prim b, Prim c) => (Finite n -> a -> b -> c) -> Vector n a -> Vector n b -> Vector n c
izipWith3 :: forall a b c d (n :: Nat). (Prim a, Prim b, Prim c, Prim d) => (Finite n -> a -> b -> c -> d) -> Vector n a -> Vector n b -> Vector n c -> Vector n d
izipWith4 :: forall a b c d e (n :: Nat). (Prim a, Prim b, Prim c, Prim d, Prim e) => (Finite n -> a -> b -> c -> d -> e) -> Vector n a -> Vector n b -> Vector n c -> Vector n d -> Vector n e
izipWith5 :: forall a b c d e f (n :: Nat). (Prim a, Prim b, Prim c, Prim d, Prim e, Prim f) => (Finite n -> a -> b -> c -> d -> e -> f) -> Vector n a -> Vector n b -> Vector n c -> Vector n d -> Vector n e -> Vector n f
izipWith6 :: forall a b c d e f g (n :: Nat). (Prim a, Prim b, Prim c, Prim d, Prim e, Prim f, Prim g) => (Finite n -> a -> b -> c -> d -> e -> f -> g) -> Vector n a -> Vector n b -> Vector n c -> Vector n d -> Vector n e -> Vector n f -> Vector n g

-- | <i>O(n)</i> Zip the two vectors of the same length with the monadic
--   action and yield a vector of results.
zipWithM :: forall m a b c (n :: Nat). (Monad m, Prim a, Prim b, Prim c) => (a -> b -> m c) -> Vector n a -> Vector n b -> m (Vector n c)

-- | <i>O(n)</i> Zip the two vectors with a monadic action that also takes
--   the element index and yield a vector of results.
izipWithM :: forall m a b c (n :: Nat). (Monad m, Prim a, Prim b, Prim c) => (Finite n -> a -> b -> m c) -> Vector n a -> Vector n b -> m (Vector n c)

-- | <i>O(n)</i> Zip the two vectors with the monadic action and ignore the
--   results.
zipWithM_ :: forall m a b c (n :: Nat). (Monad m, Prim a, Prim b) => (a -> b -> m c) -> Vector n a -> Vector n b -> m ()

-- | <i>O(n)</i> Zip the two vectors with a monadic action that also takes
--   the element index and ignore the results.
izipWithM_ :: forall m a b (n :: Nat) c. (Monad m, Prim a, Prim b) => (Finite n -> a -> b -> m c) -> Vector n a -> Vector n b -> m ()

-- | <i>O(n)</i> Check if the vector contains an element.
elem :: forall a (n :: Nat). (Prim a, Eq a) => a -> Vector n a -> Bool
infix 4 `elem`

-- | <i>O(n)</i> Check if the vector does not contain an element (inverse
--   of <a>elem</a>).
notElem :: forall a (n :: Nat). (Prim a, Eq a) => a -> Vector n a -> Bool
infix 4 `notElem`

-- | <i>O(n)</i> Yield <a>Just</a> the first element matching the predicate
--   or <a>Nothing</a> if no such element exists.
find :: forall a (n :: Nat). Prim a => (a -> Bool) -> Vector n a -> Maybe a

-- | <i>O(n)</i> Yield <a>Just</a> the index of the first element matching
--   the predicate or <a>Nothing</a> if no such element exists.
findIndex :: forall a (n :: Nat). Prim a => (a -> Bool) -> Vector n a -> Maybe (Finite n)

-- | <i>O(n)</i> Yield <a>Just</a> the index of the first occurence of the
--   given element or <a>Nothing</a> if the vector does not contain the
--   element. This is a specialised version of <a>findIndex</a>.
elemIndex :: forall a (n :: Nat). (Prim a, Eq a) => a -> Vector n a -> Maybe (Finite n)

-- | <i>O(n)</i> Left fold.
foldl :: forall b a (n :: Nat). Prim b => (a -> b -> a) -> a -> Vector n b -> a

-- | <i>O(n)</i> Left fold on non-empty vectors.
foldl1 :: forall a (n :: Natural). Prim a => (a -> a -> a) -> Vector (1 + n) a -> a

-- | <i>O(n)</i> Left fold with strict accumulator.
foldl' :: forall b a (n :: Nat). Prim b => (a -> b -> a) -> a -> Vector n b -> a

-- | <i>O(n)</i> Left fold on non-empty vectors with strict accumulator.
foldl1' :: forall a (n :: Natural). Prim a => (a -> a -> a) -> Vector (1 + n) a -> a

-- | <i>O(n)</i> Right fold.
foldr :: forall a b (n :: Nat). Prim a => (a -> b -> b) -> b -> Vector n a -> b

-- | <i>O(n)</i> Right fold on non-empty vectors.
foldr1 :: forall a (n :: Natural). Prim a => (a -> a -> a) -> Vector (n + 1) a -> a

-- | <i>O(n)</i> Right fold with a strict accumulator.
foldr' :: forall a b (n :: Nat). Prim a => (a -> b -> b) -> b -> Vector n a -> b

-- | <i>O(n)</i> Right fold on non-empty vectors with strict accumulator.
foldr1' :: forall a (n :: Natural). Prim a => (a -> a -> a) -> Vector (n + 1) a -> a

-- | <i>O(n)</i> Left fold (function applied to each element and its
--   index).
ifoldl :: forall b a (n :: Nat). Prim b => (a -> Finite n -> b -> a) -> a -> Vector n b -> a

-- | <i>O(n)</i> Left fold with strict accumulator (function applied to
--   each element and its index).
ifoldl' :: forall b a (n :: Nat). Prim b => (a -> Finite n -> b -> a) -> a -> Vector n b -> a

-- | <i>O(n)</i> Right fold (function applied to each element and its
--   index).
ifoldr :: forall a (n :: Nat) b. Prim a => (Finite n -> a -> b -> b) -> b -> Vector n a -> b

-- | <i>O(n)</i> Right fold with strict accumulator (function applied to
--   each element and its index).
ifoldr' :: forall a (n :: Nat) b. Prim a => (Finite n -> a -> b -> b) -> b -> Vector n a -> b

-- | <i>O(n)</i> Check if all elements satisfy the predicate.
all :: forall a (n :: Nat). Prim a => (a -> Bool) -> Vector n a -> Bool

-- | <i>O(n)</i> Check if any element satisfies the predicate.
any :: forall a (n :: Nat). Prim a => (a -> Bool) -> Vector n a -> Bool

-- | <i>O(n)</i> Compute the sum of the elements.
sum :: forall a (n :: Nat). (Prim a, Num a) => Vector n a -> a

-- | <i>O(n)</i> Compute the product of the elements.
product :: forall a (n :: Nat). (Prim a, Num a) => Vector n a -> a

-- | <i>O(n)</i> Yield the maximum element of the non-empty vector.
maximum :: forall a (n :: Natural). (Prim a, Ord a) => Vector (n + 1) a -> a

-- | <i>O(n)</i> Yield the maximum element of the non-empty vector
--   according to the given comparison function.
maximumBy :: forall a (n :: Natural). Prim a => (a -> a -> Ordering) -> Vector (n + 1) a -> a

-- | <i>O(n)</i> Yield the minimum element of the non-empty vector.
minimum :: forall a (n :: Natural). (Prim a, Ord a) => Vector (n + 1) a -> a

-- | <i>O(n)</i> Yield the minimum element of the non-empty vector
--   according to the given comparison function.
minimumBy :: forall a (n :: Natural). Prim a => (a -> a -> Ordering) -> Vector (n + 1) a -> a

-- | <i>O(n)</i> Yield the index of the maximum element of the non-empty
--   vector.
maxIndex :: forall a (n :: Natural). (Prim a, Ord a) => Vector (n + 1) a -> Finite (n + 1)

-- | <i>O(n)</i> Yield the index of the maximum element of the non-empty
--   vector according to the given comparison function.
maxIndexBy :: forall a (n :: Natural). Prim a => (a -> a -> Ordering) -> Vector (n + 1) a -> Finite (n + 1)

-- | <i>O(n)</i> Yield the index of the minimum element of the non-empty
--   vector.
minIndex :: forall a (n :: Natural). (Prim a, Ord a) => Vector (n + 1) a -> Finite (n + 1)

-- | <i>O(n)</i> Yield the index of the minimum element of the non-empty
--   vector according to the given comparison function.
minIndexBy :: forall a (n :: Natural). Prim a => (a -> a -> Ordering) -> Vector (n + 1) a -> Finite (n + 1)

-- | <i>O(n)</i> Monadic fold.
foldM :: forall m b a (n :: Nat). (Monad m, Prim b) => (a -> b -> m a) -> a -> Vector n b -> m a

-- | <i>O(n)</i> Monadic fold (action applied to each element and its
--   index).
ifoldM :: forall m b a (n :: Nat). (Monad m, Prim b) => (a -> Finite n -> b -> m a) -> a -> Vector n b -> m a

-- | <i>O(n)</i> Monadic fold over non-empty vectors.
fold1M :: forall m a (n :: Natural). (Monad m, Prim a) => (a -> a -> m a) -> Vector (1 + n) a -> m a

-- | <i>O(n)</i> Monadic fold with strict accumulator.
foldM' :: forall m b a (n :: Nat). (Monad m, Prim b) => (a -> b -> m a) -> a -> Vector n b -> m a

-- | <i>O(n)</i> Monadic fold with strict accumulator (action applied to
--   each element and its index).
ifoldM' :: forall m b a (n :: Nat). (Monad m, Prim b) => (a -> Finite n -> b -> m a) -> a -> Vector n b -> m a

-- | <i>O(n)</i> Monadic fold over non-empty vectors with strict
--   accumulator.
fold1M' :: forall m a (n :: Natural). (Monad m, Prim a) => (a -> a -> m a) -> Vector (n + 1) a -> m a

-- | <i>O(n)</i> Monadic fold that discards the result.
foldM_ :: forall m b a (n :: Nat). (Monad m, Prim b) => (a -> b -> m a) -> a -> Vector n b -> m ()

-- | <i>O(n)</i> Monadic fold that discards the result (action applied to
--   each element and its index).
ifoldM_ :: forall m b a (n :: Nat). (Monad m, Prim b) => (a -> Finite n -> b -> m a) -> a -> Vector n b -> m ()

-- | <i>O(n)</i> Monadic fold over non-empty vectors that discards the
--   result.
fold1M_ :: forall m a (n :: Natural). (Monad m, Prim a) => (a -> a -> m a) -> Vector (n + 1) a -> m ()

-- | <i>O(n)</i> Monadic fold with strict accumulator that discards the
--   result.
foldM'_ :: forall m b a (n :: Nat). (Monad m, Prim b) => (a -> b -> m a) -> a -> Vector n b -> m ()

-- | <i>O(n)</i> Monadic fold with strict accumulator that discards the
--   result (action applied to each element and its index).
ifoldM'_ :: forall m b a (n :: Nat). (Monad m, Prim b) => (a -> Finite n -> b -> m a) -> a -> Vector n b -> m ()

-- | <i>O(n)</i> Monad fold over non-empty vectors with strict accumulator
--   that discards the result.
fold1M'_ :: forall m a (n :: Natural). (Monad m, Prim a) => (a -> a -> m a) -> Vector (n + 1) a -> m ()

-- | <i>O(n)</i> Prescan.
--   
--   <pre>
--   prescanl f z = <a>init</a> . <a>scanl</a> f z
--   </pre>
--   
--   Example: <tt>prescanl (+) 0 &lt;1,2,3,4&gt; = &lt;0,1,3,6&gt;</tt>
prescanl :: forall a b (n :: Nat). (Prim a, Prim b) => (a -> b -> a) -> a -> Vector n b -> Vector n a

-- | <i>O(n)</i> Prescan with strict accumulator.
prescanl' :: forall a b (n :: Nat). (Prim a, Prim b) => (a -> b -> a) -> a -> Vector n b -> Vector n a

-- | <i>O(n)</i> Scan.
postscanl :: forall a b (n :: Nat). (Prim a, Prim b) => (a -> b -> a) -> a -> Vector n b -> Vector n a

-- | <i>O(n)</i> Scan with strict accumulator.
postscanl' :: forall a b (n :: Nat). (Prim a, Prim b) => (a -> b -> a) -> a -> Vector n b -> Vector n a

-- | <i>O(n)</i> Haskell-style scan.
scanl :: forall a b (n :: Nat). (Prim a, Prim b) => (a -> b -> a) -> a -> Vector n b -> Vector (1 + n) a

-- | <i>O(n)</i> Haskell-style scan with strict accumulator.
scanl' :: forall a b (n :: Nat). (Prim a, Prim b) => (a -> b -> a) -> a -> Vector n b -> Vector (1 + n) a

-- | <i>O(n)</i> Scan over a non-empty vector.
scanl1 :: forall a (n :: Natural). Prim a => (a -> a -> a) -> Vector (1 + n) a -> Vector (2 + n) a

-- | <i>O(n)</i> Scan over a non-empty vector with a strict accumulator.
scanl1' :: forall a (n :: Natural). Prim a => (a -> a -> a) -> Vector (1 + n) a -> Vector (2 + n) a

-- | <i>O(n)</i> Right-to-left prescan.
prescanr :: forall a b (n :: Nat). (Prim a, Prim b) => (a -> b -> b) -> b -> Vector n a -> Vector n b

-- | <i>O(n)</i> Right-to-left prescan with strict accumulator.
prescanr' :: forall a b (n :: Nat). (Prim a, Prim b) => (a -> b -> b) -> b -> Vector n a -> Vector n b

-- | <i>O(n)</i> Right-to-left scan.
postscanr :: forall a b (n :: Nat). (Prim a, Prim b) => (a -> b -> b) -> b -> Vector n a -> Vector n b

-- | <i>O(n)</i> Right-to-left scan with strict accumulator.
postscanr' :: forall a b (n :: Nat). (Prim a, Prim b) => (a -> b -> b) -> b -> Vector n a -> Vector n b

-- | <i>O(n)</i> Right-to-left Haskell-style scan.
scanr :: forall a b (n :: Nat). (Prim a, Prim b) => (a -> b -> b) -> b -> Vector n a -> Vector (n + 1) b

-- | <i>O(n)</i> Right-to-left Haskell-style scan with strict accumulator.
scanr' :: forall a b (n :: Nat). (Prim a, Prim b) => (a -> b -> b) -> b -> Vector n a -> Vector (n + 1) b

-- | <i>O(n)</i> Right-to-left scan over a non-empty vector.
scanr1 :: forall a (n :: Natural). Prim a => (a -> a -> a) -> Vector (n + 1) a -> Vector (n + 2) a

-- | <i>O(n)</i> Right-to-left scan over a non-empty vector with a strict
--   accumulator.
scanr1' :: forall a (n :: Natural). Prim a => (a -> a -> a) -> Vector (n + 1) a -> Vector (n + 2) a

-- | <i>O(n)</i> Convert a vector to a list.
toList :: forall a (n :: Nat). Prim a => Vector n a -> [a]

-- | <i>O(n)</i> Convert a list to a vector.
fromList :: forall a (n :: Nat). (Prim a, KnownNat n) => [a] -> Maybe (Vector n a)

-- | <i>O(n)</i> Convert the first <tt>n</tt> elements of a list to a
--   vector. The length of the resulting vector is inferred from the type.
fromListN :: forall (n :: Nat) a. (Prim a, KnownNat n) => [a] -> Maybe (Vector n a)

-- | <i>O(n)</i> Convert the first <tt>n</tt> elements of a list to a
--   vector. The length of the resulting vector is given explicitly as a
--   <a>Proxy</a> argument.
fromListN' :: forall (n :: Nat) a p. (Prim a, KnownNat n) => p n -> [a] -> Maybe (Vector n a)

-- | <i>O(n)</i> Takes a list and returns a continuation providing a vector
--   with a size parameter corresponding to the length of the list.
--   
--   Essentially converts a list into a vector with the proper size
--   parameter, determined at runtime.
--   
--   See <a>withSized</a>
withSizedList :: Prim a => [a] -> (forall (n :: Nat). KnownNat n => Vector n a -> r) -> r

-- | <i>O(n)</i> Yield an immutable copy of the mutable vector.
freeze :: forall m a (n :: Nat). (PrimMonad m, Prim a) => MVector n (PrimState m) a -> m (Vector n a)

-- | <i>O(n)</i> Yield a mutable copy of the immutable vector.
thaw :: forall m a (n :: Nat). (PrimMonad m, Prim a) => Vector n a -> m (MVector n (PrimState m) a)

-- | <i>O(n)</i> Copy an immutable vector into a mutable one.
copy :: forall m a (n :: Nat). (PrimMonad m, Prim a) => MVector n (PrimState m) a -> Vector n a -> m ()

-- | <i>O(1)</i> Unsafely convert a mutable vector to an immutable one
--   withouy copying. The mutable vector may not be used after this
--   operation.
unsafeFreeze :: forall m a (n :: Nat). (PrimMonad m, Prim a) => MVector n (PrimState m) a -> m (Vector n a)

-- | <i>O(n)</i> Unsafely convert an immutable vector to a mutable one
--   without copying. The immutable vector may not be used after this
--   operation.
unsafeThaw :: forall m a (n :: Nat). (PrimMonad m, Prim a) => Vector n a -> m (MVector n (PrimState m) a)

-- | Convert a <a>Vector</a> into a <a>Vector</a> if it has the correct
--   size, otherwise return <a>Nothing</a>.
toSized :: forall (n :: Nat) a. (Prim a, KnownNat n) => Vector a -> Maybe (Vector n a)

-- | Takes a <a>Vector</a> and returns a continuation providing a
--   <a>Vector</a> with a size parameter <tt>n</tt> that is determined at
--   runtime based on the length of the input vector.
--   
--   Essentially converts a <a>Vector</a> into a <a>Vector</a> with the
--   correct size parameter <tt>n</tt>.
withSized :: Prim a => Vector a -> (forall (n :: Nat). KnownNat n => Vector n a -> r) -> r
fromSized :: forall (n :: Nat) a. Vector n a -> Vector a

-- | Apply a function on unsized vectors to a sized vector. The function
--   must preserve the size of the vector, this is not checked.
withVectorUnsafe :: forall a b (n :: Nat). (Vector a -> Vector b) -> Vector n a -> Vector n b


-- | This module re-exports the functionality in <a>Sized</a> specialized
--   to <a>Vector</a>.
--   
--   Functions returning a vector determine the size from the type context
--   unless they have a <tt>'</tt> suffix in which case they take an
--   explicit <a>Proxy</a> argument.
--   
--   Functions where the resulting vector size is not known until runtime
--   are not exported.
module Data.Vector.Sized

-- | <a>Vector</a> specialized to use <a>Vector</a>.
type Vector = Vector Vector

-- | Pattern synonym that lets you treat an unsized vector as if it
--   "contained" a sized vector. If you pattern match on an unsized vector,
--   its contents will be the <i>sized</i> vector counterpart.
--   
--   <pre>
--   testFunc :: Unsized.Vector Int -&gt; Int
--   testFunc (<a>SomeSized</a> v) =
--       <a>sum</a> (<a>zipWith</a> (+) v (<a>replicate</a> 1))
--           -- ^ here, v is `Sized.Vector n Int`, and we have
--                       `<a>KnownNat</a> n`
--   </pre>
--   
--   The <tt>n</tt> type variable will be properly instantiated to whatever
--   the length of the vector is, and you will also have a
--   <tt><a>KnownNat</a> n</tt> instance available. You can get <tt>n</tt>
--   in scope by turning on ScopedTypeVariables and matching on
--   <tt><a>SomeSized</a> (v :: Sized.Vector n Int)</tt>.
--   
--   Without this, you would otherwise have to use <a>withSized</a> to do
--   the same thing:
--   
--   <pre>
--   testFunc :: Unsized.Vector Int -&gt; Int
--   testFunc u = <a>withSized</a> u $ \v -&gt;
--       <a>sum</a> (<a>zipWith</a> (+) v (<a>replicate</a> 1))
--   </pre>
--   
--   Remember that the type of final result of your function (the
--   <tt>Int</tt>, here) must <i>not</i> depend on <tt>n</tt>. However, the
--   types of the intermediate values are allowed to depend on <tt>n</tt>.
--   
--   This is <i>especially</i> useful in do blocks, where you can pattern
--   match on the unsized results of actions, to use the sized vector in
--   the rest of the do block. You also get a <tt><a>KnownNat</a> n</tt>
--   constraint for the remainder of the do block.
--   
--   <pre>
--   -- If you had:
--   getAVector :: IO (Unsized.Vector Int)
--   
--   main :: IO ()
--   main = do
--       SomeSized v &lt;- getAVector -- v is `Sized.Vector n Int`
--       -- get n in scope
--       SomeSized (v :: Sized.Vector n Int) &lt;- getAVector
--       print v
--   </pre>
--   
--   Remember that the final type of the result of the do block
--   (<tt>()</tt>, here) must not depend on <tt>n</tt>. However, the
--   
--   Also useful in ghci, where you can pattern match to get sized vectors
--   from unsized vectors.
--   
--   <pre>
--   ghci&gt; SomeSized v &lt;- pure (myUnsizedVector :: Unsized.Vector Int)
--                -- ^ v is `Sized.Vector n Int`
--   </pre>
--   
--   This enables interactive exploration with sized vectors in ghci, and
--   is useful for using with other libraries and functions that expect
--   sized vectors in an interactive setting.
--   
--   (Note that as of GHC 8.6, you cannot get the <tt>n</tt> in scope in
--   your ghci session using ScopedTypeVariables, like you can with do
--   blocks)
--   
--   You can also use this as a constructor, to take a sized vector and
--   "hide" the size, to produce an unsized vector:
--   
--   <pre>
--   SomeSized :: Sized.Vector n a -&gt; Unsized.Vector a
--   </pre>
pattern SomeSized :: forall a (n :: Nat). () => KnownNat n => Vector n a -> Vector a

-- | <a>Vector</a> specialized to use <a>Mutable</a>.
type MVector = MVector MVector

-- | <i>O(1)</i> Yield the length of the vector as an <a>Int</a>. This is
--   more like <a>natVal</a> than <a>length</a>, extracting the value from
--   the <a>KnownNat</a> instance and not looking at the vector itself.
length :: forall (n :: Nat) a. KnownNat n => Vector n a -> Int

-- | <i>O(1)</i> Yield the length of the vector as a <a>Proxy</a>. This
--   function doesn't <i>do</i> anything; it merely allows the size
--   parameter of the vector to be passed around as a <a>Proxy</a>.
length' :: forall (n :: Nat) a. Vector n a -> Proxy n

-- | <i>O(1)</i> Reveal a <a>KnownNat</a> instance for a vector's length,
--   determined at runtime.
knownLength :: forall (n :: Nat) a r. Vector n a -> (KnownNat n => r) -> r

-- | <i>O(1)</i> Reveal a <a>KnownNat</a> instance and <a>Proxy</a> for a
--   vector's length, determined at runtime.
knownLength' :: forall (n :: Nat) a r. Vector n a -> (KnownNat n => Proxy n -> r) -> r

-- | <i>O(1)</i> Safe indexing using a <a>Finite</a>.
index :: forall (n :: Nat) a. Vector n a -> Finite n -> a

-- | <i>O(1)</i> Safe indexing using a <a>Proxy</a>.
index' :: forall (n :: Nat) (m :: Natural) a p. KnownNat n => Vector ((n + m) + 1) a -> p n -> a

-- | <i>O(1)</i> Indexing using an <a>Int</a> without bounds checking.
unsafeIndex :: forall (n :: Nat) a. Vector n a -> Int -> a

-- | <i>O(1)</i> Yield the first element of a non-empty vector.
head :: forall (n :: Natural) a. Vector (1 + n) a -> a

-- | <i>O(1)</i> Yield the last element of a non-empty vector.
last :: forall (n :: Natural) a. Vector (n + 1) a -> a

-- | <i>O(1)</i> Safe indexing in a monad. See the documentation for
--   <a>indexM</a> for an explanation of why this is useful.
indexM :: forall (n :: Nat) a m. Monad m => Vector n a -> Finite n -> m a

-- | <i>O(1)</i> Safe indexing in a monad using a <a>Proxy</a>. See the
--   documentation for <a>indexM</a> for an explanation of why this is
--   useful.
indexM' :: forall (n :: Nat) (k :: Natural) a m p. (KnownNat n, Monad m) => Vector (n + k) a -> p n -> m a

-- | <i>O(1)</i> Indexing using an Int without bounds checking. See the
--   documentation for <a>indexM</a> for an explanation of why this is
--   useful.
unsafeIndexM :: forall (n :: Nat) a m. Monad m => Vector n a -> Int -> m a

-- | <i>O(1)</i> Yield the first element of a non-empty vector in a monad.
--   See the documentation for <a>indexM</a> for an explanation of why this
--   is useful.
headM :: forall (n :: Natural) a m. Monad m => Vector (1 + n) a -> m a

-- | <i>O(1)</i> Yield the last element of a non-empty vector in a monad.
--   See the documentation for <a>indexM</a> for an explanation of why this
--   is useful.
lastM :: forall (n :: Natural) a m. Monad m => Vector (n + 1) a -> m a

-- | <i>O(1)</i> Yield a slice of the vector without copying it with an
--   inferred length argument.
slice :: forall (i :: Nat) (n :: Nat) (m :: Natural) a p. (KnownNat i, KnownNat n) => p i -> Vector ((i + n) + m) a -> Vector n a

-- | <i>O(1)</i> Yield a slice of the vector without copying it with an
--   explicit length argument.
slice' :: forall (i :: Nat) (n :: Nat) (m :: Natural) a p. (KnownNat i, KnownNat n) => p i -> p n -> Vector ((i + n) + m) a -> Vector n a

-- | <i>O(1)</i> Yield all but the last element of a non-empty vector
--   without copying.
init :: forall (n :: Natural) a. Vector (n + 1) a -> Vector n a

-- | <i>O(1)</i> Yield all but the first element of a non-empty vector
--   without copying.
tail :: forall (n :: Natural) a. Vector (1 + n) a -> Vector n a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements. The resulting vector
--   always contains this many elements. The length of the resulting vector
--   is inferred from the type.
take :: forall (n :: Nat) (m :: Natural) a. KnownNat n => Vector (n + m) a -> Vector n a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements. The resulting vector
--   always contains this many elements. The length of the resulting vector
--   is given explicitly as a <a>Proxy</a> argument.
take' :: forall (n :: Nat) (m :: Natural) a p. KnownNat n => p n -> Vector (n + m) a -> Vector n a

-- | <i>O(1)</i> Yield all but the the first <tt>n</tt> elements. The given
--   vector must contain at least this many elements. The length of the
--   resulting vector is inferred from the type.
drop :: forall (n :: Nat) (m :: Natural) a. KnownNat n => Vector (n + m) a -> Vector m a

-- | <i>O(1)</i> Yield all but the the first <tt>n</tt> elements. The given
--   vector must contain at least this many elements. The length of the
--   resulting vector is givel explicitly as a <a>Proxy</a> argument.
drop' :: forall (n :: Nat) (m :: Natural) a p. KnownNat n => p n -> Vector (n + m) a -> Vector m a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements paired with the
--   remainder without copying. The lengths of the resulting vectors are
--   inferred from the type.
splitAt :: forall (n :: Nat) (m :: Natural) a. KnownNat n => Vector (n + m) a -> (Vector n a, Vector m a)

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements, paired with the rest,
--   without copying. The length of the first resulting vector is passed
--   explicitly as a <a>Proxy</a> argument.
splitAt' :: forall (n :: Nat) (m :: Natural) a p. KnownNat n => p n -> Vector (n + m) a -> (Vector n a, Vector m a)

-- | <i>O(1)</i> Empty vector.
empty :: Vector 0 a

-- | <i>O(1)</i> Vector with exactly one element.
singleton :: a -> Vector 1 a

-- | <i>O(n)</i> Construct a vector in a type safe manner using a tuple.
--   <tt> fromTuple (1,2) :: Vector 2 Int fromTuple ("hey", "what's",
--   "going", "on") :: Vector 4 String </tt>
fromTuple :: forall input (length :: Nat) ty. (IndexedListLiterals input length ty, KnownNat length) => input -> Vector length ty

data BuildVector (n :: Nat) a

[Nil] :: forall a. BuildVector 0 a

[:<] :: forall a (n1 :: Natural). a -> BuildVector n1 a -> BuildVector (1 + n1) a
infixr 5 :<

-- | <i>O(n)</i> Construct a vector in a type-safe manner using a sized
--   linked list. <tt> Build (1 :&lt; 2 :&lt; 3 :&lt; Nil) :: Vector 3 Int
--   Build ("not" :&lt; "much" :&lt; Nil) :: Vector 2 String </tt> Can also
--   be used as a pattern.
pattern Build :: BuildVector n a -> Vector n a

-- | <i>O(n)</i> Construct a vector with the same element in each position
--   where the length is inferred from the type.
replicate :: forall (n :: Nat) a. KnownNat n => a -> Vector n a

-- | <i>O(n)</i> Construct a vector with the same element in each position
--   where the length is given explicitly as a <a>Proxy</a> argument.
replicate' :: forall (n :: Nat) a p. KnownNat n => p n -> a -> Vector n a

-- | <i>O(n)</i> construct a vector of the given length by applying the
--   function to each index where the length is inferred from the type.
generate :: forall (n :: Nat) a. KnownNat n => (Finite n -> a) -> Vector n a

-- | <i>O(n)</i> construct a vector of the given length by applying the
--   function to each index where the length is given explicitly as a
--   <a>Proxy</a> argument.
generate' :: forall (n :: Nat) a p. KnownNat n => p n -> (Finite n -> a) -> Vector n a

-- | <i>O(n)</i> Apply the function <tt>n</tt> times to a value. Zeroth
--   element is original value. The length is inferred from the type.
iterateN :: forall (n :: Nat) a. KnownNat n => (a -> a) -> a -> Vector n a

-- | <i>O(n)</i> Apply the function <tt>n</tt> times to a value. Zeroth
--   element is original value. The length is given explicitly as a
--   <a>Proxy</a> argument.
iterateN' :: forall (n :: Nat) a p. KnownNat n => p n -> (a -> a) -> a -> Vector n a

-- | <i>O(n)</i> Execute the monadic action <tt>n</tt> times and store the
--   results in a vector where <tt>n</tt> is inferred from the type.
replicateM :: forall (n :: Nat) m a. (KnownNat n, Monad m) => m a -> m (Vector n a)

-- | <i>O(n)</i> Execute the monadic action <tt>n</tt> times and store the
--   results in a vector where <tt>n</tt> is given explicitly as a
--   <a>Proxy</a> argument.
replicateM' :: forall (n :: Nat) m a p. (KnownNat n, Monad m) => p n -> m a -> m (Vector n a)

-- | <i>O(n)</i> Construct a vector of length <tt>n</tt> by applying the
--   monadic action to each index where n is inferred from the type.
generateM :: forall (n :: Nat) m a. (KnownNat n, Monad m) => (Finite n -> m a) -> m (Vector n a)

-- | <i>O(n)</i> Construct a vector of length <tt>n</tt> by applying the
--   monadic action to each index where n is given explicitly as a
--   <a>Proxy</a> argument.
generateM' :: forall (n :: Nat) m a p. (KnownNat n, Monad m) => p n -> (Finite n -> m a) -> m (Vector n a)

-- | <i>O(n)</i> Construct a vector with exactly <tt>n</tt> elements by
--   repeatedly applying the generator function to the a seed. The length
--   is inferred from the type.
unfoldrN :: forall (n :: Nat) a b. KnownNat n => (b -> (a, b)) -> b -> Vector n a

-- | <i>O(n)</i> Construct a vector with exactly <tt>n</tt> elements by
--   repeatedly applying the generator function to the a seed. The length
--   is given explicitly as a <a>Proxy</a> argument.
unfoldrN' :: forall (n :: Nat) a b p. KnownNat n => p n -> (b -> (a, b)) -> b -> Vector n a

-- | <i>O(n)</i> Yield a vector of length <tt>n</tt> containing the values
--   <tt>x</tt>, <tt>x+1</tt>, ..., <tt>x + (n - 1)</tt>. The length is
--   inferred from the type.
enumFromN :: forall (n :: Nat) a. (KnownNat n, Num a) => a -> Vector n a

-- | <i>O(n)</i> Yield a vector of length <tt>n</tt> containing the values
--   <tt>x</tt>, <tt>x+1</tt>, ..., <tt>x + (n - 1)</tt>. The length is
--   given explicitly as a <a>Proxy</a> argument.
enumFromN' :: forall (n :: Nat) a p. (KnownNat n, Num a) => a -> p n -> Vector n a

-- | <i>O(n)</i> Yield a vector of the given length containing the values
--   <tt>x</tt>, <tt>x+y</tt>, <tt>x+2y</tt>, ... , <tt>x + (n - 1)y</tt>.
--   The length is inferred from the type.
enumFromStepN :: forall (n :: Nat) a. (KnownNat n, Num a) => a -> a -> Vector n a

-- | <i>O(n)</i> Yield a vector of the given length containing the values
--   <tt>x</tt>, <tt>x+y</tt>, <tt>x+2y</tt>, ... , <tt>x + (n - 1)y</tt>.
--   The length is given explicitly as a <a>Proxy</a> argument.
enumFromStepN' :: forall (n :: Nat) a p. (KnownNat n, Num a) => a -> a -> p n -> Vector n a

-- | <i>O(n)</i> Prepend an element.
cons :: forall (n :: Nat) a. a -> Vector n a -> Vector (1 + n) a

-- | <i>O(n)</i> Append an element.
snoc :: forall (n :: Nat) a. Vector n a -> a -> Vector (n + 1) a

-- | <i>O(m+n)</i> Concatenate two vectors.
(++) :: forall (n :: Nat) (m :: Nat) a. Vector n a -> Vector m a -> Vector (n + m) a

-- | <i>O(n)</i> Yield the argument but force it not to retain any extra
--   memory, possibly by copying it.
--   
--   This is especially useful when dealing with slices. For example:
--   
--   <pre>
--   force (slice 0 2 &lt;huge vector&gt;)
--   </pre>
--   
--   Here, the slice retains a reference to the huge vector. Forcing it
--   creates a copy of just the elements that belong to the slice and
--   allows the huge vector to be garbage collected.
force :: forall (n :: Nat) a. Vector n a -> Vector n a

-- | <i>O(m+n)</i> For each pair <tt>(i,a)</tt> from the list, replace the
--   vector element at position <tt>i</tt> by <tt>a</tt>.
--   
--   <pre>
--   &lt;5,9,2,7&gt; // [(2,1),(0,3),(2,8)] = &lt;3,9,8,7&gt;
--   </pre>
(//) :: forall (m :: Nat) a. Vector m a -> [(Finite m, a)] -> Vector m a

-- | <i>O(m+n)</i> For each pair <tt>(i,a)</tt> from the vector of
--   index/value pairs, replace the vector element at position <tt>i</tt>
--   by <tt>a</tt>.
--   
--   <pre>
--   update &lt;5,9,2,7&gt; &lt;(2,1),(0,3),(2,8)&gt; = &lt;3,9,8,7&gt;
--   </pre>
update :: forall (m :: Nat) a (n :: Nat). Vector m a -> Vector n (Int, a) -> Vector m a

-- | <i>O(m+n)</i> For each index <tt>i</tt> from the index vector and the
--   corresponding value <tt>a</tt> from the value vector, replace the
--   element of the initial vector at position <tt>i</tt> by <tt>a</tt>.
--   
--   <pre>
--   update_ &lt;5,9,2,7&gt;  &lt;2,0,2&gt; &lt;1,3,8&gt; = &lt;3,9,8,7&gt;
--   </pre>
--   
--   This function is useful for instances of <a>Vector</a> that cannot
--   store pairs. Otherwise, <a>update</a> is probably more convenient.
--   
--   <pre>
--   update_ xs is ys = <a>update</a> xs (<a>zip</a> is ys)
--   </pre>
update_ :: forall (m :: Nat) a (n :: Nat). Vector m a -> Vector n Int -> Vector n a -> Vector m a

-- | Same as (<a>//</a>) but without bounds checking.
unsafeUpd :: forall (m :: Nat) a. Vector m a -> [(Int, a)] -> Vector m a

-- | Same as <a>update</a> but without bounds checking.
unsafeUpdate :: forall (m :: Nat) a (n :: Nat). Vector m a -> Vector n (Int, a) -> Vector m a

-- | Same as <a>update_</a> but without bounds checking.
unsafeUpdate_ :: forall (m :: Nat) a (n :: Nat). Vector m a -> Vector n Int -> Vector n a -> Vector m a

-- | <i>O(m+n)</i> For each pair <tt>(i,b)</tt> from the list, replace the
--   vector element <tt>a</tt> at position <tt>i</tt> by <tt>f a b</tt>.
--   
--   <pre>
--   accum (+) &lt;5,9,2&gt; [(2,4),(1,6),(0,3),(1,7)] = &lt;5+3, 9+6+7, 2+4&gt;
--   </pre>
accum :: forall a b (m :: Nat). (a -> b -> a) -> Vector m a -> [(Finite m, b)] -> Vector m a

-- | <i>O(m+n)</i> For each pair <tt>(i,b)</tt> from the vector of pairs,
--   replace the vector element <tt>a</tt> at position <tt>i</tt> by <tt>f
--   a b</tt>.
--   
--   <pre>
--   accumulate (+) &lt;5,9,2&gt; &lt;(2,4),(1,6),(0,3),(1,7)&gt; = &lt;5+3, 9+6+7, 2+4&gt;
--   </pre>
accumulate :: forall a b (m :: Nat) (n :: Nat). (a -> b -> a) -> Vector m a -> Vector n (Int, b) -> Vector m a

-- | <i>O(m+n)</i> For each index <tt>i</tt> from the index vector and the
--   corresponding value <tt>b</tt> from the the value vector, replace the
--   element of the initial vector at position <tt>i</tt> by <tt>f a
--   b</tt>.
--   
--   <pre>
--   accumulate_ (+) &lt;5,9,2&gt; &lt;2,1,0,1&gt; &lt;4,6,3,7&gt; = &lt;5+3, 9+6+7, 2+4&gt;
--   </pre>
--   
--   This function is useful for instances of <a>Vector</a> that cannot
--   store pairs. Otherwise, <a>accumulate</a> is probably more convenient:
--   
--   <pre>
--   accumulate_ f as is bs = <a>accumulate</a> f as (<a>zip</a> is bs)
--   </pre>
accumulate_ :: forall a b (m :: Nat) (n :: Nat). (a -> b -> a) -> Vector m a -> Vector n Int -> Vector n b -> Vector m a

-- | Same as <a>accum</a> but without bounds checking.
unsafeAccum :: forall a b (m :: Nat). (a -> b -> a) -> Vector m a -> [(Int, b)] -> Vector m a

-- | Same as <a>accumulate</a> but without bounds checking.
unsafeAccumulate :: forall a b (m :: Nat) (n :: Nat). (a -> b -> a) -> Vector m a -> Vector n (Int, b) -> Vector m a

-- | Same as <a>accumulate_</a> but without bounds checking.
unsafeAccumulate_ :: forall a b (m :: Nat) (n :: Nat). (a -> b -> a) -> Vector m a -> Vector n Int -> Vector n b -> Vector m a

-- | <i>O(n)</i> Reverse a vector.
reverse :: forall (n :: Nat) a. Vector n a -> Vector n a

-- | <i>O(n)</i> Yield the vector obtained by replacing each element
--   <tt>i</tt> of the index vector by <tt>xs<tt>!</tt>i</tt>. This is
--   equivalent to <tt><a>map</a> (xs<tt>!</tt>) is</tt> but is often much
--   more efficient.
--   
--   <pre>
--   backpermute &lt;a,b,c,d&gt; &lt;0,3,2,3,1,0&gt; = &lt;a,d,c,d,b,a&gt;
--   </pre>
backpermute :: forall (m :: Nat) a (n :: Nat). Vector m a -> Vector n Int -> Vector n a

-- | Same as <a>backpermute</a> but without bounds checking.
unsafeBackpermute :: forall (m :: Nat) a (n :: Nat). Vector m a -> Vector n Int -> Vector n a

-- | Lens to access (<i>O(1)</i>) and update (<i>O(n)</i>) an arbitrary
--   element by its index.
ix :: forall (n :: Nat) a f. Functor f => Finite n -> (a -> f a) -> Vector n a -> f (Vector n a)

-- | Type-safe lens to access (<i>O(1)</i>) and update (<i>O(n)</i>) an
--   arbitrary element by its index which should be supplied via
--   TypeApplications.
ix' :: forall (i :: Nat) (n :: Nat) a f. (Functor f, KnownNat i, KnownNat n, (i + 1) <= n) => (a -> f a) -> Vector n a -> f (Vector n a)

-- | Lens to access (<i>O(1)</i>) and update (<i>O(n)</i>) the first
--   element of a non-empty vector.
_head :: forall (n :: Natural) a f. Functor f => (a -> f a) -> Vector (1 + n) a -> f (Vector (1 + n) a)

-- | Lens to access (<i>O(1)</i>) and update (<i>O(n)</i>) the last element
--   of a non-empty vector.
_last :: forall (n :: Natural) a f. Functor f => (a -> f a) -> Vector (n + 1) a -> f (Vector (n + 1) a)

-- | <i>O(n)</i> Pair each element in a vector with its index.
indexed :: forall (n :: Nat) a. Vector n a -> Vector n (Finite n, a)

-- | <i>O(n)</i> Map a function over a vector.
map :: forall a b (n :: Nat). (a -> b) -> Vector n a -> Vector n b

-- | <i>O(n)</i> Apply a function to every element of a vector and its
--   index.
imap :: forall (n :: Nat) a b. (Finite n -> a -> b) -> Vector n a -> Vector n b

-- | <i>O(n*m)</i> Map a function over a vector and concatenate the
--   results. The function is required to always return the same length
--   vector.
concatMap :: forall a (m :: Nat) b (n :: Nat). (a -> Vector m b) -> Vector n a -> Vector (n * m) b

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector,
--   yielding a vector of results.
mapM :: forall m a b (n :: Nat). Monad m => (a -> m b) -> Vector n a -> m (Vector n b)

-- | <i>O(n)</i> Apply the monadic action to every element of a vector and
--   its index, yielding a vector of results.
imapM :: forall m (n :: Nat) a b. Monad m => (Finite n -> a -> m b) -> Vector n a -> m (Vector n b)

-- | <i>O(n)</i> Apply the monadic action to all elements of a vector and
--   ignore the results.
mapM_ :: forall m a b (n :: Nat). Monad m => (a -> m b) -> Vector n a -> m ()

-- | <i>O(n)</i> Apply the monadic action to every element of a vector and
--   its index, ignoring the results.
imapM_ :: forall m (n :: Nat) a b. Monad m => (Finite n -> a -> m b) -> Vector n a -> m ()

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector,
--   yielding a vector of results. Equvalent to <tt>flip <a>mapM</a></tt>.
forM :: forall m (n :: Nat) a b. Monad m => Vector n a -> (a -> m b) -> m (Vector n b)

-- | <i>O(n)</i> Apply the monadic action to all elements of a vector and
--   ignore the results. Equivalent to <tt>flip <a>mapM_</a></tt>.
forM_ :: forall m (n :: Nat) a b. Monad m => Vector n a -> (a -> m b) -> m ()

-- | <i>O(n)</i> Zip two vectors of the same length with the given
--   function.
zipWith :: forall a b c (n :: Nat). (a -> b -> c) -> Vector n a -> Vector n b -> Vector n c

-- | Zip three vectors with the given function.
zipWith3 :: forall a b c d (n :: Nat). (a -> b -> c -> d) -> Vector n a -> Vector n b -> Vector n c -> Vector n d
zipWith4 :: forall a b c d e (n :: Nat). (a -> b -> c -> d -> e) -> Vector n a -> Vector n b -> Vector n c -> Vector n d -> Vector n e
zipWith5 :: forall a b c d e f (n :: Nat). (a -> b -> c -> d -> e -> f) -> Vector n a -> Vector n b -> Vector n c -> Vector n d -> Vector n e -> Vector n f
zipWith6 :: forall a b c d e f g (n :: Nat). (a -> b -> c -> d -> e -> f -> g) -> Vector n a -> Vector n b -> Vector n c -> Vector n d -> Vector n e -> Vector n f -> Vector n g

-- | <i>O(n)</i> Zip two vectors of the same length with a function that
--   also takes the elements' indices).
izipWith :: forall (n :: Nat) a b c. (Finite n -> a -> b -> c) -> Vector n a -> Vector n b -> Vector n c
izipWith3 :: forall (n :: Nat) a b c d. (Finite n -> a -> b -> c -> d) -> Vector n a -> Vector n b -> Vector n c -> Vector n d
izipWith4 :: forall (n :: Nat) a b c d e. (Finite n -> a -> b -> c -> d -> e) -> Vector n a -> Vector n b -> Vector n c -> Vector n d -> Vector n e
izipWith5 :: forall (n :: Nat) a b c d e f. (Finite n -> a -> b -> c -> d -> e -> f) -> Vector n a -> Vector n b -> Vector n c -> Vector n d -> Vector n e -> Vector n f
izipWith6 :: forall (n :: Nat) a b c d e f g. (Finite n -> a -> b -> c -> d -> e -> f -> g) -> Vector n a -> Vector n b -> Vector n c -> Vector n d -> Vector n e -> Vector n f -> Vector n g

-- | <i>O(n)</i> Zip two vectors of the same length.
zip :: forall (n :: Nat) a b. Vector n a -> Vector n b -> Vector n (a, b)
zip3 :: forall (n :: Nat) a b c. Vector n a -> Vector n b -> Vector n c -> Vector n (a, b, c)
zip4 :: forall (n :: Nat) a b c d. Vector n a -> Vector n b -> Vector n c -> Vector n d -> Vector n (a, b, c, d)
zip5 :: forall (n :: Nat) a b c d e. Vector n a -> Vector n b -> Vector n c -> Vector n d -> Vector n e -> Vector n (a, b, c, d, e)
zip6 :: forall (n :: Nat) a b c d e f. Vector n a -> Vector n b -> Vector n c -> Vector n d -> Vector n e -> Vector n f -> Vector n (a, b, c, d, e, f)

-- | <i>O(n)</i> Zip the two vectors of the same length with the monadic
--   action and yield a vector of results.
zipWithM :: forall m a b c (n :: Nat). Monad m => (a -> b -> m c) -> Vector n a -> Vector n b -> m (Vector n c)

-- | <i>O(n)</i> Zip the two vectors with a monadic action that also takes
--   the element index and yield a vector of results.
izipWithM :: forall m (n :: Nat) a b c. Monad m => (Finite n -> a -> b -> m c) -> Vector n a -> Vector n b -> m (Vector n c)

-- | <i>O(n)</i> Zip the two vectors with the monadic action and ignore the
--   results.
zipWithM_ :: forall m a b c (n :: Nat). Monad m => (a -> b -> m c) -> Vector n a -> Vector n b -> m ()

-- | <i>O(n)</i> Zip the two vectors with a monadic action that also takes
--   the element index and ignore the results.
izipWithM_ :: forall m (n :: Nat) a b c. Monad m => (Finite n -> a -> b -> m c) -> Vector n a -> Vector n b -> m ()

-- | <i>O(min(m,n))</i> Unzip a vector of pairs.
unzip :: forall (n :: Nat) a b. Vector n (a, b) -> (Vector n a, Vector n b)
unzip3 :: forall (n :: Nat) a b c. Vector n (a, b, c) -> (Vector n a, Vector n b, Vector n c)
unzip4 :: forall (n :: Nat) a b c d. Vector n (a, b, c, d) -> (Vector n a, Vector n b, Vector n c, Vector n d)
unzip5 :: forall (n :: Nat) a b c d e. Vector n (a, b, c, d, e) -> (Vector n a, Vector n b, Vector n c, Vector n d, Vector n e)
unzip6 :: forall (n :: Nat) a b c d e f. Vector n (a, b, c, d, e, f) -> (Vector n a, Vector n b, Vector n c, Vector n d, Vector n e, Vector n f)

-- | <i>O(n)</i> Check if the vector contains an element.
elem :: forall a (n :: Nat). Eq a => a -> Vector n a -> Bool
infix 4 `elem`

-- | <i>O(n)</i> Check if the vector does not contain an element (inverse
--   of <a>elem</a>).
notElem :: forall a (n :: Nat). Eq a => a -> Vector n a -> Bool
infix 4 `notElem`

-- | <i>O(n)</i> Yield <a>Just</a> the first element matching the predicate
--   or <a>Nothing</a> if no such element exists.
find :: forall a (n :: Nat). (a -> Bool) -> Vector n a -> Maybe a

-- | <i>O(n)</i> Yield <a>Just</a> the index of the first element matching
--   the predicate or <a>Nothing</a> if no such element exists.
findIndex :: forall a (n :: Nat). (a -> Bool) -> Vector n a -> Maybe (Finite n)

-- | <i>O(n)</i> Yield <a>Just</a> the index of the first occurence of the
--   given element or <a>Nothing</a> if the vector does not contain the
--   element. This is a specialised version of <a>findIndex</a>.
elemIndex :: forall a (n :: Nat). Eq a => a -> Vector n a -> Maybe (Finite n)

-- | <i>O(n)</i> Left fold.
foldl :: forall a b (n :: Nat). (a -> b -> a) -> a -> Vector n b -> a

-- | <i>O(n)</i> Left fold on non-empty vectors.
foldl1 :: forall a (n :: Natural). (a -> a -> a) -> Vector (1 + n) a -> a

-- | <i>O(n)</i> Left fold with strict accumulator.
foldl' :: forall a b (n :: Nat). (a -> b -> a) -> a -> Vector n b -> a

-- | <i>O(n)</i> Left fold on non-empty vectors with strict accumulator.
foldl1' :: forall a (n :: Natural). (a -> a -> a) -> Vector (1 + n) a -> a

-- | <i>O(n)</i> Right fold.
foldr :: forall a b (n :: Nat). (a -> b -> b) -> b -> Vector n a -> b

-- | <i>O(n)</i> Right fold on non-empty vectors.
foldr1 :: forall a (n :: Natural). (a -> a -> a) -> Vector (n + 1) a -> a

-- | <i>O(n)</i> Right fold with a strict accumulator.
foldr' :: forall a b (n :: Nat). (a -> b -> b) -> b -> Vector n a -> b

-- | <i>O(n)</i> Right fold on non-empty vectors with strict accumulator.
foldr1' :: forall a (n :: Natural). (a -> a -> a) -> Vector (n + 1) a -> a

-- | <i>O(n)</i> Left fold (function applied to each element and its
--   index).
ifoldl :: forall a (n :: Nat) b. (a -> Finite n -> b -> a) -> a -> Vector n b -> a

-- | <i>O(n)</i> Left fold with strict accumulator (function applied to
--   each element and its index).
ifoldl' :: forall a (n :: Nat) b. (a -> Finite n -> b -> a) -> a -> Vector n b -> a

-- | <i>O(n)</i> Right fold (function applied to each element and its
--   index).
ifoldr :: forall (n :: Nat) a b. (Finite n -> a -> b -> b) -> b -> Vector n a -> b

-- | <i>O(n)</i> Right fold with strict accumulator (function applied to
--   each element and its index).
ifoldr' :: forall (n :: Nat) a b. (Finite n -> a -> b -> b) -> b -> Vector n a -> b

-- | <i>O(n)</i> Check if all elements satisfy the predicate.
all :: forall a (n :: Nat). (a -> Bool) -> Vector n a -> Bool

-- | <i>O(n)</i> Check if any element satisfies the predicate.
any :: forall a (n :: Nat). (a -> Bool) -> Vector n a -> Bool

-- | <i>O(n)</i> Check if all elements are <a>True</a>.
and :: forall (n :: Nat). Vector n Bool -> Bool

-- | <i>O(n)</i> Check if any element is <a>True</a>.
or :: forall (n :: Nat). Vector n Bool -> Bool

-- | <i>O(n)</i> Compute the sum of the elements.
sum :: forall a (n :: Nat). Num a => Vector n a -> a

-- | <i>O(n)</i> Compute the product of the elements.
product :: forall a (n :: Nat). Num a => Vector n a -> a

-- | <i>O(n)</i> Yield the maximum element of the non-empty vector.
maximum :: forall a (n :: Natural). Ord a => Vector (n + 1) a -> a

-- | <i>O(n)</i> Yield the maximum element of the non-empty vector
--   according to the given comparison function.
maximumBy :: forall a (n :: Natural). (a -> a -> Ordering) -> Vector (n + 1) a -> a

-- | <i>O(n)</i> Yield the minimum element of the non-empty vector.
minimum :: forall a (n :: Natural). Ord a => Vector (n + 1) a -> a

-- | <i>O(n)</i> Yield the minimum element of the non-empty vector
--   according to the given comparison function.
minimumBy :: forall a (n :: Natural). (a -> a -> Ordering) -> Vector (n + 1) a -> a

-- | <i>O(n)</i> Yield the index of the maximum element of the non-empty
--   vector.
maxIndex :: forall a (n :: Natural). Ord a => Vector (n + 1) a -> Finite (n + 1)

-- | <i>O(n)</i> Yield the index of the maximum element of the non-empty
--   vector according to the given comparison function.
maxIndexBy :: forall a (n :: Natural). (a -> a -> Ordering) -> Vector (n + 1) a -> Finite (n + 1)

-- | <i>O(n)</i> Yield the index of the minimum element of the non-empty
--   vector.
minIndex :: forall a (n :: Natural). Ord a => Vector (n + 1) a -> Finite (n + 1)

-- | <i>O(n)</i> Yield the index of the minimum element of the non-empty
--   vector according to the given comparison function.
minIndexBy :: forall a (n :: Natural). (a -> a -> Ordering) -> Vector (n + 1) a -> Finite (n + 1)

-- | <i>O(n)</i> Monadic fold.
foldM :: forall m a b (n :: Nat). Monad m => (a -> b -> m a) -> a -> Vector n b -> m a

-- | <i>O(n)</i> Monadic fold (action applied to each element and its
--   index).
ifoldM :: forall m a (n :: Nat) b. Monad m => (a -> Finite n -> b -> m a) -> a -> Vector n b -> m a

-- | <i>O(n)</i> Monadic fold over non-empty vectors.
fold1M :: forall m a (n :: Natural). Monad m => (a -> a -> m a) -> Vector (1 + n) a -> m a

-- | <i>O(n)</i> Monadic fold with strict accumulator.
foldM' :: forall m a b (n :: Nat). Monad m => (a -> b -> m a) -> a -> Vector n b -> m a

-- | <i>O(n)</i> Monadic fold with strict accumulator (action applied to
--   each element and its index).
ifoldM' :: forall m a (n :: Nat) b. Monad m => (a -> Finite n -> b -> m a) -> a -> Vector n b -> m a

-- | <i>O(n)</i> Monadic fold over non-empty vectors with strict
--   accumulator.
fold1M' :: forall m a (n :: Natural). Monad m => (a -> a -> m a) -> Vector (n + 1) a -> m a

-- | <i>O(n)</i> Monadic fold that discards the result.
foldM_ :: forall m a b (n :: Nat). Monad m => (a -> b -> m a) -> a -> Vector n b -> m ()

-- | <i>O(n)</i> Monadic fold that discards the result (action applied to
--   each element and its index).
ifoldM_ :: forall m a (n :: Nat) b. Monad m => (a -> Finite n -> b -> m a) -> a -> Vector n b -> m ()

-- | <i>O(n)</i> Monadic fold over non-empty vectors that discards the
--   result.
fold1M_ :: forall m a (n :: Natural). Monad m => (a -> a -> m a) -> Vector (n + 1) a -> m ()

-- | <i>O(n)</i> Monadic fold with strict accumulator that discards the
--   result.
foldM'_ :: forall m a b (n :: Nat). Monad m => (a -> b -> m a) -> a -> Vector n b -> m ()

-- | <i>O(n)</i> Monadic fold with strict accumulator that discards the
--   result (action applied to each element and its index).
ifoldM'_ :: forall m a (n :: Nat) b. Monad m => (a -> Finite n -> b -> m a) -> a -> Vector n b -> m ()

-- | <i>O(n)</i> Monad fold over non-empty vectors with strict accumulator
--   that discards the result.
fold1M'_ :: forall m a (n :: Natural). Monad m => (a -> a -> m a) -> Vector (n + 1) a -> m ()

-- | Evaluate each action and collect the results.
sequence :: forall m (n :: Nat) a. Monad m => Vector n (m a) -> m (Vector n a)

-- | Evaluate each action and discard the results.
sequence_ :: forall m (n :: Nat) a. Monad m => Vector n (m a) -> m ()

-- | <i>O(n)</i> Prescan.
--   
--   <pre>
--   prescanl f z = <a>init</a> . <a>scanl</a> f z
--   </pre>
--   
--   Example: <tt>prescanl (+) 0 &lt;1,2,3,4&gt; = &lt;0,1,3,6&gt;</tt>
prescanl :: forall a b (n :: Nat). (a -> b -> a) -> a -> Vector n b -> Vector n a

-- | <i>O(n)</i> Prescan with strict accumulator.
prescanl' :: forall a b (n :: Nat). (a -> b -> a) -> a -> Vector n b -> Vector n a

-- | <i>O(n)</i> Scan.
postscanl :: forall a b (n :: Nat). (a -> b -> a) -> a -> Vector n b -> Vector n a

-- | <i>O(n)</i> Scan with strict accumulator.
postscanl' :: forall a b (n :: Nat). (a -> b -> a) -> a -> Vector n b -> Vector n a

-- | <i>O(n)</i> Haskell-style scan.
scanl :: forall a b (n :: Nat). (a -> b -> a) -> a -> Vector n b -> Vector (1 + n) a

-- | <i>O(n)</i> Haskell-style scan with strict accumulator.
scanl' :: forall a b (n :: Nat). (a -> b -> a) -> a -> Vector n b -> Vector (1 + n) a

-- | <i>O(n)</i> Scan over a non-empty vector.
scanl1 :: forall a (n :: Natural). (a -> a -> a) -> Vector (1 + n) a -> Vector (2 + n) a

-- | <i>O(n)</i> Scan over a non-empty vector with a strict accumulator.
scanl1' :: forall a (n :: Natural). (a -> a -> a) -> Vector (1 + n) a -> Vector (2 + n) a

-- | <i>O(n)</i> Right-to-left prescan.
prescanr :: forall a b (n :: Nat). (a -> b -> b) -> b -> Vector n a -> Vector n b

-- | <i>O(n)</i> Right-to-left prescan with strict accumulator.
prescanr' :: forall a b (n :: Nat). (a -> b -> b) -> b -> Vector n a -> Vector n b

-- | <i>O(n)</i> Right-to-left scan.
postscanr :: forall a b (n :: Nat). (a -> b -> b) -> b -> Vector n a -> Vector n b

-- | <i>O(n)</i> Right-to-left scan with strict accumulator.
postscanr' :: forall a b (n :: Nat). (a -> b -> b) -> b -> Vector n a -> Vector n b

-- | <i>O(n)</i> Right-to-left Haskell-style scan.
scanr :: forall a b (n :: Nat). (a -> b -> b) -> b -> Vector n a -> Vector (n + 1) b

-- | <i>O(n)</i> Right-to-left Haskell-style scan with strict accumulator.
scanr' :: forall a b (n :: Nat). (a -> b -> b) -> b -> Vector n a -> Vector (n + 1) b

-- | <i>O(n)</i> Right-to-left scan over a non-empty vector.
scanr1 :: forall a (n :: Natural). (a -> a -> a) -> Vector (n + 1) a -> Vector (n + 2) a

-- | <i>O(n)</i> Right-to-left scan over a non-empty vector with a strict
--   accumulator.
scanr1' :: forall a (n :: Natural). (a -> a -> a) -> Vector (n + 1) a -> Vector (n + 2) a

-- | <i>O(n)</i> Convert a vector to a list.
toList :: forall (n :: Nat) a. Vector n a -> [a]

-- | <i>O(n)</i> Convert a list to a vector.
fromList :: forall (n :: Nat) a. KnownNat n => [a] -> Maybe (Vector n a)

-- | <i>O(n)</i> Convert the first <tt>n</tt> elements of a list to a
--   vector. The length of the resulting vector is inferred from the type.
fromListN :: forall (n :: Nat) a. KnownNat n => [a] -> Maybe (Vector n a)

-- | <i>O(n)</i> Convert the first <tt>n</tt> elements of a list to a
--   vector. The length of the resulting vector is given explicitly as a
--   <a>Proxy</a> argument.
fromListN' :: forall (n :: Nat) a p. KnownNat n => p n -> [a] -> Maybe (Vector n a)

-- | <i>O(n)</i> Takes a list and returns a continuation providing a vector
--   with a size parameter corresponding to the length of the list.
--   
--   Essentially converts a list into a vector with the proper size
--   parameter, determined at runtime.
--   
--   See <a>withSized</a>
withSizedList :: [a] -> (forall (n :: Nat). KnownNat n => Vector n a -> r) -> r

-- | <i>O(n)</i> Yield an immutable copy of the mutable vector.
freeze :: forall m (n :: Nat) a. PrimMonad m => MVector n (PrimState m) a -> m (Vector n a)

-- | <i>O(n)</i> Yield a mutable copy of the immutable vector.
thaw :: forall m (n :: Nat) a. PrimMonad m => Vector n a -> m (MVector n (PrimState m) a)

-- | <i>O(n)</i> Copy an immutable vector into a mutable one.
copy :: forall m (n :: Nat) a. PrimMonad m => MVector n (PrimState m) a -> Vector n a -> m ()

-- | <i>O(1)</i> Unsafely convert a mutable vector to an immutable one
--   without copying. The mutable vector may not be used after this
--   operation.
unsafeFreeze :: forall m (n :: Nat) a. PrimMonad m => MVector n (PrimState m) a -> m (Vector n a)

-- | <i>O(n)</i> Unsafely convert an immutable vector to a mutable one
--   without copying. The immutable vector may not be used after this
--   operation.
unsafeThaw :: forall m (n :: Nat) a. PrimMonad m => Vector n a -> m (MVector n (PrimState m) a)

-- | Convert a <a>Vector</a> into a <a>Vector</a> if it has the correct
--   size, otherwise return <a>Nothing</a>.
toSized :: forall (n :: Nat) a. KnownNat n => Vector a -> Maybe (Vector n a)

-- | Takes a <a>Vector</a> and returns a continuation providing a
--   <a>Vector</a> with a size parameter <tt>n</tt> that is determined at
--   runtime based on the length of the input vector.
--   
--   Essentially converts a <a>Vector</a> into a <a>Vector</a> with the
--   correct size parameter <tt>n</tt>.
withSized :: Vector a -> (forall (n :: Nat). KnownNat n => Vector n a -> r) -> r
fromSized :: forall (n :: Nat) a. Vector n a -> Vector a

-- | Apply a function on unsized vectors to a sized vector. The function
--   must preserve the size of the vector, this is not checked.
withVectorUnsafe :: forall a b (n :: Nat). (Vector a -> Vector b) -> Vector n a -> Vector n b

-- | Apply a function on two unsized vectors to sized vectors. The function
--   must preserve the size of the vectors, this is not checked.
zipVectorsUnsafe :: forall a b c (n :: Nat). (Vector a -> Vector b -> Vector c) -> Vector n a -> Vector n b -> Vector n c


-- | This module re-exports the functionality in <a>Sized</a> specialized
--   to <a>Mutable</a>.
--   
--   Functions returning a vector determine the size from the type context
--   unless they have a <tt>'</tt> suffix in which case they take an
--   explicit <a>Proxy</a> argument.
--   
--   Functions where the resulting vector size is not known until runtime
--   are not exported.
module Data.Vector.Storable.Mutable.Sized

-- | <a>Vector</a> specialized to use <a>Mutable</a>.
type MVector = MVector MVector

-- | <i>O(1)</i> Yield the length of the mutable vector as an <a>Int</a>.
length :: forall (n :: Nat) s a. KnownNat n => MVector n s a -> Int

-- | <i>O(1)</i> Yield the length of the mutable vector as a <a>Proxy</a>.
length' :: forall (n :: Nat) s a. MVector n s a -> Proxy n

-- | <i>O(1)</i> Check whether the mutable vector is empty.
null :: forall (n :: Nat) s a. KnownNat n => MVector n s a -> Bool

-- | <i>O(1)</i> Yield a slice of the mutable vector without copying it
--   with an inferred length argument.
slice :: forall (i :: Nat) (n :: Nat) (k :: Natural) s a p. (KnownNat i, KnownNat n, Storable a) => p i -> MVector ((i + n) + k) s a -> MVector n s a

-- | <i>O(1)</i> Yield a slice of the mutable vector without copying it
--   with an explicit length argument.
slice' :: forall (i :: Nat) (n :: Nat) (k :: Natural) s a p. (KnownNat i, KnownNat n, Storable a) => p i -> p n -> MVector ((i + n) + k) s a -> MVector n s a

-- | <i>O(1)</i> Yield all but the last element of a non-empty mutable
--   vector without copying.
init :: forall (n :: Natural) s a. Storable a => MVector (n + 1) s a -> MVector n s a

-- | <i>O(1)</i> Yield all but the first element of a non-empty mutable
--   vector without copying.
tail :: forall (n :: Natural) s a. Storable a => MVector (1 + n) s a -> MVector n s a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements. The resulting vector
--   always contains this many elements. The length of the resulting vector
--   is inferred from the type.
take :: forall (n :: Nat) (k :: Natural) s a. (KnownNat n, Storable a) => MVector (n + k) s a -> MVector n s a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements. The resulting vector
--   always contains this many elements. The length of the resulting vector
--   is given explicitly as a <a>Proxy</a> argument.
take' :: forall (n :: Nat) (k :: Natural) s a p. (KnownNat n, Storable a) => p n -> MVector (n + k) s a -> MVector n s a

-- | <i>O(1)</i> Yield all but the the first <tt>n</tt> elements. The given
--   vector must contain at least this many elements. The length of the
--   resulting vector is inferred from the type.
drop :: forall (n :: Nat) (k :: Natural) s a. (KnownNat n, Storable a) => MVector (n + k) s a -> MVector k s a

-- | <i>O(1)</i> Yield all but the the first <tt>n</tt> elements. The given
--   vector must contain at least this many elements. The length of the
--   resulting vector is givel explicitly as a <a>Proxy</a> argument.
drop' :: forall (n :: Nat) (k :: Natural) s a p. (KnownNat n, Storable a) => p n -> MVector (n + k) s a -> MVector k s a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements, paired with the rest,
--   without copying. The lengths of the resulting vectors are inferred
--   from the type.
splitAt :: forall (n :: Nat) (m :: Natural) s a. (KnownNat n, Storable a) => MVector (n + m) s a -> (MVector n s a, MVector m s a)

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements, paired with the rest,
--   without copying. The length of the first resulting vector is passed
--   explicitly as a <a>Proxy</a> argument.
splitAt' :: forall (n :: Nat) (m :: Natural) s a p. (KnownNat n, Storable a) => p n -> MVector (n + m) s a -> (MVector n s a, MVector m s a)

-- | <i>O(1)</i> Check if two vectors overlap.
overlaps :: forall (n :: Nat) (k :: Nat) s a. Storable a => MVector n s a -> MVector k s a -> Bool

-- | Create a mutable vector where the length is inferred from the type.
new :: forall (n :: Nat) m a. (KnownNat n, PrimMonad m, Storable a) => m (MVector n (PrimState m) a)

-- | Create a mutable vector where the length is inferred from the type.
--   The memory is not initialized.
unsafeNew :: forall (n :: Nat) m a. (KnownNat n, PrimMonad m, Storable a) => m (MVector n (PrimState m) a)

-- | Create a mutable vector where the length is inferred from the type and
--   fill it with an initial value.
replicate :: forall (n :: Nat) m a. (KnownNat n, PrimMonad m, Storable a) => a -> m (MVector n (PrimState m) a)

-- | Create a mutable vector where the length is given explicitly as a
--   <a>Proxy</a> argument and fill it with an initial value.
replicate' :: forall (n :: Nat) m a p. (KnownNat n, PrimMonad m, Storable a) => p n -> a -> m (MVector n (PrimState m) a)

-- | Create a mutable vector where the length is inferred from the type and
--   fill it with values produced by repeatedly executing the monadic
--   action.
replicateM :: forall (n :: Nat) m a. (KnownNat n, PrimMonad m, Storable a) => m a -> m (MVector n (PrimState m) a)

-- | Create a mutable vector where the length is given explicitly as a
--   <a>Proxy</a> argument and fill it with values produced by repeatedly
--   executing the monadic action.
replicateM' :: forall (n :: Nat) m a p. (KnownNat n, PrimMonad m, Storable a) => p n -> m a -> m (MVector n (PrimState m) a)

-- | Create a copy of a mutable vector.
clone :: forall (n :: Nat) m a. (PrimMonad m, Storable a) => MVector n (PrimState m) a -> m (MVector n (PrimState m) a)

-- | Grow a mutable vector by an amount given explicitly as a <a>Proxy</a>
--   argument.
grow :: forall (n :: Nat) (k :: Nat) m a p. (KnownNat k, PrimMonad m, Storable a) => p k -> MVector n (PrimState m) a -> m (MVector (n + k) (PrimState m) a)

-- | Grow a mutable vector (from the front) by an amount given explicitly
--   as a <a>Proxy</a> argument.
growFront :: forall (n :: Nat) (k :: Nat) m a p. (KnownNat k, PrimMonad m, Storable a) => p k -> MVector n (PrimState m) a -> m (MVector (n + k) (PrimState m) a)

-- | Reset all elements of the vector to some undefined value, clearing all
--   references to external objects.
clear :: forall m a (n :: Nat). (PrimMonad m, Storable a) => MVector n (PrimState m) a -> m ()

-- | <i>O(1)</i> Yield the element at a given type-safe position using
--   <a>Finite</a>.
read :: forall (n :: Nat) m a. (PrimMonad m, Storable a) => MVector n (PrimState m) a -> Finite n -> m a

-- | <i>O(1)</i> Yield the element at a given type-safe position using
--   <a>Proxy</a>.
read' :: forall (n :: Natural) (k :: Nat) a m p. (KnownNat k, PrimMonad m, Storable a) => MVector ((n + k) + 1) (PrimState m) a -> p k -> m a

-- | <i>O(1)</i> Replace the element at a given type-safe position using
--   <a>Finite</a>.
write :: forall (n :: Nat) m a. (PrimMonad m, Storable a) => MVector n (PrimState m) a -> Finite n -> a -> m ()

-- | <i>O(1)</i> Replace the element at a given type-safe position using
--   <a>Proxy</a>.
write' :: forall (n :: Natural) (k :: Nat) a m p. (KnownNat k, PrimMonad m, Storable a) => MVector ((n + k) + 1) (PrimState m) a -> p k -> a -> m ()

-- | <i>O(1)</i> Modify the element at a given type-safe position using
--   <a>Finite</a>.
modify :: forall (n :: Nat) m a. (PrimMonad m, Storable a) => MVector n (PrimState m) a -> (a -> a) -> Finite n -> m ()

-- | <i>O(1)</i> Modify the element at a given type-safe position using
--   <a>Proxy</a>.
modify' :: forall (n :: Natural) (k :: Nat) a m p. (KnownNat k, PrimMonad m, Storable a) => MVector ((n + k) + 1) (PrimState m) a -> (a -> a) -> p k -> m ()

-- | <i>O(1)</i> Swap the elements at the given type-safe positions using
--   <a>Finite</a>s.
swap :: forall (n :: Nat) m a. (PrimMonad m, Storable a) => MVector n (PrimState m) a -> Finite n -> Finite n -> m ()

-- | <i>O(1)</i> Replace the element at a given type-safe position and
--   return the old element, using <a>Finite</a>.
exchange :: forall (n :: Nat) m a. (PrimMonad m, Storable a) => MVector n (PrimState m) a -> Finite n -> a -> m a

-- | <i>O(1)</i> Replace the element at a given type-safe position and
--   return the old element, using <a>Finite</a>.
exchange' :: forall (n :: Natural) (k :: Nat) a m p. (KnownNat k, PrimMonad m, Storable a) => MVector ((n + k) + 1) (PrimState m) a -> p k -> a -> m a

-- | <i>O(1)</i> Yield the element at a given <a>Int</a> position without
--   bounds checking.
unsafeRead :: forall (n :: Nat) a m. (PrimMonad m, Storable a) => MVector n (PrimState m) a -> Int -> m a

-- | <i>O(1)</i> Replace the element at a given <a>Int</a> position without
--   bounds checking.
unsafeWrite :: forall (n :: Nat) m a. (PrimMonad m, Storable a) => MVector n (PrimState m) a -> Int -> a -> m ()

-- | <i>O(1)</i> Modify the element at a given <a>Int</a> position without
--   bounds checking.
unsafeModify :: forall (n :: Nat) m a. (PrimMonad m, Storable a) => MVector n (PrimState m) a -> (a -> a) -> Int -> m ()

-- | <i>O(1)</i> Swap the elements at the given <a>Int</a> positions
--   without bounds checking.
unsafeSwap :: forall (n :: Nat) m a. (PrimMonad m, Storable a) => MVector n (PrimState m) a -> Int -> Int -> m ()

-- | <i>O(1)</i> Replace the element at a given <a>Int</a> position and
--   return the old element. No bounds checks are performed.
unsafeExchange :: forall (n :: Nat) m a. (PrimMonad m, Storable a) => MVector n (PrimState m) a -> Int -> a -> m a

-- | Compute the next permutation (lexicographically) of a given vector
--   in-place. Returns <a>False</a> when the input is the last permutation.
nextPermutation :: forall (n :: Nat) e m. (Ord e, PrimMonad m, Storable e) => MVector n (PrimState m) e -> m Bool

-- | Set all elements of the vector to the given value.
set :: forall m a (n :: Nat). (PrimMonad m, Storable a) => MVector n (PrimState m) a -> a -> m ()

-- | Copy a vector. The two vectors may not overlap.
copy :: forall m a (n :: Nat). (PrimMonad m, Storable a) => MVector n (PrimState m) a -> MVector n (PrimState m) a -> m ()

-- | Move the contents of a vector. If the two vectors do not overlap, this
--   is equivalent to <a>copy</a>. Otherwise, the copying is performed as
--   if the source vector were copied to a temporary vector and then the
--   temporary vector was copied to the target vector.
move :: forall m a (n :: Nat). (PrimMonad m, Storable a) => MVector n (PrimState m) a -> MVector n (PrimState m) a -> m ()

-- | Copy a vector. The two vectors may not overlap. This is not checked.
unsafeCopy :: forall m a (n :: Nat). (PrimMonad m, Storable a) => MVector n (PrimState m) a -> MVector n (PrimState m) a -> m ()

-- | Convert a <a>MVector</a> into a <a>MVector</a> if it has the correct
--   size, otherwise return Nothing.
--   
--   Note that this does no copying; the returned <a>MVector</a> is a
--   reference to the exact same vector in memory as the given one, and any
--   modifications to it are also reflected in the given <a>MVector</a>.
toSized :: forall (n :: Nat) a s. (KnownNat n, Storable a) => MVector s a -> Maybe (MVector n s a)

-- | Takes a <a>MVector</a> and returns a continuation providing a
--   <a>MVector</a> with a size parameter <tt>n</tt> that is determined at
--   runtime based on the length of the input vector.
--   
--   Essentially converts a <a>MVector</a> into a <a>MVector</a> with the
--   correct size parameter <tt>n</tt>.
--   
--   Note that this does no copying; the returned <a>MVector</a> is a
--   reference to the exact same vector in memory as the given one, and any
--   modifications to it are also reflected in the given <a>MVector</a>.
withSized :: forall s a r. Storable a => MVector s a -> (forall (n :: Nat). KnownNat n => MVector n s a -> r) -> r

-- | Convert a <a>MVector</a> into a <a>MVector</a>.
--   
--   Note that this does no copying; the returned <a>MVector</a> is a
--   reference to the exact same vector in memory as the given one, and any
--   modifications to it are also reflected in the given <a>MVector</a>.
fromSized :: forall (n :: Nat) s a. MVector n s a -> MVector s a


-- | This module re-exports the functionality in <a>Sized</a> specialized
--   to <a>Storable</a>.
--   
--   Functions returning a vector determine the size from the type context
--   unless they have a <tt>'</tt> suffix in which case they take an
--   explicit <a>Proxy</a> argument.
--   
--   Functions where the resulting vector size is not known until runtime
--   are not exported.
module Data.Vector.Storable.Sized

-- | <a>Vector</a> specialized to use <a>Storable</a>.
type Vector = Vector Vector

-- | Pattern synonym that lets you treat an unsized vector as if it
--   "contained" a sized vector. If you pattern match on an unsized vector,
--   its contents will be the <i>sized</i> vector counterpart.
--   
--   <pre>
--   testFunc :: Unsized.Vector Int -&gt; Int
--   testFunc (<a>SomeSized</a> v) =
--       <a>sum</a> (<a>zipWith</a> (+) v (<a>replicate</a> 1))
--           -- ^ here, v is `Sized.Vector n Int`, and we have
--                       `<a>KnownNat</a> n`
--   </pre>
--   
--   The <tt>n</tt> type variable will be properly instantiated to whatever
--   the length of the vector is, and you will also have a
--   <tt><a>KnownNat</a> n</tt> instance available. You can get <tt>n</tt>
--   in scope by turning on ScopedTypeVariables and matching on
--   <tt><a>SomeSized</a> (v :: Sized.Vector n Int)</tt>.
--   
--   Without this, you would otherwise have to use <a>withSized</a> to do
--   the same thing:
--   
--   <pre>
--   testFunc :: Unsized.Vector Int -&gt; Int
--   testFunc u = <a>withSized</a> u $ \v -&gt;
--       <a>sum</a> (<a>zipWith</a> (+) v (<a>replicate</a> 1))
--   </pre>
--   
--   Remember that the type of final result of your function (the
--   <tt>Int</tt>, here) must <i>not</i> depend on <tt>n</tt>. However, the
--   types of the intermediate values are allowed to depend on <tt>n</tt>.
--   
--   This is <i>especially</i> useful in do blocks, where you can pattern
--   match on the unsized results of actions, to use the sized vector in
--   the rest of the do block. You also get a <tt><a>KnownNat</a> n</tt>
--   constraint for the remainder of the do block.
--   
--   <pre>
--   -- If you had:
--   getAVector :: IO (Unsized.Vector Int)
--   
--   main :: IO ()
--   main = do
--       SomeSized v &lt;- getAVector -- v is `Sized.Vector n Int`
--       -- get n in scope
--       SomeSized (v :: Sized.Vector n Int) &lt;- getAVector
--       print v
--   </pre>
--   
--   Remember that the final type of the result of the do block
--   (<tt>()</tt>, here) must not depend on <tt>n</tt>. However, the
--   
--   Also useful in ghci, where you can pattern match to get sized vectors
--   from unsized vectors.
--   
--   <pre>
--   ghci&gt; SomeSized v &lt;- pure (myUnsizedVector :: Unsized.Vector Int)
--                -- ^ v is `Sized.Vector n Int`
--   </pre>
--   
--   This enables interactive exploration with sized vectors in ghci, and
--   is useful for using with other libraries and functions that expect
--   sized vectors in an interactive setting.
--   
--   (Note that as of GHC 8.6, you cannot get the <tt>n</tt> in scope in
--   your ghci session using ScopedTypeVariables, like you can with do
--   blocks)
--   
--   You can also use this as a constructor, to take a sized vector and
--   "hide" the size, to produce an unsized vector:
--   
--   <pre>
--   SomeSized :: Sized.Vector n a -&gt; Unsized.Vector a
--   </pre>
pattern SomeSized :: forall a (n :: Nat). Storable a => KnownNat n => Vector n a -> Vector a

-- | <a>Vector</a> specialized to use <a>Mutable</a>.
type MVector = MVector MVector

-- | <i>O(1)</i> Yield the length of the vector as an <a>Int</a>. This is
--   more like <a>natVal</a> than <a>length</a>, extracting the value from
--   the <a>KnownNat</a> instance and not looking at the vector itself.
length :: forall (n :: Nat) a. KnownNat n => Vector n a -> Int

-- | <i>O(1)</i> Yield the length of the vector as a <a>Proxy</a>. This
--   function doesn't <i>do</i> anything; it merely allows the size
--   parameter of the vector to be passed around as a <a>Proxy</a>.
length' :: forall (n :: Nat) a. Vector n a -> Proxy n

-- | <i>O(1)</i> Reveal a <a>KnownNat</a> instance for a vector's length,
--   determined at runtime.
knownLength :: forall (n :: Nat) a r. Storable a => Vector n a -> (KnownNat n => r) -> r

-- | <i>O(1)</i> Reveal a <a>KnownNat</a> instance and <a>Proxy</a> for a
--   vector's length, determined at runtime.
knownLength' :: forall (n :: Nat) a r. Storable a => Vector n a -> (KnownNat n => Proxy n -> r) -> r

-- | <i>O(1)</i> Safe indexing using a <a>Finite</a>.
index :: forall (n :: Nat) a. Storable a => Vector n a -> Finite n -> a

-- | <i>O(1)</i> Safe indexing using a <a>Proxy</a>.
index' :: forall (n :: Nat) (m :: Natural) a p. (KnownNat n, Storable a) => Vector ((n + m) + 1) a -> p n -> a

-- | <i>O(1)</i> Indexing using an <a>Int</a> without bounds checking.
unsafeIndex :: forall (n :: Nat) a. Storable a => Vector n a -> Int -> a

-- | <i>O(1)</i> Yield the first element of a non-empty vector.
head :: forall (n :: Natural) a. Storable a => Vector (1 + n) a -> a

-- | <i>O(1)</i> Yield the last element of a non-empty vector.
last :: forall (n :: Natural) a. Storable a => Vector (n + 1) a -> a

-- | <i>O(1)</i> Safe indexing in a monad. See the documentation for
--   <a>indexM</a> for an explanation of why this is useful.
indexM :: forall (n :: Nat) a m. (Storable a, Monad m) => Vector n a -> Finite n -> m a

-- | <i>O(1)</i> Safe indexing in a monad using a <a>Proxy</a>. See the
--   documentation for <a>indexM</a> for an explanation of why this is
--   useful.
indexM' :: forall (n :: Nat) (k :: Natural) a m p. (KnownNat n, Storable a, Monad m) => Vector (n + k) a -> p n -> m a

-- | <i>O(1)</i> Indexing using an <a>Int</a> without bounds checking. See
--   the documentation for <a>indexM</a> for an explanation of why this is
--   useful.
unsafeIndexM :: forall (n :: Nat) a m. (Storable a, Monad m) => Vector n a -> Int -> m a

-- | <i>O(1)</i> Yield the first element of a non-empty vector in a monad.
--   See the documentation for <a>indexM</a> for an explanation of why this
--   is useful.
headM :: forall (n :: Natural) a m. (Storable a, Monad m) => Vector (1 + n) a -> m a

-- | <i>O(1)</i> Yield the last element of a non-empty vector in a monad.
--   See the documentation for <a>indexM</a> for an explanation of why this
--   is useful.
lastM :: forall (n :: Natural) a m. (Storable a, Monad m) => Vector (n + 1) a -> m a

-- | <i>O(1)</i> Yield a slice of the vector without copying it with an
--   inferred length argument.
slice :: forall (i :: Nat) (n :: Nat) (m :: Natural) a p. (KnownNat i, KnownNat n, Storable a) => p i -> Vector ((i + n) + m) a -> Vector n a

-- | <i>O(1)</i> Yield a slice of the vector without copying it with an
--   explicit length argument.
slice' :: forall (i :: Nat) (n :: Nat) (m :: Natural) a p. (KnownNat i, KnownNat n, Storable a) => p i -> p n -> Vector ((i + n) + m) a -> Vector n a

-- | <i>O(1)</i> Yield all but the last element of a non-empty vector
--   without copying.
init :: forall (n :: Natural) a. Storable a => Vector (n + 1) a -> Vector n a

-- | <i>O(1)</i> Yield all but the first element of a non-empty vector
--   without copying.
tail :: forall (n :: Natural) a. Storable a => Vector (1 + n) a -> Vector n a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements. The resulting vector
--   always contains this many elements. The length of the resulting vector
--   is inferred from the type.
take :: forall (n :: Nat) (m :: Natural) a. (KnownNat n, Storable a) => Vector (n + m) a -> Vector n a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements. The resulting vector
--   always contains this many elements. The length of the resulting vector
--   is given explicitly as a <a>Proxy</a> argument.
take' :: forall (n :: Nat) (m :: Natural) a p. (KnownNat n, Storable a) => p n -> Vector (n + m) a -> Vector n a

-- | <i>O(1)</i> Yield all but the the first <tt>n</tt> elements. The given
--   vector must contain at least this many elements. The length of the
--   resulting vector is inferred from the type.
drop :: forall (n :: Nat) (m :: Natural) a. (KnownNat n, Storable a) => Vector (n + m) a -> Vector m a

-- | <i>O(1)</i> Yield all but the the first <tt>n</tt> elements. The given
--   vector must contain at least this many elements. The length of the
--   resulting vector is givel explicitly as a <a>Proxy</a> argument.
drop' :: forall (n :: Nat) (m :: Natural) a p. (KnownNat n, Storable a) => p n -> Vector (n + m) a -> Vector m a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements, paired with the rest,
--   without copying. The lengths of the resulting vectors are inferred
--   from the type.
splitAt :: forall (n :: Nat) (m :: Natural) a. (KnownNat n, Storable a) => Vector (n + m) a -> (Vector n a, Vector m a)

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements paired with the
--   remainder without copying. The length of the first resulting vector is
--   passed explicitly as a <a>Proxy</a> argument.
splitAt' :: forall (n :: Nat) (m :: Natural) a p. (KnownNat n, Storable a) => p n -> Vector (n + m) a -> (Vector n a, Vector m a)

-- | <i>O(1)</i> Empty vector.
empty :: Storable a => Vector 0 a

-- | <i>O(1)</i> Vector with exactly one element.
singleton :: Storable a => a -> Vector 1 a

-- | <i>O(n)</i> Construct a vector in a type safe manner using a tuple.
--   <tt> fromTuple (1,2) :: Vector 2 Int fromTuple ("hey", "what's",
--   "going", "on") :: Vector 4 String </tt>
fromTuple :: forall a input (length :: Nat). (Storable a, IndexedListLiterals input length a, KnownNat length) => input -> Vector length a

-- | <i>O(n)</i> Construct a vector in a type-safe manner using a sized
--   linked list. <tt> Build (1 :&lt; 2 :&lt; 3 :&lt; Nil) :: Vector 3 Int
--   Build ("not" :&lt; "much" :&lt; Nil) :: Vector 2 String </tt> Can also
--   be used as a pattern.
pattern Build :: Storable a => BuildVector n a -> Vector n a

-- | <i>O(n)</i> Construct a vector with the same element in each position
--   where the length is inferred from the type.
replicate :: forall (n :: Nat) a. (KnownNat n, Storable a) => a -> Vector n a

-- | <i>O(n)</i> Construct a vector with the same element in each position
--   where the length is given explicitly as a <a>Proxy</a> argument.
replicate' :: forall (n :: Nat) a p. (KnownNat n, Storable a) => p n -> a -> Vector n a

-- | <i>O(n)</i> construct a vector of the given length by applying the
--   function to each index where the length is inferred from the type.
generate :: forall (n :: Nat) a. (KnownNat n, Storable a) => (Finite n -> a) -> Vector n a

-- | <i>O(n)</i> construct a vector of the given length by applying the
--   function to each index where the length is given explicitly as a
--   <a>Proxy</a> argument.
generate' :: forall (n :: Nat) a p. (KnownNat n, Storable a) => p n -> (Finite n -> a) -> Vector n a

-- | <i>O(n)</i> Apply function <tt>n</tt> times to value. Zeroth element
--   is original value. The length is inferred from the type.
iterateN :: forall (n :: Nat) a. (KnownNat n, Storable a) => (a -> a) -> a -> Vector n a

-- | <i>O(n)</i> Apply function <tt>n</tt> times to value. Zeroth element
--   is original value. The length is given explicitly as a <a>Proxy</a>
--   argument.
iterateN' :: forall (n :: Nat) a p. (KnownNat n, Storable a) => p n -> (a -> a) -> a -> Vector n a

-- | <i>O(n)</i> Execute the monadic action <tt>n</tt> times and store the
--   results in a vector where <tt>n</tt> is inferred from the type.
replicateM :: forall (n :: Nat) m a. (KnownNat n, Storable a, Monad m) => m a -> m (Vector n a)

-- | <i>O(n)</i> Execute the monadic action <tt>n</tt> times and store the
--   results in a vector where <tt>n</tt> is given explicitly as a
--   <a>Proxy</a> argument.
replicateM' :: forall (n :: Nat) m a p. (KnownNat n, Storable a, Monad m) => p n -> m a -> m (Vector n a)

-- | <i>O(n)</i> Construct a vector of length <tt>n</tt> by applying the
--   monadic action to each index where <tt>n</tt> is inferred from the
--   type.
generateM :: forall (n :: Nat) m a. (KnownNat n, Storable a, Monad m) => (Finite n -> m a) -> m (Vector n a)

-- | <i>O(n)</i> Construct a vector of length <tt>n</tt> by applying the
--   monadic action to each index where <tt>n</tt> is given explicitly as a
--   <a>Proxy</a> argument.
generateM' :: forall (n :: Nat) m a p. (KnownNat n, Storable a, Monad m) => p n -> (Finite n -> m a) -> m (Vector n a)

-- | <i>O(n)</i> Construct a vector with exactly <tt>n</tt> elements by
--   repeatedly applying the generator function to the a seed. The length
--   is inferred from the type.
unfoldrN :: forall (n :: Nat) a b. (KnownNat n, Storable a) => (b -> (a, b)) -> b -> Vector n a

-- | <i>O(n)</i> Construct a vector with exactly <tt>n</tt> elements by
--   repeatedly applying the generator function to the a seed. The length
--   is given explicitly as a <a>Proxy</a> argument.
unfoldrN' :: forall (n :: Nat) a b p. (KnownNat n, Storable a) => p n -> (b -> (a, b)) -> b -> Vector n a

-- | <i>O(n)</i> Yield a vector of length <tt>n</tt> containing the values
--   <tt>x</tt>, <tt>x+1</tt>, ..., <tt>x + (n - 1)</tt>. The length is
--   inferred from the type.
enumFromN :: forall (n :: Nat) a. (KnownNat n, Storable a, Num a) => a -> Vector n a

-- | <i>O(n)</i> Yield a vector of length <tt>n</tt> containing the values
--   <tt>x</tt>, <tt>x+1</tt>, ..., <tt>x + (n - 1)</tt>. The length is
--   given explicitly as a <a>Proxy</a> argument.
enumFromN' :: forall (n :: Nat) a p. (KnownNat n, Storable a, Num a) => a -> p n -> Vector n a

-- | <i>O(n)</i> Yield a vector of the given length containing the values
--   <tt>x</tt>, <tt>x+y</tt>, <tt>x+2y</tt>, ..., <tt>x + (n - 1)y</tt>.
--   The length is inferred from the type.
enumFromStepN :: forall (n :: Nat) a. (KnownNat n, Storable a, Num a) => a -> a -> Vector n a

-- | <i>O(n)</i> Yield a vector of the given length containing the values
--   <tt>x</tt>, <tt>x+y</tt>, <tt>x+2y</tt>, ..., <tt>x + (n - 1)y</tt>.
--   The length is given explicitly as a <a>Proxy</a> argument.
enumFromStepN' :: forall (n :: Nat) a p. (KnownNat n, Storable a, Num a) => a -> a -> p n -> Vector n a

-- | <i>O(n)</i> Prepend an element.
cons :: forall (n :: Nat) a. Storable a => a -> Vector n a -> Vector (1 + n) a

-- | <i>O(n)</i> Append an element.
snoc :: forall (n :: Nat) a. Storable a => Vector n a -> a -> Vector (n + 1) a

-- | <i>O(m+n)</i> Concatenate two vectors.
(++) :: forall (n :: Nat) (m :: Nat) a. Storable a => Vector n a -> Vector m a -> Vector (n + m) a

-- | <i>O(n)</i> Yield the argument but force it not to retain any extra
--   memory, possibly by copying it.
--   
--   This is especially useful when dealing with slices. For example:
--   
--   <pre>
--   force (slice 0 2 &lt;huge vector&gt;)
--   </pre>
--   
--   Here, the slice retains a reference to the huge vector. Forcing it
--   creates a copy of just the elements that belong to the slice and
--   allows the huge vector to be garbage collected.
force :: forall a (n :: Nat). Storable a => Vector n a -> Vector n a

-- | <i>O(m+n)</i> For each pair <tt>(i,a)</tt> from the list, replace the
--   vector element at position <tt>i</tt> by <tt>a</tt>.
--   
--   <pre>
--   &lt;5,9,2,7&gt; // [(2,1),(0,3),(2,8)] = &lt;3,9,8,7&gt;
--   </pre>
(//) :: forall a (m :: Nat). Storable a => Vector m a -> [(Finite m, a)] -> Vector m a

-- | <i>O(m+n)</i> For each pair <tt>(i,a)</tt> from the vector of
--   index/value pairs, replace the vector element at position <tt>i</tt>
--   by <tt>a</tt>.
--   
--   <pre>
--   update &lt;5,9,2,7&gt; &lt;(2,1),(0,3),(2,8)&gt; = &lt;3,9,8,7&gt;
--   </pre>
update :: forall a (m :: Nat) (n :: Nat). (Storable a, Storable (Int, a)) => Vector m a -> Vector n (Int, a) -> Vector m a

-- | <i>O(m+n)</i> For each index <tt>i</tt> from the index vector and the
--   corresponding value <tt>a</tt> from the value vector, replace the
--   element of the initial vector at position <tt>i</tt> by <tt>a</tt>.
--   
--   <pre>
--   update_ &lt;5,9,2,7&gt;  &lt;2,0,2&gt; &lt;1,3,8&gt; = &lt;3,9,8,7&gt;
--   </pre>
--   
--   This function is useful for instances of <a>Vector</a> that cannot
--   store pairs. Otherwise, <a>update</a> is probably more convenient.
--   
--   <pre>
--   update_ xs is ys = <a>update</a> xs (<a>zip</a> is ys)
--   </pre>
update_ :: forall a (m :: Nat) (n :: Nat). Storable a => Vector m a -> Vector n Int -> Vector n a -> Vector m a

-- | Same as (<a>//</a>) but without bounds checking.
unsafeUpd :: forall a (m :: Nat). Storable a => Vector m a -> [(Int, a)] -> Vector m a

-- | Same as <a>update</a> but without bounds checking.
unsafeUpdate :: forall a (m :: Nat) (n :: Nat). (Storable a, Storable (Int, a)) => Vector m a -> Vector n (Int, a) -> Vector m a

-- | Same as <a>update_</a> but without bounds checking.
unsafeUpdate_ :: forall a (m :: Nat) (n :: Nat). Storable a => Vector m a -> Vector n Int -> Vector n a -> Vector m a

-- | <i>O(m+n)</i> For each pair <tt>(i,b)</tt> from the list, replace the
--   vector element <tt>a</tt> at position <tt>i</tt> by <tt>f a b</tt>.
--   
--   <pre>
--   accum (+) &lt;5,9,2&gt; [(2,4),(1,6),(0,3),(1,7)] = &lt;5+3, 9+6+7, 2+4&gt;
--   </pre>
accum :: forall a b (m :: Nat). Storable a => (a -> b -> a) -> Vector m a -> [(Finite m, b)] -> Vector m a

-- | <i>O(m+n)</i> For each pair <tt>(i,b)</tt> from the vector of pairs,
--   replace the vector element <tt>a</tt> at position <tt>i</tt> by <tt>f
--   a b</tt>.
--   
--   <pre>
--   accumulate (+) &lt;5,9,2&gt; &lt;(2,4),(1,6),(0,3),(1,7)&gt; = &lt;5+3, 9+6+7, 2+4&gt;
--   </pre>
accumulate :: forall a b (m :: Nat) (n :: Nat). (Storable a, Storable (Int, b)) => (a -> b -> a) -> Vector m a -> Vector n (Int, b) -> Vector m a

-- | <i>O(m+n)</i> For each index <tt>i</tt> from the index vector and the
--   corresponding value <tt>b</tt> from the the value vector, replace the
--   element of the initial vector at position <tt>i</tt> by <tt>f a
--   b</tt>.
--   
--   <pre>
--   accumulate_ (+) &lt;5,9,2&gt; &lt;2,1,0,1&gt; &lt;4,6,3,7&gt; = &lt;5+3, 9+6+7, 2+4&gt;
--   </pre>
--   
--   This function is useful for instances of <a>Vector</a> that cannot
--   store pairs. Otherwise, <a>accumulate</a> is probably more convenient:
--   
--   <pre>
--   accumulate_ f as is bs = <a>accumulate</a> f as (<a>zip</a> is bs)
--   </pre>
accumulate_ :: forall a b (m :: Nat) (n :: Nat). (Storable a, Storable b) => (a -> b -> a) -> Vector m a -> Vector n Int -> Vector n b -> Vector m a

-- | Same as <a>accum</a> but without bounds checking.
unsafeAccum :: forall a b (m :: Nat). Storable a => (a -> b -> a) -> Vector m a -> [(Int, b)] -> Vector m a

-- | Same as <a>accumulate</a> but without bounds checking.
unsafeAccumulate :: forall a b (m :: Nat) (n :: Nat). (Storable a, Storable (Int, b)) => (a -> b -> a) -> Vector m a -> Vector n (Int, b) -> Vector m a

-- | Same as <a>accumulate_</a> but without bounds checking.
unsafeAccumulate_ :: forall a b (m :: Nat) (n :: Nat). (Storable a, Storable b) => (a -> b -> a) -> Vector m a -> Vector n Int -> Vector n b -> Vector m a

-- | <i>O(n)</i> Reverse a vector.
reverse :: forall a (n :: Nat). Storable a => Vector n a -> Vector n a

-- | <i>O(n)</i> Yield the vector obtained by replacing each element
--   <tt>i</tt> of the index vector by <tt>xs<tt>!</tt>i</tt>. This is
--   equivalent to <tt><a>map</a> (xs<tt>!</tt>) is</tt> but is often much
--   more efficient.
--   
--   <pre>
--   backpermute &lt;a,b,c,d&gt; &lt;0,3,2,3,1,0&gt; = &lt;a,d,c,d,b,a&gt;
--   </pre>
backpermute :: forall a (m :: Nat) (n :: Nat). Storable a => Vector m a -> Vector n Int -> Vector n a

-- | Same as <a>backpermute</a> but without bounds checking.
unsafeBackpermute :: forall a (m :: Nat) (n :: Nat). Storable a => Vector m a -> Vector n Int -> Vector n a

-- | Lens to access (<i>O(1)</i>) and update (<i>O(n)</i>) an arbitrary
--   element by its index.
ix :: forall (n :: Nat) a f. (Storable a, Functor f) => Finite n -> (a -> f a) -> Vector n a -> f (Vector n a)

-- | Type-safe lens to access (<i>O(1)</i>) and update (<i>O(n)</i>) an
--   arbitrary element by its index which should be supplied via
--   TypeApplications.
ix' :: forall (i :: Nat) (n :: Nat) a f. (Storable a, Functor f, KnownNat i, KnownNat n, (i + 1) <= n) => (a -> f a) -> Vector n a -> f (Vector n a)

-- | Lens to access (<i>O(1)</i>) and update (<i>O(n)</i>) the first
--   element of a non-empty vector.
_head :: forall (n :: Natural) a f. (Storable a, Functor f) => (a -> f a) -> Vector (1 + n) a -> f (Vector (1 + n) a)

-- | Lens to access (<i>O(1)</i>) and update (<i>O(n)</i>) the last element
--   of a non-empty vector.
_last :: forall (n :: Natural) a f. (Storable a, Functor f) => (a -> f a) -> Vector (n + 1) a -> f (Vector (n + 1) a)

-- | <i>O(n)</i> Pair each element in a vector with its index.
indexed :: forall a (n :: Nat). (Storable a, Storable (Int, a), Storable (Finite n, a)) => Vector n a -> Vector n (Finite n, a)

-- | <i>O(n)</i> Map a function over a vector.
map :: forall a b (n :: Nat). (Storable a, Storable b) => (a -> b) -> Vector n a -> Vector n b

-- | <i>O(n)</i> Apply a function to every element of a vector and its
--   index.
imap :: forall a b (n :: Nat). (Storable a, Storable b) => (Finite n -> a -> b) -> Vector n a -> Vector n b

-- | <i>O(n*m)</i> Map a function over a vector and concatenate the
--   results. The function is required to always return the same length
--   vector.
concatMap :: forall a b (m :: Nat) (n :: Nat). (Storable a, Storable b) => (a -> Vector m b) -> Vector n a -> Vector (n * m) b

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector,
--   yielding a vector of results.
mapM :: forall m a b (n :: Nat). (Monad m, Storable a, Storable b) => (a -> m b) -> Vector n a -> m (Vector n b)

-- | <i>O(n)</i> Apply the monadic action to every element of a vector and
--   its index, yielding a vector of results.
imapM :: forall m a b (n :: Nat). (Monad m, Storable a, Storable b) => (Finite n -> a -> m b) -> Vector n a -> m (Vector n b)

-- | <i>O(n)</i> Apply the monadic action to all elements of a vector and
--   ignore the results.
mapM_ :: forall m a b (n :: Nat). (Monad m, Storable a) => (a -> m b) -> Vector n a -> m ()

-- | <i>O(n)</i> Apply the monadic action to every element of a vector and
--   its index, ignoring the results.
imapM_ :: forall m a (n :: Nat) b. (Monad m, Storable a) => (Finite n -> a -> m b) -> Vector n a -> m ()

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector,
--   yielding a vector of results. Equvalent to <tt>flip <a>mapM</a></tt>.
forM :: forall m a b (n :: Nat). (Monad m, Storable a, Storable b) => Vector n a -> (a -> m b) -> m (Vector n b)

-- | <i>O(n)</i> Apply the monadic action to all elements of a vector and
--   ignore the results. Equivalent to <tt>flip <a>mapM_</a></tt>.
forM_ :: forall m a (n :: Nat) b. (Monad m, Storable a) => Vector n a -> (a -> m b) -> m ()

-- | <i>O(n)</i> Zip two vectors of the same length with the given
--   function.
zipWith :: forall a b c (n :: Nat). (Storable a, Storable b, Storable c) => (a -> b -> c) -> Vector n a -> Vector n b -> Vector n c

-- | Zip three vectors with the given function.
zipWith3 :: forall a b c d (n :: Nat). (Storable a, Storable b, Storable c, Storable d) => (a -> b -> c -> d) -> Vector n a -> Vector n b -> Vector n c -> Vector n d
zipWith4 :: forall a b c d e (n :: Nat). (Storable a, Storable b, Storable c, Storable d, Storable e) => (a -> b -> c -> d -> e) -> Vector n a -> Vector n b -> Vector n c -> Vector n d -> Vector n e
zipWith5 :: forall a b c d e f (n :: Nat). (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f) => (a -> b -> c -> d -> e -> f) -> Vector n a -> Vector n b -> Vector n c -> Vector n d -> Vector n e -> Vector n f
zipWith6 :: forall a b c d e f g (n :: Nat). (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f, Storable g) => (a -> b -> c -> d -> e -> f -> g) -> Vector n a -> Vector n b -> Vector n c -> Vector n d -> Vector n e -> Vector n f -> Vector n g

-- | <i>O(n)</i> Zip two vectors of the same length with a function that
--   also takes the elements' indices).
izipWith :: forall a b c (n :: Nat). (Storable a, Storable b, Storable c) => (Finite n -> a -> b -> c) -> Vector n a -> Vector n b -> Vector n c
izipWith3 :: forall a b c d (n :: Nat). (Storable a, Storable b, Storable c, Storable d) => (Finite n -> a -> b -> c -> d) -> Vector n a -> Vector n b -> Vector n c -> Vector n d
izipWith4 :: forall a b c d e (n :: Nat). (Storable a, Storable b, Storable c, Storable d, Storable e) => (Finite n -> a -> b -> c -> d -> e) -> Vector n a -> Vector n b -> Vector n c -> Vector n d -> Vector n e
izipWith5 :: forall a b c d e f (n :: Nat). (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f) => (Finite n -> a -> b -> c -> d -> e -> f) -> Vector n a -> Vector n b -> Vector n c -> Vector n d -> Vector n e -> Vector n f
izipWith6 :: forall a b c d e f g (n :: Nat). (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f, Storable g) => (Finite n -> a -> b -> c -> d -> e -> f -> g) -> Vector n a -> Vector n b -> Vector n c -> Vector n d -> Vector n e -> Vector n f -> Vector n g

-- | <i>O(n)</i> Zip two vectors of the same length.
zip :: forall a b (n :: Nat). (Storable a, Storable b, Storable (a, b)) => Vector n a -> Vector n b -> Vector n (a, b)
zip3 :: forall a b c (n :: Nat). (Storable a, Storable b, Storable c, Storable (a, b, c)) => Vector n a -> Vector n b -> Vector n c -> Vector n (a, b, c)
zip4 :: forall a b c d (n :: Nat). (Storable a, Storable b, Storable c, Storable d, Storable (a, b, c, d)) => Vector n a -> Vector n b -> Vector n c -> Vector n d -> Vector n (a, b, c, d)
zip5 :: forall a b c d e (n :: Nat). (Storable a, Storable b, Storable c, Storable d, Storable e, Storable (a, b, c, d, e)) => Vector n a -> Vector n b -> Vector n c -> Vector n d -> Vector n e -> Vector n (a, b, c, d, e)
zip6 :: forall a b c d e f (n :: Nat). (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f, Storable (a, b, c, d, e, f)) => Vector n a -> Vector n b -> Vector n c -> Vector n d -> Vector n e -> Vector n f -> Vector n (a, b, c, d, e, f)

-- | <i>O(n)</i> Zip the two vectors of the same length with the monadic
--   action and yield a vector of results.
zipWithM :: forall m a b c (n :: Nat). (Monad m, Storable a, Storable b, Storable c) => (a -> b -> m c) -> Vector n a -> Vector n b -> m (Vector n c)

-- | <i>O(n)</i> Zip the two vectors with a monadic action that also takes
--   the element index and yield a vector of results.
izipWithM :: forall m a b c (n :: Nat). (Monad m, Storable a, Storable b, Storable c) => (Finite n -> a -> b -> m c) -> Vector n a -> Vector n b -> m (Vector n c)

-- | <i>O(n)</i> Zip the two vectors with the monadic action and ignore the
--   results.
zipWithM_ :: forall m a b c (n :: Nat). (Monad m, Storable a, Storable b) => (a -> b -> m c) -> Vector n a -> Vector n b -> m ()

-- | <i>O(n)</i> Zip the two vectors with a monadic action that also takes
--   the element index and ignore the results.
izipWithM_ :: forall m a b (n :: Nat) c. (Monad m, Storable a, Storable b) => (Finite n -> a -> b -> m c) -> Vector n a -> Vector n b -> m ()

-- | <i>O(min(m,n))</i> Unzip a vector of pairs.
unzip :: forall a b (n :: Nat). (Storable a, Storable b, Storable (a, b)) => Vector n (a, b) -> (Vector n a, Vector n b)
unzip3 :: forall a b c (n :: Nat). (Storable a, Storable b, Storable c, Storable (a, b, c)) => Vector n (a, b, c) -> (Vector n a, Vector n b, Vector n c)
unzip4 :: forall a b c d (n :: Nat). (Storable a, Storable b, Storable c, Storable d, Storable (a, b, c, d)) => Vector n (a, b, c, d) -> (Vector n a, Vector n b, Vector n c, Vector n d)
unzip5 :: forall a b c d e (n :: Nat). (Storable a, Storable b, Storable c, Storable d, Storable e, Storable (a, b, c, d, e)) => Vector n (a, b, c, d, e) -> (Vector n a, Vector n b, Vector n c, Vector n d, Vector n e)
unzip6 :: forall a b c d e f (n :: Nat). (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f, Storable (a, b, c, d, e, f)) => Vector n (a, b, c, d, e, f) -> (Vector n a, Vector n b, Vector n c, Vector n d, Vector n e, Vector n f)

-- | <i>O(n)</i> Check if the vector contains an element.
elem :: forall a (n :: Nat). (Storable a, Eq a) => a -> Vector n a -> Bool
infix 4 `elem`

-- | <i>O(n)</i> Check if the vector does not contain an element (inverse
--   of <a>elem</a>).
notElem :: forall a (n :: Nat). (Storable a, Eq a) => a -> Vector n a -> Bool
infix 4 `notElem`

-- | <i>O(n)</i> Yield <a>Just</a> the first element matching the predicate
--   or <a>Nothing</a> if no such element exists.
find :: forall a (n :: Nat). Storable a => (a -> Bool) -> Vector n a -> Maybe a

-- | <i>O(n)</i> Yield <a>Just</a> the index of the first element matching
--   the predicate or <a>Nothing</a> if no such element exists.
findIndex :: forall a (n :: Nat). Storable a => (a -> Bool) -> Vector n a -> Maybe (Finite n)

-- | <i>O(n)</i> Yield <a>Just</a> the index of the first occurence of the
--   given element or <a>Nothing</a> if the vector does not contain the
--   element. This is a specialised version of <a>findIndex</a>.
elemIndex :: forall a (n :: Nat). (Storable a, Eq a) => a -> Vector n a -> Maybe (Finite n)

-- | <i>O(n)</i> Left fold.
foldl :: forall b a (n :: Nat). Storable b => (a -> b -> a) -> a -> Vector n b -> a

-- | <i>O(n)</i> Left fold on non-empty vectors.
foldl1 :: forall a (n :: Natural). Storable a => (a -> a -> a) -> Vector (1 + n) a -> a

-- | <i>O(n)</i> Left fold with strict accumulator.
foldl' :: forall b a (n :: Nat). Storable b => (a -> b -> a) -> a -> Vector n b -> a

-- | <i>O(n)</i> Left fold on non-empty vectors with strict accumulator.
foldl1' :: forall a (n :: Natural). Storable a => (a -> a -> a) -> Vector (1 + n) a -> a

-- | <i>O(n)</i> Right fold.
foldr :: forall a b (n :: Nat). Storable a => (a -> b -> b) -> b -> Vector n a -> b

-- | <i>O(n)</i> Right fold on non-empty vectors.
foldr1 :: forall a (n :: Natural). Storable a => (a -> a -> a) -> Vector (n + 1) a -> a

-- | <i>O(n)</i> Right fold with a strict accumulator.
foldr' :: forall a b (n :: Nat). Storable a => (a -> b -> b) -> b -> Vector n a -> b

-- | <i>O(n)</i> Right fold on non-empty vectors with strict accumulator.
foldr1' :: forall a (n :: Natural). Storable a => (a -> a -> a) -> Vector (n + 1) a -> a

-- | <i>O(n)</i> Left fold (function applied to each element and its
--   index).
ifoldl :: forall b a (n :: Nat). Storable b => (a -> Finite n -> b -> a) -> a -> Vector n b -> a

-- | <i>O(n)</i> Left fold with strict accumulator (function applied to
--   each element and its index).
ifoldl' :: forall b a (n :: Nat). Storable b => (a -> Finite n -> b -> a) -> a -> Vector n b -> a

-- | <i>O(n)</i> Right fold (function applied to each element and its
--   index).
ifoldr :: forall a (n :: Nat) b. Storable a => (Finite n -> a -> b -> b) -> b -> Vector n a -> b

-- | <i>O(n)</i> Right fold with strict accumulator (function applied to
--   each element and its index).
ifoldr' :: forall a (n :: Nat) b. Storable a => (Finite n -> a -> b -> b) -> b -> Vector n a -> b

-- | <i>O(n)</i> Check if all elements satisfy the predicate.
all :: forall a (n :: Nat). Storable a => (a -> Bool) -> Vector n a -> Bool

-- | <i>O(n)</i> Check if any element satisfies the predicate.
any :: forall a (n :: Nat). Storable a => (a -> Bool) -> Vector n a -> Bool

-- | <i>O(n)</i> Check if all elements are <a>True</a>
and :: forall (n :: Nat). Vector n Bool -> Bool

-- | <i>O(n)</i> Check if any element is <a>True</a>
or :: forall (n :: Nat). Vector n Bool -> Bool

-- | <i>O(n)</i> Compute the sum of the elements.
sum :: forall a (n :: Nat). (Storable a, Num a) => Vector n a -> a

-- | <i>O(n)</i> Compute the product of the elements.
product :: forall a (n :: Nat). (Storable a, Num a) => Vector n a -> a

-- | <i>O(n)</i> Yield the maximum element of the non-empty vector.
maximum :: forall a (n :: Natural). (Storable a, Ord a) => Vector (n + 1) a -> a

-- | <i>O(n)</i> Yield the maximum element of the non-empty vector
--   according to the given comparison function.
maximumBy :: forall a (n :: Natural). Storable a => (a -> a -> Ordering) -> Vector (n + 1) a -> a

-- | <i>O(n)</i> Yield the minimum element of the non-empty vector.
minimum :: forall a (n :: Natural). (Storable a, Ord a) => Vector (n + 1) a -> a

-- | <i>O(n)</i> Yield the minimum element of the non-empty vector
--   according to the given comparison function.
minimumBy :: forall a (n :: Natural). Storable a => (a -> a -> Ordering) -> Vector (n + 1) a -> a

-- | <i>O(n)</i> Yield the index of the maximum element of the non-empty
--   vector.
maxIndex :: forall a (n :: Natural). (Storable a, Ord a) => Vector (n + 1) a -> Finite (n + 1)

-- | <i>O(n)</i> Yield the index of the maximum element of the non-empty
--   vector according to the given comparison function.
maxIndexBy :: forall a (n :: Natural). Storable a => (a -> a -> Ordering) -> Vector (n + 1) a -> Finite (n + 1)

-- | <i>O(n)</i> Yield the index of the minimum element of the non-empty
--   vector.
minIndex :: forall a (n :: Natural). (Storable a, Ord a) => Vector (n + 1) a -> Finite (n + 1)

-- | <i>O(n)</i> Yield the index of the minimum element of the non-empty
--   vector according to the given comparison function.
minIndexBy :: forall a (n :: Natural). Storable a => (a -> a -> Ordering) -> Vector (n + 1) a -> Finite (n + 1)

-- | <i>O(n)</i> Monadic fold.
foldM :: forall m b a (n :: Nat). (Monad m, Storable b) => (a -> b -> m a) -> a -> Vector n b -> m a

-- | <i>O(n)</i> Monadic fold (action applied to each element and its
--   index).
ifoldM :: forall m b a (n :: Nat). (Monad m, Storable b) => (a -> Finite n -> b -> m a) -> a -> Vector n b -> m a

-- | <i>O(n)</i> Monadic fold over non-empty vectors.
fold1M :: forall m a (n :: Natural). (Monad m, Storable a) => (a -> a -> m a) -> Vector (1 + n) a -> m a

-- | <i>O(n)</i> Monadic fold with strict accumulator.
foldM' :: forall m b a (n :: Nat). (Monad m, Storable b) => (a -> b -> m a) -> a -> Vector n b -> m a

-- | <i>O(n)</i> Monadic fold with strict accumulator (action applied to
--   each element and its index).
ifoldM' :: forall m b a (n :: Nat). (Monad m, Storable b) => (a -> Finite n -> b -> m a) -> a -> Vector n b -> m a

-- | <i>O(n)</i> Monadic fold over non-empty vectors with strict
--   accumulator.
fold1M' :: forall m a (n :: Natural). (Monad m, Storable a) => (a -> a -> m a) -> Vector (n + 1) a -> m a

-- | <i>O(n)</i> Monadic fold that discards the result.
foldM_ :: forall m b a (n :: Nat). (Monad m, Storable b) => (a -> b -> m a) -> a -> Vector n b -> m ()

-- | <i>O(n)</i> Monadic fold that discards the result (action applied to
--   each element and its index).
ifoldM_ :: forall m b a (n :: Nat). (Monad m, Storable b) => (a -> Finite n -> b -> m a) -> a -> Vector n b -> m ()

-- | <i>O(n)</i> Monadic fold over non-empty vectors that discards the
--   result.
fold1M_ :: forall m a (n :: Natural). (Monad m, Storable a) => (a -> a -> m a) -> Vector (n + 1) a -> m ()

-- | <i>O(n)</i> Monadic fold with strict accumulator that discards the
--   result.
foldM'_ :: forall m b a (n :: Nat). (Monad m, Storable b) => (a -> b -> m a) -> a -> Vector n b -> m ()

-- | <i>O(n)</i> Monadic fold with strict accumulator that discards the
--   result (action applied to each element and its index).
ifoldM'_ :: forall m b a (n :: Nat). (Monad m, Storable b) => (a -> Finite n -> b -> m a) -> a -> Vector n b -> m ()

-- | <i>O(n)</i> Monad fold over non-empty vectors with strict accumulator
--   that discards the result.
fold1M'_ :: forall m a (n :: Natural). (Monad m, Storable a) => (a -> a -> m a) -> Vector (n + 1) a -> m ()

-- | Evaluate each action and collect the results.
sequence :: forall m a (n :: Nat). (Monad m, Storable a, Storable (m a)) => Vector n (m a) -> m (Vector n a)

-- | Evaluate each action and discard the results.
sequence_ :: forall m a (n :: Nat). (Monad m, Storable (m a)) => Vector n (m a) -> m ()

-- | <i>O(n)</i> Prescan.
--   
--   <pre>
--   prescanl f z = <a>init</a> . <a>scanl</a> f z
--   </pre>
--   
--   Example: <tt>prescanl (+) 0 &lt;1,2,3,4&gt; = &lt;0,1,3,6&gt;</tt>
prescanl :: forall a b (n :: Nat). (Storable a, Storable b) => (a -> b -> a) -> a -> Vector n b -> Vector n a

-- | <i>O(n)</i> Prescan with strict accumulator.
prescanl' :: forall a b (n :: Nat). (Storable a, Storable b) => (a -> b -> a) -> a -> Vector n b -> Vector n a

-- | <i>O(n)</i> Scan.
postscanl :: forall a b (n :: Nat). (Storable a, Storable b) => (a -> b -> a) -> a -> Vector n b -> Vector n a

-- | <i>O(n)</i> Scan with strict accumulator.
postscanl' :: forall a b (n :: Nat). (Storable a, Storable b) => (a -> b -> a) -> a -> Vector n b -> Vector n a

-- | <i>O(n)</i> Haskell-style scan.
scanl :: forall a b (n :: Nat). (Storable a, Storable b) => (a -> b -> a) -> a -> Vector n b -> Vector (1 + n) a

-- | <i>O(n)</i> Haskell-style scan with strict accumulator.
scanl' :: forall a b (n :: Nat). (Storable a, Storable b) => (a -> b -> a) -> a -> Vector n b -> Vector (1 + n) a

-- | <i>O(n)</i> Scan over a non-empty vector.
scanl1 :: forall a (n :: Natural). Storable a => (a -> a -> a) -> Vector (1 + n) a -> Vector (2 + n) a

-- | <i>O(n)</i> Scan over a non-empty vector with a strict accumulator.
scanl1' :: forall a (n :: Natural). Storable a => (a -> a -> a) -> Vector (1 + n) a -> Vector (2 + n) a

-- | <i>O(n)</i> Right-to-left prescan.
prescanr :: forall a b (n :: Nat). (Storable a, Storable b) => (a -> b -> b) -> b -> Vector n a -> Vector n b

-- | <i>O(n)</i> Right-to-left prescan with strict accumulator.
prescanr' :: forall a b (n :: Nat). (Storable a, Storable b) => (a -> b -> b) -> b -> Vector n a -> Vector n b

-- | <i>O(n)</i> Right-to-left scan.
postscanr :: forall a b (n :: Nat). (Storable a, Storable b) => (a -> b -> b) -> b -> Vector n a -> Vector n b

-- | <i>O(n)</i> Right-to-left scan with strict accumulator.
postscanr' :: forall a b (n :: Nat). (Storable a, Storable b) => (a -> b -> b) -> b -> Vector n a -> Vector n b

-- | <i>O(n)</i> Right-to-left Haskell-style scan.
scanr :: forall a b (n :: Nat). (Storable a, Storable b) => (a -> b -> b) -> b -> Vector n a -> Vector (n + 1) b

-- | <i>O(n)</i> Right-to-left Haskell-style scan with strict accumulator.
scanr' :: forall a b (n :: Nat). (Storable a, Storable b) => (a -> b -> b) -> b -> Vector n a -> Vector (n + 1) b

-- | <i>O(n)</i> Right-to-left scan over a non-empty vector.
scanr1 :: forall a (n :: Natural). Storable a => (a -> a -> a) -> Vector (n + 1) a -> Vector (n + 2) a

-- | <i>O(n)</i> Right-to-left scan over a non-empty vector with a strict
--   accumulator.
scanr1' :: forall a (n :: Natural). Storable a => (a -> a -> a) -> Vector (n + 1) a -> Vector (n + 2) a

-- | <i>O(n)</i> Convert a vector to a list.
toList :: forall a (n :: Nat). Storable a => Vector n a -> [a]

-- | <i>O(n)</i> Convert a list to a vector.
fromList :: forall a (n :: Nat). (Storable a, KnownNat n) => [a] -> Maybe (Vector n a)

-- | <i>O(n)</i> Convert the first <tt>n</tt> elements of a list to a
--   vector. The length of the resulting vector is inferred from the type.
fromListN :: forall (n :: Nat) a. (Storable a, KnownNat n) => [a] -> Maybe (Vector n a)

-- | <i>O(n)</i> Convert the first <tt>n</tt> elements of a list to a
--   vector. The length of the resulting vector is given explicitly as a
--   <a>Proxy</a> argument.
fromListN' :: forall (n :: Nat) a p. (Storable a, KnownNat n) => p n -> [a] -> Maybe (Vector n a)

-- | <i>O(n)</i> Takes a list and returns a continuation providing a vector
--   with a size parameter corresponding to the length of the list.
--   
--   Essentially converts a list into a vector with the proper size
--   parameter, determined at runtime.
--   
--   See <a>withSized</a>
withSizedList :: Storable a => [a] -> (forall (n :: Nat). KnownNat n => Vector n a -> r) -> r

-- | <i>O(n)</i> Yield an immutable copy of the mutable vector.
freeze :: forall m a (n :: Nat). (PrimMonad m, Storable a) => MVector n (PrimState m) a -> m (Vector n a)

-- | <i>O(n)</i> Yield a mutable copy of the immutable vector.
thaw :: forall m a (n :: Nat). (PrimMonad m, Storable a) => Vector n a -> m (MVector n (PrimState m) a)

-- | <i>O(n)</i> Copy an immutable vector into a mutable one.
copy :: forall m a (n :: Nat). (PrimMonad m, Storable a) => MVector n (PrimState m) a -> Vector n a -> m ()

-- | <i>O(1)</i> Unsafely convert a mutable vector to an immutable one
--   withouy copying. The mutable vector may not be used after this
--   operation.
unsafeFreeze :: forall m a (n :: Nat). (PrimMonad m, Storable a) => MVector n (PrimState m) a -> m (Vector n a)

-- | <i>O(n)</i> Unsafely convert an immutable vector to a mutable one
--   without copying. The immutable vector may not be used after this
--   operation.
unsafeThaw :: forall m a (n :: Nat). (PrimMonad m, Storable a) => Vector n a -> m (MVector n (PrimState m) a)

-- | Convert a <a>Vector</a> into a <a>Vector</a> if it has the correct
--   size, otherwise return <a>Nothing</a>.
toSized :: forall (n :: Nat) a. (Storable a, KnownNat n) => Vector a -> Maybe (Vector n a)

-- | Takes a <a>Vector</a> and returns a continuation providing a
--   <a>Vector</a> with a size parameter <tt>n</tt> that is determined at
--   runtime based on the length of the input vector.
--   
--   Essentially converts a <a>Vector</a> into a <a>Vector</a> with the
--   correct size parameter <tt>n</tt>.
withSized :: Storable a => Vector a -> (forall (n :: Nat). KnownNat n => Vector n a -> r) -> r
fromSized :: forall (n :: Nat) a. Vector n a -> Vector a

-- | Apply a function on unsized vectors to a sized vector. The function
--   must preserve the size of the vector, this is not checked.
withVectorUnsafe :: forall a b (n :: Nat). (Vector a -> Vector b) -> Vector n a -> Vector n b

-- | Apply a function on two unsized vectors to sized vectors. The function
--   must preserve the size of the vectors, this is not checked.
zipVectorsUnsafe :: forall a b c (n :: Nat). (Vector a -> Vector b -> Vector c) -> Vector n a -> Vector n b -> Vector n c


-- | This module re-exports the functionality in <a>Sized</a> specialized
--   to <a>Mutable</a>.
--   
--   Functions returning a vector determine the size from the type context
--   unless they have a <tt>'</tt> suffix in which case they take an
--   explicit <a>Proxy</a> argument.
--   
--   Functions where the resulting vector size is not known until runtime
--   are not exported.
module Data.Vector.Unboxed.Mutable.Sized

-- | <a>Vector</a> specialized to use <a>Mutable</a>.
type MVector = MVector MVector

-- | <i>O(1)</i> Yield the length of the mutable vector as an <a>Int</a>.
length :: forall (n :: Nat) s a. KnownNat n => MVector n s a -> Int

-- | <i>O(1)</i> Yield the length of the mutable vector as a <a>Proxy</a>.
length' :: forall (n :: Nat) s a. MVector n s a -> Proxy n

-- | <i>O(1)</i> Check whether the mutable vector is empty.
null :: forall (n :: Nat) s a. KnownNat n => MVector n s a -> Bool

-- | <i>O(1)</i> Yield a slice of the mutable vector without copying it
--   with an inferred length argument.
slice :: forall (i :: Nat) (n :: Nat) (k :: Natural) s a p. (KnownNat i, KnownNat n, Unbox a) => p i -> MVector ((i + n) + k) s a -> MVector n s a

-- | <i>O(1)</i> Yield a slice of the mutable vector without copying it
--   with an explicit length argument.
slice' :: forall (i :: Nat) (n :: Nat) (k :: Natural) s a p. (KnownNat i, KnownNat n, Unbox a) => p i -> p n -> MVector ((i + n) + k) s a -> MVector n s a

-- | <i>O(1)</i> Yield all but the last element of a non-empty mutable
--   vector without copying.
init :: forall (n :: Natural) s a. Unbox a => MVector (n + 1) s a -> MVector n s a

-- | <i>O(1)</i> Yield all but the first element of a non-empty mutable
--   vector without copying.
tail :: forall (n :: Natural) s a. Unbox a => MVector (1 + n) s a -> MVector n s a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements. The resulting vector
--   always contains this many elements. The length of the resulting vector
--   is inferred from the type.
take :: forall (n :: Nat) (k :: Natural) s a. (KnownNat n, Unbox a) => MVector (n + k) s a -> MVector n s a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements. The resulting vector
--   always contains this many elements. The length of the resulting vector
--   is given explicitly as a <a>Proxy</a> argument.
take' :: forall (n :: Nat) (k :: Natural) s a p. (KnownNat n, Unbox a) => p n -> MVector (n + k) s a -> MVector n s a

-- | <i>O(1)</i> Yield all but the the first <tt>n</tt> elements. The given
--   vector must contain at least this many elements. The length of the
--   resulting vector is inferred from the type.
drop :: forall (n :: Nat) (k :: Natural) s a. (KnownNat n, Unbox a) => MVector (n + k) s a -> MVector k s a

-- | <i>O(1)</i> Yield all but the the first <tt>n</tt> elements. The given
--   vector must contain at least this many elements. The length of the
--   resulting vector is givel explicitly as a <a>Proxy</a> argument.
drop' :: forall (n :: Nat) (k :: Natural) s a p. (KnownNat n, Unbox a) => p n -> MVector (n + k) s a -> MVector k s a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements, paired with the rest,
--   without copying. The lengths of the resulting vectors are inferred
--   from the type.
splitAt :: forall (n :: Nat) (m :: Natural) s a. (KnownNat n, Unbox a) => MVector (n + m) s a -> (MVector n s a, MVector m s a)

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements, paired with the rest,
--   without copying. The length of the first resulting vector is passed
--   explicitly as a <a>Proxy</a> argument.
splitAt' :: forall (n :: Nat) (m :: Natural) s a p. (KnownNat n, Unbox a) => p n -> MVector (n + m) s a -> (MVector n s a, MVector m s a)

-- | <i>O(1)</i> Check if two vectors overlap.
overlaps :: forall (n :: Nat) (k :: Nat) s a. Unbox a => MVector n s a -> MVector k s a -> Bool

-- | Create a mutable vector where the length is inferred from the type.
new :: forall (n :: Nat) m a. (KnownNat n, PrimMonad m, Unbox a) => m (MVector n (PrimState m) a)

-- | Create a mutable vector where the length is inferred from the type.
--   The memory is not initialized.
unsafeNew :: forall (n :: Nat) m a. (KnownNat n, PrimMonad m, Unbox a) => m (MVector n (PrimState m) a)

-- | Create a mutable vector where the length is inferred from the type and
--   fill it with an initial value.
replicate :: forall (n :: Nat) m a. (KnownNat n, PrimMonad m, Unbox a) => a -> m (MVector n (PrimState m) a)

-- | Create a mutable vector where the length is given explicitly as a
--   <a>Proxy</a> argument and fill it with an initial value.
replicate' :: forall (n :: Nat) m a p. (KnownNat n, PrimMonad m, Unbox a) => p n -> a -> m (MVector n (PrimState m) a)

-- | Create a mutable vector where the length is inferred from the type and
--   fill it with values produced by repeatedly executing the monadic
--   action.
replicateM :: forall (n :: Nat) m a. (KnownNat n, PrimMonad m, Unbox a) => m a -> m (MVector n (PrimState m) a)

-- | Create a mutable vector where the length is given explicitly as a
--   <a>Proxy</a> argument and fill it with values produced by repeatedly
--   executing the monadic action.
replicateM' :: forall (n :: Nat) m a p. (KnownNat n, PrimMonad m, Unbox a) => p n -> m a -> m (MVector n (PrimState m) a)

-- | Create a copy of a mutable vector.
clone :: forall (n :: Nat) m a. (PrimMonad m, Unbox a) => MVector n (PrimState m) a -> m (MVector n (PrimState m) a)

-- | Grow a mutable vector by an amount given explicitly as a <a>Proxy</a>
--   argument.
grow :: forall (n :: Nat) (k :: Nat) m a p. (KnownNat k, PrimMonad m, Unbox a) => p k -> MVector n (PrimState m) a -> m (MVector (n + k) (PrimState m) a)

-- | Grow a mutable vector (from the front) by an amount given explicitly
--   as a <a>Proxy</a> argument.
growFront :: forall (n :: Nat) (k :: Nat) m a p. (KnownNat k, PrimMonad m, Unbox a) => p k -> MVector n (PrimState m) a -> m (MVector (n + k) (PrimState m) a)

-- | Reset all elements of the vector to some undefined value, clearing all
--   references to external objects.
clear :: forall m a (n :: Nat). (PrimMonad m, Unbox a) => MVector n (PrimState m) a -> m ()

-- | <i>O(1)</i> Yield the element at a given type-safe position using
--   <a>Finite</a>.
read :: forall (n :: Nat) m a. (PrimMonad m, Unbox a) => MVector n (PrimState m) a -> Finite n -> m a

-- | <i>O(1)</i> Yield the element at a given type-safe position using
--   <a>Proxy</a>.
read' :: forall (n :: Natural) (k :: Nat) a m p. (KnownNat k, PrimMonad m, Unbox a) => MVector ((n + k) + 1) (PrimState m) a -> p k -> m a

-- | <i>O(1)</i> Replace the element at a given type-safe position using
--   <a>Finite</a>.
write :: forall (n :: Nat) m a. (PrimMonad m, Unbox a) => MVector n (PrimState m) a -> Finite n -> a -> m ()

-- | <i>O(1)</i> Replace the element at a given type-safe position using
--   <a>Proxy</a>.
write' :: forall (n :: Natural) (k :: Nat) a m p. (KnownNat k, PrimMonad m, Unbox a) => MVector ((n + k) + 1) (PrimState m) a -> p k -> a -> m ()

-- | <i>O(1)</i> Modify the element at a given type-safe position using
--   <a>Finite</a>.
modify :: forall (n :: Nat) m a. (PrimMonad m, Unbox a) => MVector n (PrimState m) a -> (a -> a) -> Finite n -> m ()

-- | <i>O(1)</i> Modify the element at a given type-safe position using
--   <a>Proxy</a>.
modify' :: forall (n :: Natural) (k :: Nat) a m p. (KnownNat k, PrimMonad m, Unbox a) => MVector ((n + k) + 1) (PrimState m) a -> (a -> a) -> p k -> m ()

-- | <i>O(1)</i> Swap the elements at the given type-safe positions using
--   <a>Finite</a>s.
swap :: forall (n :: Nat) m a. (PrimMonad m, Unbox a) => MVector n (PrimState m) a -> Finite n -> Finite n -> m ()

-- | <i>O(1)</i> Replace the element at a given type-safe position and
--   return the old element, using <a>Finite</a>.
exchange :: forall (n :: Nat) m a. (PrimMonad m, Unbox a) => MVector n (PrimState m) a -> Finite n -> a -> m a

-- | <i>O(1)</i> Replace the element at a given type-safe position and
--   return the old element, using <a>Finite</a>.
exchange' :: forall (n :: Natural) (k :: Nat) a m p. (KnownNat k, PrimMonad m, Unbox a) => MVector ((n + k) + 1) (PrimState m) a -> p k -> a -> m a

-- | <i>O(1)</i> Yield the element at a given <a>Int</a> position without
--   bounds checking.
unsafeRead :: forall (n :: Nat) a m. (PrimMonad m, Unbox a) => MVector n (PrimState m) a -> Int -> m a

-- | <i>O(1)</i> Replace the element at a given <a>Int</a> position without
--   bounds checking.
unsafeWrite :: forall (n :: Nat) m a. (PrimMonad m, Unbox a) => MVector n (PrimState m) a -> Int -> a -> m ()

-- | <i>O(1)</i> Modify the element at a given <a>Int</a> position without
--   bounds checking.
unsafeModify :: forall (n :: Nat) m a. (PrimMonad m, Unbox a) => MVector n (PrimState m) a -> (a -> a) -> Int -> m ()

-- | <i>O(1)</i> Swap the elements at the given <a>Int</a> positions
--   without bounds checking.
unsafeSwap :: forall (n :: Nat) m a. (PrimMonad m, Unbox a) => MVector n (PrimState m) a -> Int -> Int -> m ()

-- | <i>O(1)</i> Replace the element at a given <a>Int</a> position and
--   return the old element. No bounds checks are performed.
unsafeExchange :: forall (n :: Nat) m a. (PrimMonad m, Unbox a) => MVector n (PrimState m) a -> Int -> a -> m a

-- | Compute the next permutation (lexicographically) of a given vector
--   in-place. Returns <a>False</a> when the input is the last permutation.
nextPermutation :: forall (n :: Nat) e m. (Ord e, PrimMonad m, Unbox e) => MVector n (PrimState m) e -> m Bool

-- | Set all elements of the vector to the given value.
set :: forall m a (n :: Nat). (PrimMonad m, Unbox a) => MVector n (PrimState m) a -> a -> m ()

-- | Copy a vector. The two vectors may not overlap.
copy :: forall m a (n :: Nat). (PrimMonad m, Unbox a) => MVector n (PrimState m) a -> MVector n (PrimState m) a -> m ()

-- | Move the contents of a vector. If the two vectors do not overlap, this
--   is equivalent to <a>copy</a>. Otherwise, the copying is performed as
--   if the source vector were copied to a temporary vector and then the
--   temporary vector was copied to the target vector.
move :: forall m a (n :: Nat). (PrimMonad m, Unbox a) => MVector n (PrimState m) a -> MVector n (PrimState m) a -> m ()

-- | Copy a vector. The two vectors may not overlap. This is not checked.
unsafeCopy :: forall m a (n :: Nat). (PrimMonad m, Unbox a) => MVector n (PrimState m) a -> MVector n (PrimState m) a -> m ()

-- | Convert a <a>MVector</a> into a <a>MVector</a> if it has the correct
--   size, otherwise return Nothing.
--   
--   Note that this does no copying; the returned <a>MVector</a> is a
--   reference to the exact same vector in memory as the given one, and any
--   modifications to it are also reflected in the given <a>MVector</a>.
toSized :: forall (n :: Nat) a s. (KnownNat n, Unbox a) => MVector s a -> Maybe (MVector n s a)

-- | Takes a <a>MVector</a> and returns a continuation providing a
--   <a>MVector</a> with a size parameter <tt>n</tt> that is determined at
--   runtime based on the length of the input vector.
--   
--   Essentially converts a <a>MVector</a> into a <a>MVector</a> with the
--   correct size parameter <tt>n</tt>.
--   
--   Note that this does no copying; the returned <a>MVector</a> is a
--   reference to the exact same vector in memory as the given one, and any
--   modifications to it are also reflected in the given <a>MVector</a>.
withSized :: forall s a r. Unbox a => MVector s a -> (forall (n :: Nat). KnownNat n => MVector n s a -> r) -> r

-- | Convert a <a>MVector</a> into a <a>MVector</a>.
--   
--   Note that this does no copying; the returned <a>MVector</a> is a
--   reference to the exact same vector in memory as the given one, and any
--   modifications to it are also reflected in the given <a>MVector</a>.
fromSized :: forall (n :: Nat) s a. MVector n s a -> MVector s a
class (Vector Vector a, MVector MVector a) => Unbox a
instance (Data.Vector.Unboxed.Base.Unbox a, GHC.Internal.TypeNats.KnownNat n) => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (Data.Vector.Generic.Sized.Internal.Vector Data.Vector.Unboxed.Base.Vector n a)
instance (Data.Vector.Unboxed.Base.Unbox a, GHC.Internal.TypeNats.KnownNat n) => Data.Vector.Unboxed.Base.Unbox (Data.Vector.Generic.Sized.Internal.Vector Data.Vector.Unboxed.Base.Vector n a)
instance (Data.Vector.Unboxed.Base.Unbox a, GHC.Internal.TypeNats.KnownNat n) => Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (Data.Vector.Generic.Sized.Internal.Vector Data.Vector.Unboxed.Base.Vector n a)


-- | This module re-exports the functionality in <a>Sized</a> specialized
--   to <a>Unboxed</a>.
--   
--   Functions returning a vector determine the size from the type context
--   unless they have a <tt>'</tt> suffix in which case they take an
--   explicit <a>Proxy</a> argument.
--   
--   Functions where the resulting vector size is not known until runtime
--   are not exported.
module Data.Vector.Unboxed.Sized

-- | <a>Vector</a> specialized to use <a>Unboxed</a>.
type Vector = Vector Vector

-- | Pattern synonym that lets you treat an unsized vector as if it
--   "contained" a sized vector. If you pattern match on an unsized vector,
--   its contents will be the <i>sized</i> vector counterpart.
--   
--   <pre>
--   testFunc :: Unsized.Vector Int -&gt; Int
--   testFunc (<a>SomeSized</a> v) =
--       <a>sum</a> (<a>zipWith</a> (+) v (<a>replicate</a> 1))
--           -- ^ here, v is `Sized.Vector n Int`, and we have
--                       `<a>KnownNat</a> n`
--   </pre>
--   
--   The <tt>n</tt> type variable will be properly instantiated to whatever
--   the length of the vector is, and you will also have a
--   <tt><a>KnownNat</a> n</tt> instance available. You can get <tt>n</tt>
--   in scope by turning on ScopedTypeVariables and matching on
--   <tt><a>SomeSized</a> (v :: Sized.Vector n Int)</tt>.
--   
--   Without this, you would otherwise have to use <a>withSized</a> to do
--   the same thing:
--   
--   <pre>
--   testFunc :: Unsized.Vector Int -&gt; Int
--   testFunc u = <a>withSized</a> u $ \v -&gt;
--       <a>sum</a> (<a>zipWith</a> (+) v (<a>replicate</a> 1))
--   </pre>
--   
--   Remember that the type of final result of your function (the
--   <tt>Int</tt>, here) must <i>not</i> depend on <tt>n</tt>. However, the
--   types of the intermediate values are allowed to depend on <tt>n</tt>.
--   
--   This is <i>especially</i> useful in do blocks, where you can pattern
--   match on the unsized results of actions, to use the sized vector in
--   the rest of the do block. You also get a <tt><a>KnownNat</a> n</tt>
--   constraint for the remainder of the do block.
--   
--   <pre>
--   -- If you had:
--   getAVector :: IO (Unsized.Vector Int)
--   
--   main :: IO ()
--   main = do
--       SomeSized v &lt;- getAVector -- v is `Sized.Vector n Int`
--       -- get n in scope
--       SomeSized (v :: Sized.Vector n Int) &lt;- getAVector
--       print v
--   </pre>
--   
--   Remember that the final type of the result of the do block
--   (<tt>()</tt>, here) must not depend on <tt>n</tt>. However, the
--   
--   Also useful in ghci, where you can pattern match to get sized vectors
--   from unsized vectors.
--   
--   <pre>
--   ghci&gt; SomeSized v &lt;- pure (myUnsizedVector :: Unsized.Vector Int)
--                -- ^ v is `Sized.Vector n Int`
--   </pre>
--   
--   This enables interactive exploration with sized vectors in ghci, and
--   is useful for using with other libraries and functions that expect
--   sized vectors in an interactive setting.
--   
--   (Note that as of GHC 8.6, you cannot get the <tt>n</tt> in scope in
--   your ghci session using ScopedTypeVariables, like you can with do
--   blocks)
--   
--   You can also use this as a constructor, to take a sized vector and
--   "hide" the size, to produce an unsized vector:
--   
--   <pre>
--   SomeSized :: Sized.Vector n a -&gt; Unsized.Vector a
--   </pre>
pattern SomeSized :: forall a (n :: Nat). Unbox a => KnownNat n => Vector n a -> Vector a

-- | <a>Vector</a> specialized to use <a>Mutable</a>.
type MVector = MVector MVector

-- | <i>O(1)</i> Yield the length of the vector as an <a>Int</a>. This is
--   more like <a>natVal</a> than <a>length</a>, extracting the value from
--   the <a>KnownNat</a> instance and not looking at the vector itself.
length :: forall (n :: Nat) a. KnownNat n => Vector n a -> Int

-- | <i>O(1)</i> Yield the length of the vector as a <a>Proxy</a>. This
--   function doesn't <i>do</i> anything; it merely allows the size
--   parameter of the vector to be passed around as a <a>Proxy</a>.
length' :: forall (n :: Nat) a. Vector n a -> Proxy n

-- | <i>O(1)</i> Reveal a <a>KnownNat</a> instance for a vector's length,
--   determined at runtime.
knownLength :: forall (n :: Nat) a r. Unbox a => Vector n a -> (KnownNat n => r) -> r

-- | <i>O(1)</i> Reveal a <a>KnownNat</a> instance and <a>Proxy</a> for a
--   vector's length, determined at runtime.
knownLength' :: forall (n :: Nat) a r. Unbox a => Vector n a -> (KnownNat n => Proxy n -> r) -> r

-- | <i>O(1)</i> Safe indexing using a <a>Finite</a>.
index :: forall (n :: Nat) a. Unbox a => Vector n a -> Finite n -> a

-- | <i>O(1)</i> Safe indexing using a <a>Proxy</a>.
index' :: forall (n :: Nat) (m :: Natural) a p. (KnownNat n, Unbox a) => Vector ((n + m) + 1) a -> p n -> a

-- | <i>O(1)</i> Indexing using an <a>Int</a> without bounds checking.
unsafeIndex :: forall (n :: Nat) a. Unbox a => Vector n a -> Int -> a

-- | <i>O(1)</i> Yield the first element of a non-empty vector.
head :: forall (n :: Natural) a. Unbox a => Vector (1 + n) a -> a

-- | <i>O(1)</i> Yield the last element of a non-empty vector.
last :: forall (n :: Natural) a. Unbox a => Vector (n + 1) a -> a

-- | <i>O(1)</i> Safe indexing in a monad. See the documentation for
--   <a>indexM</a> for an explanation of why this is useful.
indexM :: forall (n :: Nat) a m. (Unbox a, Monad m) => Vector n a -> Finite n -> m a

-- | <i>O(1)</i> Safe indexing in a monad using a <a>Proxy</a>. See the
--   documentation for <a>indexM</a> for an explanation of why this is
--   useful.
indexM' :: forall (n :: Nat) (k :: Natural) a m p. (KnownNat n, Unbox a, Monad m) => Vector (n + k) a -> p n -> m a

-- | <i>O(1)</i> Indexing using an Int without bounds checking. See the
--   documentation for <a>indexM</a> for an explanation of why this is
--   useful.
unsafeIndexM :: forall (n :: Nat) a m. (Unbox a, Monad m) => Vector n a -> Int -> m a

-- | <i>O(1)</i> Yield the first element of a non-empty vector in a monad.
--   See the documentation for <a>indexM</a> for an explanation of why this
--   is useful.
headM :: forall (n :: Natural) a m. (Unbox a, Monad m) => Vector (1 + n) a -> m a

-- | <i>O(1)</i> Yield the last element of a non-empty vector in a monad.
--   See the documentation for <a>indexM</a> for an explanation of why this
--   is useful.
lastM :: forall (n :: Natural) a m. (Unbox a, Monad m) => Vector (n + 1) a -> m a

-- | <i>O(1)</i> Yield a slice of the vector without copying it with an
--   inferred length argument.
slice :: forall (i :: Nat) (n :: Nat) (m :: Natural) a p. (KnownNat i, KnownNat n, Unbox a) => p i -> Vector ((i + n) + m) a -> Vector n a

-- | <i>O(1)</i> Yield a slice of the vector without copying it with an
--   explicit length argument.
slice' :: forall (i :: Nat) (n :: Nat) (m :: Natural) a p. (KnownNat i, KnownNat n, Unbox a) => p i -> p n -> Vector ((i + n) + m) a -> Vector n a

-- | <i>O(1)</i> Yield all but the last element of a non-empty vector
--   without copying.
init :: forall (n :: Natural) a. Unbox a => Vector (n + 1) a -> Vector n a

-- | <i>O(1)</i> Yield all but the first element of a non-empty vector
--   without copying.
tail :: forall (n :: Natural) a. Unbox a => Vector (1 + n) a -> Vector n a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements. The resulting vector
--   always contains this many elements. The length of the resulting vector
--   is inferred from the type.
take :: forall (n :: Nat) (m :: Natural) a. (KnownNat n, Unbox a) => Vector (n + m) a -> Vector n a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements. The resulting vector
--   always contains this many elements. The length of the resulting vector
--   is given explicitly as a <a>Proxy</a> argument.
take' :: forall (n :: Nat) (m :: Natural) a p. (KnownNat n, Unbox a) => p n -> Vector (n + m) a -> Vector n a

-- | <i>O(1)</i> Yield all but the the first <tt>n</tt> elements. The given
--   vector must contain at least this many elements. The length of the
--   resulting vector is inferred from the type.
drop :: forall (n :: Nat) (m :: Natural) a. (KnownNat n, Unbox a) => Vector (n + m) a -> Vector m a

-- | <i>O(1)</i> Yield all but the the first <tt>n</tt> elements. The given
--   vector must contain at least this many elements. The length of the
--   resulting vector is givel explicitly as a <a>Proxy</a> argument.
drop' :: forall (n :: Nat) (m :: Natural) a p. (KnownNat n, Unbox a) => p n -> Vector (n + m) a -> Vector m a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements, paired with the rest,
--   without copying. The lengths of the resulting vector are inferred from
--   the type.
splitAt :: forall (n :: Nat) (m :: Natural) a. (KnownNat n, Unbox a) => Vector (n + m) a -> (Vector n a, Vector m a)

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements, paired with the rest,
--   without copying. The length of the first resulting vector is passed
--   explicitly as a <a>Proxy</a> argument.
splitAt' :: forall (n :: Nat) (m :: Natural) a p. (KnownNat n, Unbox a) => p n -> Vector (n + m) a -> (Vector n a, Vector m a)

-- | <i>O(1)</i> Empty vector.
empty :: Unbox a => Vector 0 a

-- | <i>O(1)</i> Vector with exactly one element.
singleton :: Unbox a => a -> Vector 1 a

-- | <i>O(n)</i> Construct a vector in a type safe manner using a tuple.
--   <tt> fromTuple (1,2) :: Vector 2 Int fromTuple ("hey", "what's",
--   "going", "on") :: Vector 4 String </tt>
fromTuple :: forall a input (length :: Nat). (Unbox a, IndexedListLiterals input length a, KnownNat length) => input -> Vector length a

-- | <i>O(n)</i> Construct a vector in a type-safe manner using a sized
--   linked list. <tt> Build (1 :&lt; 2 :&lt; 3 :&lt; Nil) :: Vector 3 Int
--   Build ("not" :&lt; "much" :&lt; Nil) :: Vector 2 String </tt> Can also
--   be used as a pattern.
pattern Build :: Unbox a => BuildVector n a -> Vector n a

-- | <i>O(n)</i> Construct a vector with the same element in each position
--   where the length is inferred from the type.
replicate :: forall (n :: Nat) a. (KnownNat n, Unbox a) => a -> Vector n a

-- | <i>O(n)</i> Construct a vector with the same element in each position
--   where the length is given explicitly as a <a>Proxy</a> argument.
replicate' :: forall (n :: Nat) a p. (KnownNat n, Unbox a) => p n -> a -> Vector n a

-- | <i>O(n)</i> construct a vector of the given length by applying the
--   function to each index where the length is inferred from the type.
generate :: forall (n :: Nat) a. (KnownNat n, Unbox a) => (Finite n -> a) -> Vector n a

-- | <i>O(n)</i> construct a vector of the given length by applying the
--   function to each index where the length is given explicitly as a
--   <a>Proxy</a> argument.
generate' :: forall (n :: Nat) a p. (KnownNat n, Unbox a) => p n -> (Finite n -> a) -> Vector n a

-- | <i>O(n)</i> Apply the function <tt>n</tt> times to a value. Zeroth
--   element is original value. The length is inferred from the type.
iterateN :: forall (n :: Nat) a. (KnownNat n, Unbox a) => (a -> a) -> a -> Vector n a

-- | <i>O(n)</i> Apply the function <tt>n</tt> times to a value. Zeroth
--   element is original value. The length is given explicitly as a
--   <a>Proxy</a> argument.
iterateN' :: forall (n :: Nat) a p. (KnownNat n, Unbox a) => p n -> (a -> a) -> a -> Vector n a

-- | <i>O(n)</i> Execute the monadic action <tt>n</tt> times and store the
--   results in a vector where <tt>n</tt> is inferred from the type.
replicateM :: forall (n :: Nat) m a. (KnownNat n, Unbox a, Monad m) => m a -> m (Vector n a)

-- | <i>O(n)</i> Execute the monadic action <tt>n</tt> times and store the
--   results in a vector where <tt>n</tt> is given explicitly as a
--   <a>Proxy</a> argument.
replicateM' :: forall (n :: Nat) m a p. (KnownNat n, Unbox a, Monad m) => p n -> m a -> m (Vector n a)

-- | <i>O(n)</i> Construct a vector of length <tt>n</tt> by applying the
--   monadic action to each index where <tt>n</tt> is inferred from the
--   type.
generateM :: forall (n :: Nat) m a. (KnownNat n, Unbox a, Monad m) => (Finite n -> m a) -> m (Vector n a)

-- | <i>O(n)</i> Construct a vector of length <tt>n</tt> by applying the
--   monadic action to each index where <tt>n</tt> is given explicitly as a
--   <a>Proxy</a> argument.
generateM' :: forall (n :: Nat) m a p. (KnownNat n, Unbox a, Monad m) => p n -> (Finite n -> m a) -> m (Vector n a)

-- | <i>O(n)</i> Construct a vector with exactly <tt>n</tt> elements by
--   repeatedly applying the generator function to the a seed. The length
--   is inferred from the type.
unfoldrN :: forall (n :: Nat) a b. (KnownNat n, Unbox a) => (b -> (a, b)) -> b -> Vector n a

-- | <i>O(n)</i> Construct a vector with exactly <tt>n</tt> elements by
--   repeatedly applying the generator function to the a seed. The length
--   is given explicitly as a <a>Proxy</a> argument.
unfoldrN' :: forall (n :: Nat) a b p. (KnownNat n, Unbox a) => p n -> (b -> (a, b)) -> b -> Vector n a

-- | <i>O(n)</i> Yield a vector of length <tt>n</tt> containing the values
--   <tt>x</tt>, <tt>x+1</tt>, ..., <tt>x + (n - 1)</tt>. The length is
--   inferred from the type.
enumFromN :: forall (n :: Nat) a. (KnownNat n, Unbox a, Num a) => a -> Vector n a

-- | <i>O(n)</i> Yield a vector of length <tt>n</tt> containing the values
--   <tt>x</tt>, <tt>x+1</tt>, ..., <tt>x + (n - 1)</tt>. The length is
--   given explicitly as a <a>Proxy</a> argument.
enumFromN' :: forall (n :: Nat) a p. (KnownNat n, Unbox a, Num a) => a -> p n -> Vector n a

-- | <i>O(n)</i> Yield a vector of the given length containing the values
--   <tt>x</tt>, <tt>x+y</tt>, <tt>x+2y</tt>, ..., <tt>x + (n - 1)y</tt>.
--   The length is inferred from the type.
enumFromStepN :: forall (n :: Nat) a. (KnownNat n, Unbox a, Num a) => a -> a -> Vector n a

-- | <i>O(n)</i> Yield a vector of the given length containing the values
--   <tt>x</tt>, <tt>x+y</tt>, <tt>x+2y</tt>, ..., <tt>x + (n - 1)y</tt>.
--   The length is given explicitly as a <a>Proxy</a> argument.
enumFromStepN' :: forall (n :: Nat) a p. (KnownNat n, Unbox a, Num a) => a -> a -> p n -> Vector n a

-- | <i>O(n)</i> Prepend an element.
cons :: forall (n :: Nat) a. Unbox a => a -> Vector n a -> Vector (1 + n) a

-- | <i>O(n)</i> Append an element.
snoc :: forall (n :: Nat) a. Unbox a => Vector n a -> a -> Vector (n + 1) a

-- | <i>O(m+n)</i> Concatenate two vectors.
(++) :: forall (n :: Nat) (m :: Nat) a. Unbox a => Vector n a -> Vector m a -> Vector (n + m) a

-- | <i>O(n)</i> Yield the argument but force it not to retain any extra
--   memory, possibly by copying it.
--   
--   This is especially useful when dealing with slices. For example:
--   
--   <pre>
--   force (slice 0 2 &lt;huge vector&gt;)
--   </pre>
--   
--   Here, the slice retains a reference to the huge vector. Forcing it
--   creates a copy of just the elements that belong to the slice and
--   allows the huge vector to be garbage collected.
force :: forall a (n :: Nat). Unbox a => Vector n a -> Vector n a

-- | <i>O(m+n)</i> For each pair <tt>(i,a)</tt> from the list, replace the
--   vector element at position <tt>i</tt> by <tt>a</tt>.
--   
--   <pre>
--   &lt;5,9,2,7&gt; // [(2,1),(0,3),(2,8)] = &lt;3,9,8,7&gt;
--   </pre>
(//) :: forall a (m :: Nat). Unbox a => Vector m a -> [(Finite m, a)] -> Vector m a

-- | <i>O(m+n)</i> For each pair <tt>(i,a)</tt> from the vector of
--   index/value pairs, replace the vector element at position <tt>i</tt>
--   by <tt>a</tt>.
--   
--   <pre>
--   update &lt;5,9,2,7&gt; &lt;(2,1),(0,3),(2,8)&gt; = &lt;3,9,8,7&gt;
--   </pre>
update :: forall a (m :: Nat) (n :: Nat). Unbox a => Vector m a -> Vector n (Int, a) -> Vector m a

-- | <i>O(m+n)</i> For each index <tt>i</tt> from the index vector and the
--   corresponding value <tt>a</tt> from the value vector, replace the
--   element of the initial vector at position <tt>i</tt> by <tt>a</tt>.
--   
--   <pre>
--   update_ &lt;5,9,2,7&gt;  &lt;2,0,2&gt; &lt;1,3,8&gt; = &lt;3,9,8,7&gt;
--   </pre>
--   
--   This function is useful for instances of <a>Vector</a> that cannot
--   store pairs. Otherwise, <a>update</a> is probably more convenient.
--   
--   <pre>
--   update_ xs is ys = <a>update</a> xs (<a>zip</a> is ys)
--   </pre>
update_ :: forall a (m :: Nat) (n :: Nat). Unbox a => Vector m a -> Vector n Int -> Vector n a -> Vector m a

-- | Same as (<a>//</a>) but without bounds checking.
unsafeUpd :: forall a (m :: Nat). Unbox a => Vector m a -> [(Int, a)] -> Vector m a

-- | Same as <a>update</a> but without bounds checking.
unsafeUpdate :: forall a (m :: Nat) (n :: Nat). Unbox a => Vector m a -> Vector n (Int, a) -> Vector m a

-- | Same as <a>update_</a> but without bounds checking.
unsafeUpdate_ :: forall a (m :: Nat) (n :: Nat). Unbox a => Vector m a -> Vector n Int -> Vector n a -> Vector m a

-- | <i>O(m+n)</i> For each pair <tt>(i,b)</tt> from the list, replace the
--   vector element <tt>a</tt> at position <tt>i</tt> by <tt>f a b</tt>.
--   
--   <pre>
--   accum (+) &lt;5,9,2&gt; [(2,4),(1,6),(0,3),(1,7)] = &lt;5+3, 9+6+7, 2+4&gt;
--   </pre>
accum :: forall a b (m :: Nat). Unbox a => (a -> b -> a) -> Vector m a -> [(Finite m, b)] -> Vector m a

-- | <i>O(m+n)</i> For each pair <tt>(i,b)</tt> from the vector of pairs,
--   replace the vector element <tt>a</tt> at position <tt>i</tt> by <tt>f
--   a b</tt>.
--   
--   <pre>
--   accumulate (+) &lt;5,9,2&gt; &lt;(2,4),(1,6),(0,3),(1,7)&gt; = &lt;5+3, 9+6+7, 2+4&gt;
--   </pre>
accumulate :: forall a b (m :: Nat) (n :: Nat). (Unbox a, Unbox b) => (a -> b -> a) -> Vector m a -> Vector n (Int, b) -> Vector m a

-- | <i>O(m+n)</i> For each index <tt>i</tt> from the index vector and the
--   corresponding value <tt>b</tt> from the the value vector, replace the
--   element of the initial vector at position <tt>i</tt> by <tt>f a
--   b</tt>.
--   
--   <pre>
--   accumulate_ (+) &lt;5,9,2&gt; &lt;2,1,0,1&gt; &lt;4,6,3,7&gt; = &lt;5+3, 9+6+7, 2+4&gt;
--   </pre>
--   
--   This function is useful for instances of <a>Vector</a> that cannot
--   store pairs. Otherwise, <a>accumulate</a> is probably more convenient:
--   
--   <pre>
--   accumulate_ f as is bs = <a>accumulate</a> f as (<a>zip</a> is bs)
--   </pre>
accumulate_ :: forall a b (m :: Nat) (n :: Nat). (Unbox a, Unbox b) => (a -> b -> a) -> Vector m a -> Vector n Int -> Vector n b -> Vector m a

-- | Same as <a>accum</a> but without bounds checking.
unsafeAccum :: forall a b (m :: Nat). Unbox a => (a -> b -> a) -> Vector m a -> [(Int, b)] -> Vector m a

-- | Same as <a>accumulate</a> but without bounds checking.
unsafeAccumulate :: forall a b (m :: Nat) (n :: Nat). (Unbox a, Unbox b) => (a -> b -> a) -> Vector m a -> Vector n (Int, b) -> Vector m a

-- | Same as <a>accumulate_</a> but without bounds checking.
unsafeAccumulate_ :: forall a b (m :: Nat) (n :: Nat). (Unbox a, Unbox b) => (a -> b -> a) -> Vector m a -> Vector n Int -> Vector n b -> Vector m a

-- | <i>O(n)</i> Reverse a vector.
reverse :: forall a (n :: Nat). Unbox a => Vector n a -> Vector n a

-- | <i>O(n)</i> Yield the vector obtained by replacing each element
--   <tt>i</tt> of the index vector by <tt>xs<tt>!</tt>i</tt>. This is
--   equivalent to <tt><a>map</a> (xs<tt>!</tt>) is</tt> but is often much
--   more efficient.
--   
--   <pre>
--   backpermute &lt;a,b,c,d&gt; &lt;0,3,2,3,1,0&gt; = &lt;a,d,c,d,b,a&gt;
--   </pre>
backpermute :: forall a (m :: Nat) (n :: Nat). Unbox a => Vector m a -> Vector n Int -> Vector n a

-- | Same as <a>backpermute</a> but without bounds checking.
unsafeBackpermute :: forall a (m :: Nat) (n :: Nat). Unbox a => Vector m a -> Vector n Int -> Vector n a

-- | Lens to access (<i>O(1)</i>) and update (<i>O(n)</i>) an arbitrary
--   element by its index.
ix :: forall (n :: Nat) a f. (Unbox a, Functor f) => Finite n -> (a -> f a) -> Vector n a -> f (Vector n a)

-- | Type-safe lens to access (<i>O(1)</i>) and update (<i>O(n)</i>) an
--   arbitrary element by its index which should be supplied via
--   TypeApplications.
ix' :: forall (i :: Nat) (n :: Nat) a f. (Unbox a, Functor f, KnownNat i, KnownNat n, (i + 1) <= n) => (a -> f a) -> Vector n a -> f (Vector n a)

-- | Lens to access (<i>O(1)</i>) and update (<i>O(n)</i>) the first
--   element of a non-empty vector.
_head :: forall (n :: Natural) a f. (Unbox a, Functor f) => (a -> f a) -> Vector (1 + n) a -> f (Vector (1 + n) a)

-- | Lens to access (<i>O(1)</i>) and update (<i>O(n)</i>) the last element
--   of a non-empty vector.
_last :: forall (n :: Natural) a f. (Unbox a, Functor f) => (a -> f a) -> Vector (n + 1) a -> f (Vector (n + 1) a)

-- | <i>O(n)</i> Pair each element in a vector with its index.
indexed :: forall a (n :: Nat). (Unbox a, Unbox (Finite n)) => Vector n a -> Vector n (Finite n, a)

-- | <i>O(n)</i> Map a function over a vector.
map :: forall a b (n :: Nat). (Unbox a, Unbox b) => (a -> b) -> Vector n a -> Vector n b

-- | <i>O(n)</i> Apply a function to every element of a vector and its
--   index.
imap :: forall a b (n :: Nat). (Unbox a, Unbox b) => (Finite n -> a -> b) -> Vector n a -> Vector n b

-- | <i>O(n*m)</i> Map a function over a vector and concatenate the
--   results. The function is required to always return the same length
--   vector.
concatMap :: forall a b (m :: Nat) (n :: Nat). (Unbox a, Unbox b) => (a -> Vector m b) -> Vector n a -> Vector (n * m) b

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector,
--   yielding a vector of results.
mapM :: forall m a b (n :: Nat). (Monad m, Unbox a, Unbox b) => (a -> m b) -> Vector n a -> m (Vector n b)

-- | <i>O(n)</i> Apply the monadic action to every element of a vector and
--   its index, yielding a vector of results.
imapM :: forall m a b (n :: Nat). (Monad m, Unbox a, Unbox b) => (Finite n -> a -> m b) -> Vector n a -> m (Vector n b)

-- | <i>O(n)</i> Apply the monadic action to all elements of a vector and
--   ignore the results.
mapM_ :: forall m a b (n :: Nat). (Monad m, Unbox a) => (a -> m b) -> Vector n a -> m ()

-- | <i>O(n)</i> Apply the monadic action to every element of a vector and
--   its index, ignoring the results.
imapM_ :: forall m a (n :: Nat) b. (Monad m, Unbox a) => (Finite n -> a -> m b) -> Vector n a -> m ()

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector,
--   yielding a vector of results. Equvalent to <tt>flip <a>mapM</a></tt>.
forM :: forall m a b (n :: Nat). (Monad m, Unbox a, Unbox b) => Vector n a -> (a -> m b) -> m (Vector n b)

-- | <i>O(n)</i> Apply the monadic action to all elements of a vector and
--   ignore the results. Equivalent to <tt>flip <a>mapM_</a></tt>.
forM_ :: forall m a (n :: Nat) b. (Monad m, Unbox a) => Vector n a -> (a -> m b) -> m ()

-- | <i>O(n)</i> Zip two vectors of the same length with the given
--   function.
zipWith :: forall a b c (n :: Nat). (Unbox a, Unbox b, Unbox c) => (a -> b -> c) -> Vector n a -> Vector n b -> Vector n c

-- | Zip three vectors with the given function.
zipWith3 :: forall a b c d (n :: Nat). (Unbox a, Unbox b, Unbox c, Unbox d) => (a -> b -> c -> d) -> Vector n a -> Vector n b -> Vector n c -> Vector n d
zipWith4 :: forall a b c d e (n :: Nat). (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e) => (a -> b -> c -> d -> e) -> Vector n a -> Vector n b -> Vector n c -> Vector n d -> Vector n e
zipWith5 :: forall a b c d e f (n :: Nat). (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f) => (a -> b -> c -> d -> e -> f) -> Vector n a -> Vector n b -> Vector n c -> Vector n d -> Vector n e -> Vector n f
zipWith6 :: forall a b c d e f g (n :: Nat). (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f, Unbox g) => (a -> b -> c -> d -> e -> f -> g) -> Vector n a -> Vector n b -> Vector n c -> Vector n d -> Vector n e -> Vector n f -> Vector n g

-- | <i>O(n)</i> Zip two vectors of the same length with a function that
--   also takes the elements' indices).
izipWith :: forall a b c (n :: Nat). (Unbox a, Unbox b, Unbox c) => (Finite n -> a -> b -> c) -> Vector n a -> Vector n b -> Vector n c
izipWith3 :: forall a b c d (n :: Nat). (Unbox a, Unbox b, Unbox c, Unbox d) => (Finite n -> a -> b -> c -> d) -> Vector n a -> Vector n b -> Vector n c -> Vector n d
izipWith4 :: forall a b c d e (n :: Nat). (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e) => (Finite n -> a -> b -> c -> d -> e) -> Vector n a -> Vector n b -> Vector n c -> Vector n d -> Vector n e
izipWith5 :: forall a b c d e f (n :: Nat). (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f) => (Finite n -> a -> b -> c -> d -> e -> f) -> Vector n a -> Vector n b -> Vector n c -> Vector n d -> Vector n e -> Vector n f
izipWith6 :: forall a b c d e f g (n :: Nat). (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f, Unbox g) => (Finite n -> a -> b -> c -> d -> e -> f -> g) -> Vector n a -> Vector n b -> Vector n c -> Vector n d -> Vector n e -> Vector n f -> Vector n g

-- | <i>O(n)</i> Zip two vectors of the same length.
zip :: forall a b (n :: Nat). (Unbox a, Unbox b) => Vector n a -> Vector n b -> Vector n (a, b)
zip3 :: forall a b c (n :: Nat). (Unbox a, Unbox b, Unbox c) => Vector n a -> Vector n b -> Vector n c -> Vector n (a, b, c)
zip4 :: forall a b c d (n :: Nat). (Unbox a, Unbox b, Unbox c, Unbox d) => Vector n a -> Vector n b -> Vector n c -> Vector n d -> Vector n (a, b, c, d)
zip5 :: forall a b c d e (n :: Nat). (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e) => Vector n a -> Vector n b -> Vector n c -> Vector n d -> Vector n e -> Vector n (a, b, c, d, e)
zip6 :: forall a b c d e f (n :: Nat). (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f) => Vector n a -> Vector n b -> Vector n c -> Vector n d -> Vector n e -> Vector n f -> Vector n (a, b, c, d, e, f)

-- | <i>O(n)</i> Zip the two vectors of the same length with the monadic
--   action and yield a vector of results.
zipWithM :: forall m a b c (n :: Nat). (Monad m, Unbox a, Unbox b, Unbox c) => (a -> b -> m c) -> Vector n a -> Vector n b -> m (Vector n c)

-- | <i>O(n)</i> Zip the two vectors with a monadic action that also takes
--   the element index and yield a vector of results.
izipWithM :: forall m a b c (n :: Nat). (Monad m, Unbox a, Unbox b, Unbox c) => (Finite n -> a -> b -> m c) -> Vector n a -> Vector n b -> m (Vector n c)

-- | <i>O(n)</i> Zip the two vectors with the monadic action and ignore the
--   results.
zipWithM_ :: forall m a b c (n :: Nat). (Monad m, Unbox a, Unbox b) => (a -> b -> m c) -> Vector n a -> Vector n b -> m ()

-- | <i>O(n)</i> Zip the two vectors with a monadic action that also takes
--   the element index and ignore the results.
izipWithM_ :: forall m a b (n :: Nat) c. (Monad m, Unbox a, Unbox b) => (Finite n -> a -> b -> m c) -> Vector n a -> Vector n b -> m ()

-- | <i>O(min(m,n))</i> Unzip a vector of pairs.
unzip :: forall a b (n :: Nat). (Unbox a, Unbox b) => Vector n (a, b) -> (Vector n a, Vector n b)
unzip3 :: forall a b c (n :: Nat). (Unbox a, Unbox b, Unbox c) => Vector n (a, b, c) -> (Vector n a, Vector n b, Vector n c)
unzip4 :: forall a b c d (n :: Nat). (Unbox a, Unbox b, Unbox c, Unbox d) => Vector n (a, b, c, d) -> (Vector n a, Vector n b, Vector n c, Vector n d)
unzip5 :: forall a b c d e (n :: Nat). (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e) => Vector n (a, b, c, d, e) -> (Vector n a, Vector n b, Vector n c, Vector n d, Vector n e)
unzip6 :: forall a b c d e f (n :: Nat). (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f) => Vector n (a, b, c, d, e, f) -> (Vector n a, Vector n b, Vector n c, Vector n d, Vector n e, Vector n f)

-- | <i>O(n)</i> Check if the vector contains an element.
elem :: forall a (n :: Nat). (Unbox a, Eq a) => a -> Vector n a -> Bool
infix 4 `elem`

-- | <i>O(n)</i> Check if the vector does not contain an element (inverse
--   of <a>elem</a>).
notElem :: forall a (n :: Nat). (Unbox a, Eq a) => a -> Vector n a -> Bool
infix 4 `notElem`

-- | <i>O(n)</i> Yield <a>Just</a> the first element matching the predicate
--   or <a>Nothing</a> if no such element exists.
find :: forall a (n :: Nat). Unbox a => (a -> Bool) -> Vector n a -> Maybe a

-- | <i>O(n)</i> Yield <a>Just</a> the index of the first element matching
--   the predicate or <a>Nothing</a> if no such element exists.
findIndex :: forall a (n :: Nat). Unbox a => (a -> Bool) -> Vector n a -> Maybe (Finite n)

-- | <i>O(n)</i> Yield <a>Just</a> the index of the first occurence of the
--   given element or <a>Nothing</a> if the vector does not contain the
--   element. This is a specialised version of <a>findIndex</a>.
elemIndex :: forall a (n :: Nat). (Unbox a, Eq a) => a -> Vector n a -> Maybe (Finite n)

-- | <i>O(n)</i> Left fold.
foldl :: forall b a (n :: Nat). Unbox b => (a -> b -> a) -> a -> Vector n b -> a

-- | <i>O(n)</i> Left fold on non-empty vectors.
foldl1 :: forall a (n :: Natural). Unbox a => (a -> a -> a) -> Vector (1 + n) a -> a

-- | <i>O(n)</i> Left fold with strict accumulator.
foldl' :: forall b a (n :: Nat). Unbox b => (a -> b -> a) -> a -> Vector n b -> a

-- | <i>O(n)</i> Left fold on non-empty vectors with strict accumulator.
foldl1' :: forall a (n :: Natural). Unbox a => (a -> a -> a) -> Vector (1 + n) a -> a

-- | <i>O(n)</i> Right fold.
foldr :: forall a b (n :: Nat). Unbox a => (a -> b -> b) -> b -> Vector n a -> b

-- | <i>O(n)</i> Right fold on non-empty vectors.
foldr1 :: forall a (n :: Natural). Unbox a => (a -> a -> a) -> Vector (n + 1) a -> a

-- | <i>O(n)</i> Right fold with a strict accumulator.
foldr' :: forall a b (n :: Nat). Unbox a => (a -> b -> b) -> b -> Vector n a -> b

-- | <i>O(n)</i> Right fold on non-empty vectors with strict accumulator.
foldr1' :: forall a (n :: Natural). Unbox a => (a -> a -> a) -> Vector (n + 1) a -> a

-- | <i>O(n)</i> Left fold (function applied to each element and its
--   index).
ifoldl :: forall b a (n :: Nat). Unbox b => (a -> Finite n -> b -> a) -> a -> Vector n b -> a

-- | <i>O(n)</i> Left fold with strict accumulator (function applied to
--   each element and its index).
ifoldl' :: forall b a (n :: Nat). Unbox b => (a -> Finite n -> b -> a) -> a -> Vector n b -> a

-- | <i>O(n)</i> Right fold (function applied to each element and its
--   index).
ifoldr :: forall a (n :: Nat) b. Unbox a => (Finite n -> a -> b -> b) -> b -> Vector n a -> b

-- | <i>O(n)</i> Right fold with strict accumulator (function applied to
--   each element and its index).
ifoldr' :: forall a (n :: Nat) b. Unbox a => (Finite n -> a -> b -> b) -> b -> Vector n a -> b

-- | <i>O(n)</i> Check if all elements satisfy the predicate.
all :: forall a (n :: Nat). Unbox a => (a -> Bool) -> Vector n a -> Bool

-- | <i>O(n)</i> Check if any element satisfies the predicate.
any :: forall a (n :: Nat). Unbox a => (a -> Bool) -> Vector n a -> Bool

-- | <i>O(n)</i> Check if all elements are <a>True</a>.
and :: forall (n :: Nat). Vector n Bool -> Bool

-- | <i>O(n)</i> Check if any element is <a>True</a>.
or :: forall (n :: Nat). Vector n Bool -> Bool

-- | <i>O(n)</i> Compute the sum of the elements.
sum :: forall a (n :: Nat). (Unbox a, Num a) => Vector n a -> a

-- | <i>O(n)</i> Compute the product of the elements.
product :: forall a (n :: Nat). (Unbox a, Num a) => Vector n a -> a

-- | <i>O(n)</i> Yield the maximum element of the non-empty vector.
maximum :: forall a (n :: Natural). (Unbox a, Ord a) => Vector (n + 1) a -> a

-- | <i>O(n)</i> Yield the maximum element of the non-empty vector
--   according to the given comparison function.
maximumBy :: forall a (n :: Natural). Unbox a => (a -> a -> Ordering) -> Vector (n + 1) a -> a

-- | <i>O(n)</i> Yield the minimum element of the non-empty vector.
minimum :: forall a (n :: Natural). (Unbox a, Ord a) => Vector (n + 1) a -> a

-- | <i>O(n)</i> Yield the minimum element of the non-empty vector
--   according to the given comparison function.
minimumBy :: forall a (n :: Natural). Unbox a => (a -> a -> Ordering) -> Vector (n + 1) a -> a

-- | <i>O(n)</i> Yield the index of the maximum element of the non-empty
--   vector.
maxIndex :: forall a (n :: Natural). (Unbox a, Ord a) => Vector (n + 1) a -> Finite (n + 1)

-- | <i>O(n)</i> Yield the index of the maximum element of the non-empty
--   vector according to the given comparison function.
maxIndexBy :: forall a (n :: Natural). Unbox a => (a -> a -> Ordering) -> Vector (n + 1) a -> Finite (n + 1)

-- | <i>O(n)</i> Yield the index of the minimum element of the non-empty
--   vector.
minIndex :: forall a (n :: Natural). (Unbox a, Ord a) => Vector (n + 1) a -> Finite (n + 1)

-- | <i>O(n)</i> Yield the index of the minimum element of the non-empty
--   vector according to the given comparison function.
minIndexBy :: forall a (n :: Natural). Unbox a => (a -> a -> Ordering) -> Vector (n + 1) a -> Finite (n + 1)

-- | <i>O(n)</i> Monadic fold.
foldM :: forall m b a (n :: Nat). (Monad m, Unbox b) => (a -> b -> m a) -> a -> Vector n b -> m a

-- | <i>O(n)</i> Monadic fold (action applied to each element and its
--   index).
ifoldM :: forall m b a (n :: Nat). (Monad m, Unbox b) => (a -> Finite n -> b -> m a) -> a -> Vector n b -> m a

-- | <i>O(n)</i> Monadic fold over non-empty vectors.
fold1M :: forall m a (n :: Natural). (Monad m, Unbox a) => (a -> a -> m a) -> Vector (1 + n) a -> m a

-- | <i>O(n)</i> Monadic fold with strict accumulator.
foldM' :: forall m b a (n :: Nat). (Monad m, Unbox b) => (a -> b -> m a) -> a -> Vector n b -> m a

-- | <i>O(n)</i> Monadic fold with strict accumulator (action applied to
--   each element and its index).
ifoldM' :: forall m b a (n :: Nat). (Monad m, Unbox b) => (a -> Finite n -> b -> m a) -> a -> Vector n b -> m a

-- | <i>O(n)</i> Monadic fold over non-empty vectors with strict
--   accumulator.
fold1M' :: forall m a (n :: Natural). (Monad m, Unbox a) => (a -> a -> m a) -> Vector (n + 1) a -> m a

-- | <i>O(n)</i> Monadic fold that discards the result.
foldM_ :: forall m b a (n :: Nat). (Monad m, Unbox b) => (a -> b -> m a) -> a -> Vector n b -> m ()

-- | <i>O(n)</i> Monadic fold that discards the result (action applied to
--   each element and its index).
ifoldM_ :: forall m b a (n :: Nat). (Monad m, Unbox b) => (a -> Finite n -> b -> m a) -> a -> Vector n b -> m ()

-- | <i>O(n)</i> Monadic fold over non-empty vectors that discards the
--   result.
fold1M_ :: forall m a (n :: Natural). (Monad m, Unbox a) => (a -> a -> m a) -> Vector (n + 1) a -> m ()

-- | <i>O(n)</i> Monadic fold with strict accumulator that discards the
--   result.
foldM'_ :: forall m b a (n :: Nat). (Monad m, Unbox b) => (a -> b -> m a) -> a -> Vector n b -> m ()

-- | <i>O(n)</i> Monadic fold with strict accumulator that discards the
--   result (action applied to each element and its index).
ifoldM'_ :: forall m b a (n :: Nat). (Monad m, Unbox b) => (a -> Finite n -> b -> m a) -> a -> Vector n b -> m ()

-- | <i>O(n)</i> Monad fold over non-empty vectors with strict accumulator
--   that discards the result.
fold1M'_ :: forall m a (n :: Natural). (Monad m, Unbox a) => (a -> a -> m a) -> Vector (n + 1) a -> m ()

-- | Evaluate each action and collect the results.
sequence :: forall m a (n :: Nat). (Monad m, Unbox a, Unbox (m a)) => Vector n (m a) -> m (Vector n a)

-- | Evaluate each action and discard the results.
sequence_ :: forall m a (n :: Nat). (Monad m, Unbox (m a)) => Vector n (m a) -> m ()

-- | <i>O(n)</i> Prescan.
--   
--   <pre>
--   prescanl f z = <a>init</a> . <a>scanl</a> f z
--   </pre>
--   
--   Example: <tt>prescanl (+) 0 &lt;1,2,3,4&gt; = &lt;0,1,3,6&gt;</tt>
prescanl :: forall a b (n :: Nat). (Unbox a, Unbox b) => (a -> b -> a) -> a -> Vector n b -> Vector n a

-- | <i>O(n)</i> Prescan with strict accumulator.
prescanl' :: forall a b (n :: Nat). (Unbox a, Unbox b) => (a -> b -> a) -> a -> Vector n b -> Vector n a

-- | <i>O(n)</i> Scan.
postscanl :: forall a b (n :: Nat). (Unbox a, Unbox b) => (a -> b -> a) -> a -> Vector n b -> Vector n a

-- | <i>O(n)</i> Scan with strict accumulator.
postscanl' :: forall a b (n :: Nat). (Unbox a, Unbox b) => (a -> b -> a) -> a -> Vector n b -> Vector n a

-- | <i>O(n)</i> Haskell-style scan.
scanl :: forall a b (n :: Nat). (Unbox a, Unbox b) => (a -> b -> a) -> a -> Vector n b -> Vector (1 + n) a

-- | <i>O(n)</i> Haskell-style scan with strict accumulator.
scanl' :: forall a b (n :: Nat). (Unbox a, Unbox b) => (a -> b -> a) -> a -> Vector n b -> Vector (1 + n) a

-- | <i>O(n)</i> Scan over a non-empty vector.
scanl1 :: forall a (n :: Natural). Unbox a => (a -> a -> a) -> Vector (1 + n) a -> Vector (2 + n) a

-- | <i>O(n)</i> Scan over a non-empty vector with a strict accumulator.
scanl1' :: forall a (n :: Natural). Unbox a => (a -> a -> a) -> Vector (1 + n) a -> Vector (2 + n) a

-- | <i>O(n)</i> Right-to-left prescan.
prescanr :: forall a b (n :: Nat). (Unbox a, Unbox b) => (a -> b -> b) -> b -> Vector n a -> Vector n b

-- | <i>O(n)</i> Right-to-left prescan with strict accumulator.
prescanr' :: forall a b (n :: Nat). (Unbox a, Unbox b) => (a -> b -> b) -> b -> Vector n a -> Vector n b

-- | <i>O(n)</i> Right-to-left scan.
postscanr :: forall a b (n :: Nat). (Unbox a, Unbox b) => (a -> b -> b) -> b -> Vector n a -> Vector n b

-- | <i>O(n)</i> Right-to-left scan with strict accumulator.
postscanr' :: forall a b (n :: Nat). (Unbox a, Unbox b) => (a -> b -> b) -> b -> Vector n a -> Vector n b

-- | <i>O(n)</i> Right-to-left Haskell-style scan.
scanr :: forall a b (n :: Nat). (Unbox a, Unbox b) => (a -> b -> b) -> b -> Vector n a -> Vector (n + 1) b

-- | <i>O(n)</i> Right-to-left Haskell-style scan with strict accumulator.
scanr' :: forall a b (n :: Nat). (Unbox a, Unbox b) => (a -> b -> b) -> b -> Vector n a -> Vector (n + 1) b

-- | <i>O(n)</i> Right-to-left scan over a non-empty vector.
scanr1 :: forall a (n :: Natural). Unbox a => (a -> a -> a) -> Vector (n + 1) a -> Vector (n + 2) a

-- | <i>O(n)</i> Right-to-left scan over a non-empty vector with a strict
--   accumulator.
scanr1' :: forall a (n :: Natural). Unbox a => (a -> a -> a) -> Vector (n + 1) a -> Vector (n + 2) a

-- | <i>O(n)</i> Convert a vector to a list.
toList :: forall a (n :: Nat). Unbox a => Vector n a -> [a]

-- | <i>O(n)</i> Convert a list to a vector.
fromList :: forall a (n :: Nat). (Unbox a, KnownNat n) => [a] -> Maybe (Vector n a)

-- | <i>O(n)</i> Convert the first <tt>n</tt> elements of a list to a
--   vector. The length of the resulting vector is inferred from the type.
fromListN :: forall (n :: Nat) a. (Unbox a, KnownNat n) => [a] -> Maybe (Vector n a)

-- | <i>O(n)</i> Convert the first <tt>n</tt> elements of a list to a
--   vector. The length of the resulting vector is given explicitly as a
--   <a>Proxy</a> argument.
fromListN' :: forall (n :: Nat) a p. (Unbox a, KnownNat n) => p n -> [a] -> Maybe (Vector n a)

-- | <i>O(n)</i> Takes a list and returns a continuation providing a vector
--   with a size parameter corresponding to the length of the list.
--   
--   Essentially converts a list into a vector with the proper size
--   parameter, determined at runtime.
--   
--   See <a>withSized</a>
withSizedList :: Unbox a => [a] -> (forall (n :: Nat). KnownNat n => Vector n a -> r) -> r

-- | <i>O(n)</i> Yield an immutable copy of the mutable vector.
freeze :: forall m a (n :: Nat). (PrimMonad m, Unbox a) => MVector n (PrimState m) a -> m (Vector n a)

-- | <i>O(n)</i> Yield a mutable copy of the immutable vector.
thaw :: forall m a (n :: Nat). (PrimMonad m, Unbox a) => Vector n a -> m (MVector n (PrimState m) a)

-- | <i>O(n)</i> Copy an immutable vector into a mutable one.
copy :: forall m a (n :: Nat). (PrimMonad m, Unbox a) => MVector n (PrimState m) a -> Vector n a -> m ()

-- | <i>O(1)</i> Unsafely convert a mutable vector to an immutable one
--   withouy copying. The mutable vector may not be used after this
--   operation.
unsafeFreeze :: forall m a (n :: Nat). (PrimMonad m, Unbox a) => MVector n (PrimState m) a -> m (Vector n a)

-- | <i>O(n)</i> Unsafely convert an immutable vector to a mutable one
--   without copying. The immutable vector may not be used after this
--   operation.
unsafeThaw :: forall m a (n :: Nat). (PrimMonad m, Unbox a) => Vector n a -> m (MVector n (PrimState m) a)

-- | Convert a <a>Vector</a> into a <a>Vector</a> if it has the correct
--   size, otherwise return <a>Nothing</a>.
toSized :: forall (n :: Nat) a. (Unbox a, KnownNat n) => Vector a -> Maybe (Vector n a)

-- | Takes a <a>Vector</a> and returns a continuation providing a
--   <a>Vector</a> with a size parameter <tt>n</tt> that is determined at
--   runtime based on the length of the input vector.
--   
--   Essentially converts a <a>Vector</a> into a <a>Vector</a> with the
--   correct size parameter <tt>n</tt>.
withSized :: Unbox a => Vector a -> (forall (n :: Nat). KnownNat n => Vector n a -> r) -> r
fromSized :: forall (n :: Nat) a. Vector n a -> Vector a

-- | Apply a function on unsized vectors to a sized vector. The function
--   must preserve the size of the vector, this is not checked.
withVectorUnsafe :: forall a b (n :: Nat). (Vector a -> Vector b) -> Vector n a -> Vector n b

-- | Apply a function on two unsized vectors to sized vectors. The function
--   must preserve the size of the vectors, this is not checked.
zipVectorsUnsafe :: forall a b c (n :: Nat). (Vector a -> Vector b -> Vector c) -> Vector n a -> Vector n b -> Vector n c
class (Vector Vector a, MVector MVector a) => Unbox a
