-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A simple DSL for probabilistic programming with conjugate models.
@package conjugate-programs
@version 0.1.0.0

module Inference.Conjugate

-- | Describes a family of distributions with a fixed form. For example, a
--   <a>Bernoulli</a> distribution is parameterized by a probability
--   <tt>p</tt> and produces binary samples (<tt>True</tt> with probability
--   <tt>p</tt>, <tt>False</tt> with probability <tt>1-p</tt>).
--   
--   Its <a>Distribution</a> instance is: &gt; instance Distribution
--   Bernoulli where &gt; type Params Bernoulli = Double &gt; type Support
--   Bernoulli = Bool &gt; distSample _ = uncurry bernoulli &gt; distLogP _
--   p True = log p &gt; distLogP _ p False = log (1 - p)
class Distribution a where {
    type Params a;
    type Support a;
}
distSample :: forall (m :: Type -> Type). (Distribution a, PrimMonad m) => a -> Params a -> Prob m (Support a)
distLogP :: Distribution a => a -> Params a -> Support a -> Double

-- | A type-level marker for treating a distribution as a prior.
newtype AsPrior p
AsPrior :: p -> AsPrior p

-- | Marks two distributions as a conjugate pair of prior and likelihood.
--   The property of such a pair is that the posterior has the same form as
--   the prior (including the same <a>Params</a> and <a>Support</a>), and
--   that its parameters can be obtained analytically from the parameters
--   of the prior and a set of observations.
--   
--   The class method <a>updatePrior</a> returns the parameters of the
--   posterior given the prior parameters after a single observation.
class (Distribution p, Distribution l, Support p ~ Params l) => Conjugate p l
priorSingleton :: Conjugate p l => p
updatePrior :: Conjugate p l => l -> Params p -> Support l -> Params p
predLogP :: Conjugate p l => l -> Params p -> Support l -> Double
type family Hyper (a :: k)
type family Probs (a :: k)
newtype HyperRep p
HyperRep :: Hyper (AsPrior p) -> HyperRep p
[runHyper] :: HyperRep p -> Hyper (AsPrior p)
newtype ProbsRep p
ProbsRep :: Probs (AsPrior p) -> ProbsRep p
[runProbs] :: ProbsRep p -> Probs (AsPrior p)
class Jeffreys (a :: k)
jeffreysPrior :: Jeffreys a => Hyper a
class GJeffreys (t :: k -> Type)
gjeffreysPrior :: forall (p :: k). GJeffreys t => t p
class Uniform (a :: k)
uniformPrior :: Uniform a => Hyper a
class GUniform (t :: k -> Type)
guniformPrior :: forall (p :: k). GUniform t => t p
class Prior (a :: k)
sampleProbs :: forall (m :: Type -> Type). (Prior a, PrimMonad m) => Hyper a -> Prob m (Probs a)
expectedProbs :: Prior a => Hyper a -> Probs a
class GPrior (i :: k -> Type) (o :: k -> Type)
gsampleProbs :: forall (m :: Type -> Type) (p :: k). (GPrior i o, PrimMonad m) => i p -> Prob m (o p)
gexpectedProbs :: forall (p :: k). GPrior i o => i p -> o p
type Accessor (r :: k -> Type -> Type) (p :: k) = forall (f :: k -> Type). () => Lens' r f f p
class Monad m => RandomInterpreter (m :: Type -> Type) (r :: Type -> Type -> Type) | m -> r where {
    type SampleCtx (m :: Type -> Type) a;
}
sampleValue :: (RandomInterpreter m r, Conjugate p l, SampleCtx m l) => String -> l -> Accessor r p -> m (Support l)
sampleConst :: (RandomInterpreter m r, Distribution d, SampleCtx m d) => String -> d -> Params d -> m (Support d)
permutationPlate :: (RandomInterpreter m r, Ord a) => Int -> (Int -> m a) -> m [a]
newtype Trace (r :: Type -> Type -> Type)
Trace :: Seq (String, Dynamic) -> Trace (r :: (Type -> Type) -> Type)
[runTrace] :: Trace (r :: (Type -> Type) -> Type) -> Seq (String, Dynamic)
observeValue :: forall p l (m :: Type -> Type) (r :: (Type -> Type) -> Type). (Conjugate p l, Typeable (Support l), Monad m) => String -> l -> Accessor r p -> Support l -> StateT (Trace r) m ()
observeConst :: forall d (m :: Type -> Type) (r :: (Type -> Type) -> Type). (Distribution d, Typeable (Support d), Monad m) => String -> d -> Params d -> Support d -> StateT (Trace r) m ()
takeTrace :: forall a (r :: (Type -> Type) -> Type). Typeable a => Trace r -> Maybe ((String, a), Trace r)
peekTrace :: forall (r :: (Type -> Type) -> Type). Trace r -> Maybe (String, Dynamic)
newtype SampleI (m :: Type -> Type) (r :: Type -> Type -> Type) a
SampleI :: ReaderT (r ProbsRep) (Prob m) a -> SampleI (m :: Type -> Type) (r :: (Type -> Type) -> Type) a
sampleResult :: p ProbsRep -> SampleI m p a -> Gen (PrimState m) -> m a
newtype TraceI (m :: Type -> Type) (r :: Type -> Type -> Type) a
TraceI :: ReaderT (r ProbsRep) (StateT (Trace r) (Prob m)) a -> TraceI (m :: Type -> Type) (r :: (Type -> Type) -> Type) a
sampleTrace :: r ProbsRep -> TraceI m r a -> Gen (PrimState m) -> m (a, Trace r)
newtype EvalTraceI (r :: Type -> Type -> Type) a
EvalTraceI :: ReaderT (r ProbsRep) (StateT (Trace r, Double) Maybe) a -> EvalTraceI (r :: (Type -> Type) -> Type) a
runTraceLogP :: r ProbsRep -> Trace r -> EvalTraceI r a -> Maybe (a, (Trace r, Double))
evalTraceLogP :: r ProbsRep -> Trace r -> EvalTraceI r a -> Maybe (a, Double)
newtype EvalPredTraceI (r :: Type -> Type -> Type) a
EvalPredTraceI :: ReaderT (r HyperRep) (StateT (Trace r, Double) Maybe) a -> EvalPredTraceI (r :: (Type -> Type) -> Type) a
runTracePredLogP :: r HyperRep -> Trace r -> EvalPredTraceI r a -> Maybe (a, (Trace r, Double))
evalTracePredLogP :: r HyperRep -> Trace r -> EvalPredTraceI r a -> Maybe (a, Double)
newtype UpdatePriorsI (r :: Type -> Type -> Type) a
UpdatePriorsI :: StateT (Trace r, r HyperRep) Maybe a -> UpdatePriorsI (r :: (Type -> Type) -> Type) a
getPosterior :: r HyperRep -> Trace r -> UpdatePriorsI r a -> Maybe (r HyperRep)
newtype ShowTraceI (r :: Type -> Type -> Type) a
ShowTraceI :: MaybeT (WriterT String (State (Trace r))) a -> ShowTraceI (r :: (Type -> Type) -> Type) a
showTraceItem :: forall l (r :: (Type -> Type) -> Type). (Show (Support l), Typeable l, Typeable (Support l)) => String -> ShowTraceI r (Support l)
showTrace :: forall (r :: (Type -> Type) -> Type) a. Trace r -> ShowTraceI r a -> (Maybe a, String)
printTrace :: forall (r :: (Type -> Type) -> Type) a. Trace r -> ShowTraceI r a -> IO ()
newtype TraceTraceI (r :: Type -> Type -> Type) a
TraceTraceI :: State (Trace r) a -> TraceTraceI (r :: (Type -> Type) -> Type) a
traceTraceItem :: forall l (r :: (Type -> Type) -> Type). (Show (Support l), Typeable l, Typeable (Support l)) => String -> TraceTraceI r (Support l)
traceTrace :: forall (r :: (Type -> Type) -> Type) a. Trace r -> TraceTraceI r a -> a
data Beta
Beta :: Beta
data Bernoulli
Bernoulli :: Bernoulli
newtype Binomial
Binomial :: Int -> Binomial
data Categorical (n :: Nat)
Categorical :: Categorical (n :: Nat)
data Dirichlet (n :: Nat)
Dirichlet :: Dirichlet (n :: Nat)
data Geometric0
Geometric0 :: Geometric0
data Geometric1
Geometric1 :: Geometric1
replicateMWithI :: Applicative m => Int -> (Int -> m a) -> m [a]
instance GHC.Internal.Base.Applicative (Inference.Conjugate.EvalPredTraceI r)
instance GHC.Internal.Base.Applicative (Inference.Conjugate.EvalTraceI r)
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Applicative (Inference.Conjugate.SampleI m r)
instance GHC.Internal.Base.Applicative (Inference.Conjugate.ShowTraceI r)
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Applicative (Inference.Conjugate.TraceI m r)
instance GHC.Internal.Base.Applicative (Inference.Conjugate.TraceTraceI r)
instance GHC.Internal.Base.Applicative (Inference.Conjugate.UpdatePriorsI r)
instance Inference.Conjugate.Conjugate Inference.Conjugate.Beta Inference.Conjugate.Bernoulli
instance Inference.Conjugate.Conjugate Inference.Conjugate.Beta Inference.Conjugate.Binomial
instance Inference.Conjugate.Conjugate Inference.Conjugate.Beta Inference.Conjugate.Geometric0
instance Inference.Conjugate.Conjugate Inference.Conjugate.Beta Inference.Conjugate.Geometric1
instance Inference.Conjugate.Conjugate (Inference.Conjugate.Dirichlet n) (Inference.Conjugate.Categorical n)
instance Inference.Conjugate.Distribution Inference.Conjugate.Bernoulli
instance Inference.Conjugate.Distribution Inference.Conjugate.Beta
instance Inference.Conjugate.Distribution Inference.Conjugate.Binomial
instance Inference.Conjugate.Distribution (Inference.Conjugate.Categorical n)
instance Inference.Conjugate.Distribution (Inference.Conjugate.Dirichlet n)
instance Inference.Conjugate.Distribution Inference.Conjugate.Geometric0
instance Inference.Conjugate.Distribution Inference.Conjugate.Geometric1
instance GHC.Classes.Eq Inference.Conjugate.Bernoulli
instance GHC.Classes.Eq Inference.Conjugate.Beta
instance GHC.Classes.Eq Inference.Conjugate.Binomial
instance GHC.Classes.Eq (Inference.Conjugate.Categorical n)
instance GHC.Classes.Eq (Inference.Conjugate.Dirichlet n)
instance GHC.Classes.Eq Inference.Conjugate.Geometric0
instance GHC.Classes.Eq Inference.Conjugate.Geometric1
instance GHC.Internal.Base.Functor (Inference.Conjugate.EvalPredTraceI r)
instance GHC.Internal.Base.Functor (Inference.Conjugate.EvalTraceI r)
instance GHC.Internal.Base.Functor m => GHC.Internal.Base.Functor (Inference.Conjugate.SampleI m r)
instance GHC.Internal.Base.Functor (Inference.Conjugate.ShowTraceI r)
instance GHC.Internal.Base.Functor m => GHC.Internal.Base.Functor (Inference.Conjugate.TraceI m r)
instance GHC.Internal.Base.Functor (Inference.Conjugate.TraceTraceI r)
instance GHC.Internal.Base.Functor (Inference.Conjugate.UpdatePriorsI r)
instance Inference.Conjugate.GJeffreys t => Inference.Conjugate.GJeffreys (GHC.Internal.Generics.M1 i c t)
instance forall k (ta :: k -> *) (tb :: k -> *). (Inference.Conjugate.GJeffreys ta, Inference.Conjugate.GJeffreys tb) => Inference.Conjugate.GJeffreys (ta GHC.Internal.Generics.:*: tb)
instance Inference.Conjugate.Jeffreys (Inference.Conjugate.AsPrior p) => Inference.Conjugate.GJeffreys (GHC.Internal.Generics.K1 i (Inference.Conjugate.HyperRep p))
instance (Inference.Conjugate.Jeffreys k2, k2 Inference.Conjugate.HyperRep GHC.Types.~ Inference.Conjugate.Hyper k2) => Inference.Conjugate.GJeffreys (GHC.Internal.Generics.K1 i (k2 Inference.Conjugate.HyperRep))
instance Inference.Conjugate.GJeffreys GHC.Internal.Generics.U1
instance Inference.Conjugate.GJeffreys GHC.Internal.Generics.V1
instance forall k (ia :: k -> *) (oa :: k -> *) (ib :: k -> *) (ob :: k -> *). (Inference.Conjugate.GPrior ia oa, Inference.Conjugate.GPrior ib ob) => Inference.Conjugate.GPrior (ia GHC.Internal.Generics.:*: ib) (oa GHC.Internal.Generics.:*: ob)
instance forall k (ia :: k -> *) (oa :: k -> *) (ib :: k -> *) (ob :: k -> *). (Inference.Conjugate.GPrior ia oa, Inference.Conjugate.GPrior ib ob) => Inference.Conjugate.GPrior (ia GHC.Internal.Generics.:+: ib) (oa GHC.Internal.Generics.:+: ob)
instance Inference.Conjugate.Prior (Inference.Conjugate.AsPrior p) => Inference.Conjugate.GPrior (GHC.Internal.Generics.K1 i (Inference.Conjugate.HyperRep p)) (GHC.Internal.Generics.K1 i (Inference.Conjugate.ProbsRep p))
instance (Inference.Conjugate.Prior k2, k2 Inference.Conjugate.HyperRep GHC.Types.~ Inference.Conjugate.Hyper k2, k2 Inference.Conjugate.ProbsRep GHC.Types.~ Inference.Conjugate.Probs k2) => Inference.Conjugate.GPrior (GHC.Internal.Generics.K1 i (k2 Inference.Conjugate.HyperRep)) (GHC.Internal.Generics.K1 i (k2 Inference.Conjugate.ProbsRep))
instance forall k (ti :: k -> *) (to :: k -> *) i (c :: GHC.Internal.Generics.Meta) i' (c' :: GHC.Internal.Generics.Meta). Inference.Conjugate.GPrior ti to => Inference.Conjugate.GPrior (GHC.Internal.Generics.M1 i c ti) (GHC.Internal.Generics.M1 i' c' to)
instance Inference.Conjugate.GPrior GHC.Internal.Generics.U1 GHC.Internal.Generics.U1
instance Inference.Conjugate.GPrior GHC.Internal.Generics.V1 GHC.Internal.Generics.V1
instance Inference.Conjugate.GUniform t => Inference.Conjugate.GUniform (GHC.Internal.Generics.M1 i c t)
instance forall k (ta :: k -> *) (tb :: k -> *). (Inference.Conjugate.GUniform ta, Inference.Conjugate.GUniform tb) => Inference.Conjugate.GUniform (ta GHC.Internal.Generics.:*: tb)
instance Inference.Conjugate.Uniform (Inference.Conjugate.AsPrior p) => Inference.Conjugate.GUniform (GHC.Internal.Generics.K1 i (Inference.Conjugate.HyperRep p))
instance (Inference.Conjugate.Uniform k2, k2 Inference.Conjugate.HyperRep GHC.Types.~ Inference.Conjugate.Hyper k2) => Inference.Conjugate.GUniform (GHC.Internal.Generics.K1 i (k2 Inference.Conjugate.HyperRep))
instance Inference.Conjugate.GUniform GHC.Internal.Generics.U1
instance Inference.Conjugate.GUniform GHC.Internal.Generics.V1
instance GHC.Internal.Generics.Generic Inference.Conjugate.Bernoulli
instance GHC.Internal.Generics.Generic Inference.Conjugate.Beta
instance GHC.Internal.Generics.Generic Inference.Conjugate.Binomial
instance GHC.Internal.Generics.Generic (Inference.Conjugate.Categorical n)
instance GHC.Internal.Generics.Generic (Inference.Conjugate.Dirichlet n)
instance GHC.Internal.Generics.Generic Inference.Conjugate.Geometric0
instance GHC.Internal.Generics.Generic Inference.Conjugate.Geometric1
instance (GHC.Internal.Generics.Generic (t Inference.Conjugate.HyperRep), Inference.Conjugate.GJeffreys (GHC.Internal.Generics.Rep (t Inference.Conjugate.HyperRep))) => Inference.Conjugate.Jeffreys t
instance GHC.Internal.TypeNats.KnownNat n => Inference.Conjugate.Jeffreys (Inference.Conjugate.AsPrior (Inference.Conjugate.Dirichlet n))
instance Inference.Conjugate.Jeffreys (Inference.Conjugate.AsPrior Inference.Conjugate.Beta)
instance GHC.Internal.Base.Monad (Inference.Conjugate.EvalPredTraceI r)
instance GHC.Internal.Base.Monad (Inference.Conjugate.EvalTraceI r)
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Monad (Inference.Conjugate.SampleI m r)
instance GHC.Internal.Base.Monad (Inference.Conjugate.ShowTraceI r)
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Monad (Inference.Conjugate.TraceI m r)
instance GHC.Internal.Base.Monad (Inference.Conjugate.TraceTraceI r)
instance GHC.Internal.Base.Monad (Inference.Conjugate.UpdatePriorsI r)
instance GHC.Classes.Ord Inference.Conjugate.Bernoulli
instance GHC.Classes.Ord Inference.Conjugate.Beta
instance GHC.Classes.Ord Inference.Conjugate.Binomial
instance GHC.Classes.Ord (Inference.Conjugate.Categorical n)
instance GHC.Classes.Ord (Inference.Conjugate.Dirichlet n)
instance GHC.Classes.Ord Inference.Conjugate.Geometric0
instance GHC.Classes.Ord Inference.Conjugate.Geometric1
instance (GHC.Internal.Generics.Generic (a Inference.Conjugate.HyperRep), GHC.Internal.Generics.Generic (a Inference.Conjugate.ProbsRep), Inference.Conjugate.GPrior (GHC.Internal.Generics.Rep (a Inference.Conjugate.HyperRep)) (GHC.Internal.Generics.Rep (a Inference.Conjugate.ProbsRep))) => Inference.Conjugate.Prior a
instance Inference.Conjugate.Prior (Inference.Conjugate.AsPrior (Inference.Conjugate.Dirichlet n))
instance Inference.Conjugate.Prior (Inference.Conjugate.AsPrior Inference.Conjugate.Beta)
instance Inference.Conjugate.RandomInterpreter (Inference.Conjugate.EvalPredTraceI r) r
instance Inference.Conjugate.RandomInterpreter (Inference.Conjugate.EvalTraceI r) r
instance Control.Monad.Primitive.PrimMonad m => Inference.Conjugate.RandomInterpreter (Inference.Conjugate.SampleI m r) r
instance Inference.Conjugate.RandomInterpreter (Inference.Conjugate.ShowTraceI r) r
instance Control.Monad.Primitive.PrimMonad m => Inference.Conjugate.RandomInterpreter (Inference.Conjugate.TraceI m r) r
instance Inference.Conjugate.RandomInterpreter (Inference.Conjugate.TraceTraceI r) r
instance Inference.Conjugate.RandomInterpreter (Inference.Conjugate.UpdatePriorsI r) r
instance GHC.Internal.Show.Show Inference.Conjugate.Bernoulli
instance GHC.Internal.Show.Show Inference.Conjugate.Beta
instance GHC.Internal.Show.Show Inference.Conjugate.Binomial
instance GHC.Internal.Show.Show (Inference.Conjugate.Categorical n)
instance GHC.Internal.Show.Show (Inference.Conjugate.Dirichlet n)
instance GHC.Internal.Show.Show Inference.Conjugate.Geometric0
instance GHC.Internal.Show.Show Inference.Conjugate.Geometric1
instance GHC.Internal.Show.Show (Inference.Conjugate.Hyper (Inference.Conjugate.AsPrior p)) => GHC.Internal.Show.Show (Inference.Conjugate.HyperRep p)
instance GHC.Internal.Show.Show (Inference.Conjugate.Probs (Inference.Conjugate.AsPrior p)) => GHC.Internal.Show.Show (Inference.Conjugate.ProbsRep p)
instance GHC.Internal.Show.Show (Inference.Conjugate.Trace r)
instance (GHC.Internal.Generics.Generic (t Inference.Conjugate.HyperRep), Inference.Conjugate.GUniform (GHC.Internal.Generics.Rep (t Inference.Conjugate.HyperRep))) => Inference.Conjugate.Uniform t
instance GHC.Internal.TypeNats.KnownNat n => Inference.Conjugate.Uniform (Inference.Conjugate.AsPrior (Inference.Conjugate.Dirichlet n))
instance Inference.Conjugate.Uniform (Inference.Conjugate.AsPrior Inference.Conjugate.Beta)
