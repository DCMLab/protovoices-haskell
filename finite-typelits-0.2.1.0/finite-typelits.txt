-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A type inhabited by finitely many values, indexed by type-level naturals
--   
--   A type inhabited by finitely many values, indexed by type-level
--   naturals.
@package finite-typelits
@version 0.2.1.0


module Data.Finite.Internal.Integral

-- | A class of datatypes that faithfully represent a sub-range of
--   <a>Integer</a> that includes <tt>0</tt>. A valid instance must obey
--   the following laws:
--   
--   <a>fromInteger</a> must be a retract of <a>toInteger</a>:
--   
--   <pre>
--   fromInteger (toInteger a) == a
--   </pre>
--   
--   Restricted to the range <tt>[0, <a>Limit</a>]</tt> (with
--   <a>Nothing</a> understood as positive infinity), <a>fromInteger</a>
--   must be an inverse of <a>toInteger</a>:
--   
--   <pre>
--   limited i ==&gt; toInteger (fromInteger i) == i
--   </pre>
--   
--   where:
--   
--   <pre>
--   limited i = case limit of
--       Just l -&gt; 0 &lt;= i &amp;&amp; i &lt;= l
--       Nothing -&gt; 0 &lt;= i
--   </pre>
--   
--   <b>WARNING</b>: violating the above constraint in particular breaks
--   type safety.
--   
--   The implementations of <a>Ord</a>, <a>Enum</a>, <a>Num</a>,
--   <a>Integral</a> must be compatible with that of <a>Integer</a>,
--   whenever all arguments and results fall within <tt>[0,
--   <a>Limit</a>]</tt>, for example:
--   
--   <pre>
--   limited i &amp;&amp; limited j &amp;&amp; limited k &amp;&amp; (i * j == k) ==&gt; (fromInteger i * fromInteger j == fromInteger k)
--   </pre>
--   
--   Methods <a>modAdd</a>, <a>modSub</a>, and <a>modMul</a> implement
--   modular addition, multiplication, and subtraction. The default
--   implementation is via <a>Integer</a>, but a faster implementation can
--   be provided instead. If provided, the implementation must be correct
--   for moduli in range <tt>[1, <a>Limit</a>]</tt>.
--   
--   <b>WARNING:</b> a naive implementaton is prone to arithmetic overflow
--   and may produce invalid results for moduli close to <a>Limit</a>.
class Integral a => SaneIntegral a where {
    type Limit a :: Maybe Nat;
}

-- | Given <tt>n &gt; 0</tt>, <tt>0 &lt;= a &lt; n</tt>, and <tt>0 &lt;= b
--   &lt; n</tt>, <tt><a>modAdd</a> n a b</tt> computes <tt>(a <a>+</a> b)
--   ` <a>mod</a> ` n</tt>.
modAdd :: SaneIntegral a => a -> a -> a -> a

-- | Given <tt>n &gt; 0</tt>, <tt>0 &lt;= a &lt; n</tt>, and <tt>0 &lt;= b
--   &lt; n</tt>, <tt><a>modSub</a> n a b</tt> computes <tt>(a <a>-</a> b)
--   ` <a>mod</a> ` n</tt>.
modSub :: SaneIntegral a => a -> a -> a -> a

-- | Given <tt>n &gt; 0</tt>, <tt>0 &lt;= a &lt; n</tt>, and <tt>0 &lt;= b
--   &lt; n</tt>, <tt><a>modMul</a> n a b</tt> computes <tt>(a <a>*</a> b)
--   ` <a>mod</a> ` n</tt>.
modMul :: SaneIntegral a => a -> a -> a -> a

-- | Unsafely obtain evidence that <tt>n &lt;= Limit a</tt>. When
--   <a>Limit</a> is <a>Nothing</a> there is no evidence to obtain, and
--   <tt>\_ _ k -&gt; k</tt> is a valid implementation. When <a>Limit</a>
--   is a <a>Just</a>, the default implementation should work.
unsafeWithLimited :: forall proxy1 proxy2 (n :: Nat) r. SaneIntegral a => proxy1 a -> proxy2 n -> (Limited a n => r) -> r
($dmunsafeWithLimited) :: forall (n :: Nat) r (lim :: Nat) proxy1 proxy2. (SaneIntegral a, Limit a ~ 'Just lim) => proxy1 a -> proxy2 n -> (Limited a n => r) -> r

-- | Ensures that the value of <tt>n</tt> is representable in type
--   <tt>a</tt> (which should be a <a>SaneIntegral</a>).
type Limited a (n :: Nat) = LeqMaybe n Limit a

-- | This class asserts that the value of <tt>n</tt> is known at runtime,
--   and that it is representable in type <tt>a</tt> (which should be a
--   <a>SaneIntegral</a>).
--   
--   At runtime it acts like an implicit parameter of type <tt>a</tt>, much
--   like <a>KnownNat</a> is an implicit parameter of type <a>Integer</a>.
class KnownIntegral a (n :: Nat)

-- | Reflect a type-level number into a term.
intVal :: forall (n :: Nat) a proxy. KnownIntegral a n => proxy n -> a

-- | Recover a <a>KnownNat</a> constraint from a <a>KnownIntegral</a>
--   constraint.
withIntegral :: forall a (n :: Nat) r proxy1 proxy2. (SaneIntegral a, KnownIntegral a n) => proxy1 a -> proxy2 n -> (KnownNat n => r) -> r

-- | Recover a <a>Limited</a> constraint from a <a>KnownIntegral</a>
--   constraint.
withLimited :: forall a (n :: Nat) r proxy1 proxy2. (SaneIntegral a, KnownIntegral a n) => proxy1 a -> proxy2 n -> (Limited a n => r) -> r

-- | Finite number type. The type <tt><a>Finite</a> a n</tt> is inhabited
--   by exactly <tt>n</tt> values from type <tt>a</tt>, in the range
--   <tt>[0, n)</tt> including <tt>0</tt> but excluding <tt>n</tt>.
--   <tt>a</tt> must be an instance of <a>SaneIntegral</a> to use this
--   type. Invariants:
--   
--   <pre>
--   getFinite x &lt; intVal x
--   </pre>
--   
--   <pre>
--   getFinite x &gt;= 0
--   </pre>
newtype Finite a (n :: Nat)
Finite :: a -> Finite a (n :: Nat)

-- | Convert an <tt>a</tt> into a <tt><a>Finite</a> a</tt>, throwing an
--   error if the input is out of bounds.
finite :: forall (n :: Nat) a. (SaneIntegral a, KnownIntegral a n) => a -> Finite a n

-- | Convert a <tt><a>Finite</a> a</tt> into the corresponding <tt>a</tt>.
getFinite :: forall (n :: Nat) a. Finite a n -> a
instance (Data.Finite.Internal.Integral.SaneIntegral a, Data.Finite.Internal.Integral.KnownIntegral a n) => GHC.Internal.Enum.Bounded (Data.Finite.Internal.Integral.Finite a n)
instance (Data.Finite.Internal.Integral.SaneIntegral a, Data.Finite.Internal.Integral.KnownIntegral a n) => GHC.Internal.Enum.Enum (Data.Finite.Internal.Integral.Finite a n)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Finite.Internal.Integral.Finite a n)
instance (Data.Finite.Internal.Integral.SaneIntegral a, Data.Finite.Internal.Integral.KnownIntegral a n) => GHC.Internal.Real.Integral (Data.Finite.Internal.Integral.Finite a n)
instance GHC.Internal.Ix.Ix a => GHC.Internal.Ix.Ix (Data.Finite.Internal.Integral.Finite a n)
instance (Data.Finite.Internal.Integral.SaneIntegral a, Data.Finite.Internal.Integral.Limited a n, GHC.Internal.TypeNats.KnownNat n) => Data.Finite.Internal.Integral.KnownIntegral a n
instance (n GHC.Internal.Data.Type.Ord.<= m) => Data.Finite.Internal.Integral.LeqMaybe n ('GHC.Internal.Maybe.Just m)
instance Data.Finite.Internal.Integral.LeqMaybe n 'GHC.Internal.Maybe.Nothing
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Finite.Internal.Integral.Finite a n)
instance (Data.Finite.Internal.Integral.SaneIntegral a, Data.Finite.Internal.Integral.KnownIntegral a n) => GHC.Internal.Num.Num (Data.Finite.Internal.Integral.Finite a n)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Finite.Internal.Integral.Finite a n)
instance (GHC.Internal.Read.Read a, Data.Finite.Internal.Integral.SaneIntegral a, Data.Finite.Internal.Integral.KnownIntegral a n) => GHC.Internal.Read.Read (Data.Finite.Internal.Integral.Finite a n)
instance (Data.Finite.Internal.Integral.SaneIntegral a, Data.Finite.Internal.Integral.KnownIntegral a n) => GHC.Internal.Real.Real (Data.Finite.Internal.Integral.Finite a n)
instance Data.Finite.Internal.Integral.SaneIntegral GHC.Types.Int
instance Data.Finite.Internal.Integral.SaneIntegral GHC.Internal.Int.Int16
instance Data.Finite.Internal.Integral.SaneIntegral GHC.Internal.Int.Int32
instance Data.Finite.Internal.Integral.SaneIntegral GHC.Internal.Int.Int64
instance Data.Finite.Internal.Integral.SaneIntegral GHC.Internal.Int.Int8
instance Data.Finite.Internal.Integral.SaneIntegral GHC.Num.Integer.Integer
instance Data.Finite.Internal.Integral.SaneIntegral GHC.Num.Natural.Natural
instance Data.Finite.Internal.Integral.SaneIntegral GHC.Types.Word
instance Data.Finite.Internal.Integral.SaneIntegral GHC.Internal.Word.Word16
instance Data.Finite.Internal.Integral.SaneIntegral GHC.Internal.Word.Word32
instance Data.Finite.Internal.Integral.SaneIntegral GHC.Internal.Word.Word64
instance Data.Finite.Internal.Integral.SaneIntegral GHC.Internal.Word.Word8
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Data.Finite.Internal.Integral.Finite a n)


module Data.Finite.Internal

-- | Finite number type. The type <tt><a>Finite</a> n</tt> is inhabited by
--   exactly <tt>n</tt> values in the range <tt>[0, n)</tt> including
--   <tt>0</tt> but excluding <tt>n</tt>. Invariants:
--   
--   <pre>
--   getFinite x &lt; natVal x
--   </pre>
--   
--   <pre>
--   getFinite x &gt;= 0
--   </pre>
type Finite = Finite Integer
pattern Finite :: Integer -> Finite n

-- | Convert an <a>Integer</a> into a <a>Finite</a>, throwing an error if
--   the input is out of bounds.
finite :: forall (n :: Nat). KnownNat n => Integer -> Finite n

-- | Convert a <a>Finite</a> into the corresponding <a>Integer</a>.
getFinite :: forall (n :: Nat). Finite n -> Integer


module Data.Finite.Integral

-- | A class of datatypes that faithfully represent a sub-range of
--   <a>Integer</a> that includes <tt>0</tt>. A valid instance must obey
--   the following laws:
--   
--   <a>fromInteger</a> must be a retract of <a>toInteger</a>:
--   
--   <pre>
--   fromInteger (toInteger a) == a
--   </pre>
--   
--   Restricted to the range <tt>[0, <a>Limit</a>]</tt> (with
--   <a>Nothing</a> understood as positive infinity), <a>fromInteger</a>
--   must be an inverse of <a>toInteger</a>:
--   
--   <pre>
--   limited i ==&gt; toInteger (fromInteger i) == i
--   </pre>
--   
--   where:
--   
--   <pre>
--   limited i = case limit of
--       Just l -&gt; 0 &lt;= i &amp;&amp; i &lt;= l
--       Nothing -&gt; 0 &lt;= i
--   </pre>
--   
--   <b>WARNING</b>: violating the above constraint in particular breaks
--   type safety.
--   
--   The implementations of <a>Ord</a>, <a>Enum</a>, <a>Num</a>,
--   <a>Integral</a> must be compatible with that of <a>Integer</a>,
--   whenever all arguments and results fall within <tt>[0,
--   <a>Limit</a>]</tt>, for example:
--   
--   <pre>
--   limited i &amp;&amp; limited j &amp;&amp; limited k &amp;&amp; (i * j == k) ==&gt; (fromInteger i * fromInteger j == fromInteger k)
--   </pre>
--   
--   Methods <a>modAdd</a>, <a>modSub</a>, and <a>modMul</a> implement
--   modular addition, multiplication, and subtraction. The default
--   implementation is via <a>Integer</a>, but a faster implementation can
--   be provided instead. If provided, the implementation must be correct
--   for moduli in range <tt>[1, <a>Limit</a>]</tt>.
--   
--   <b>WARNING:</b> a naive implementaton is prone to arithmetic overflow
--   and may produce invalid results for moduli close to <a>Limit</a>.
class Integral a => SaneIntegral a

-- | Ensures that the value of <tt>n</tt> is representable in type
--   <tt>a</tt> (which should be a <a>SaneIntegral</a>).
type Limited a (n :: Nat) = LeqMaybe n Limit a

-- | This class asserts that the value of <tt>n</tt> is known at runtime,
--   and that it is representable in type <tt>a</tt> (which should be a
--   <a>SaneIntegral</a>).
--   
--   At runtime it acts like an implicit parameter of type <tt>a</tt>, much
--   like <a>KnownNat</a> is an implicit parameter of type <a>Integer</a>.
class KnownIntegral a (n :: Nat)

-- | Reflect a type-level number into a term.
intVal :: forall (n :: Nat) a proxy. KnownIntegral a n => proxy n -> a

-- | Recover a <a>KnownNat</a> constraint from a <a>KnownIntegral</a>
--   constraint.
withIntegral :: forall a (n :: Nat) r proxy1 proxy2. (SaneIntegral a, KnownIntegral a n) => proxy1 a -> proxy2 n -> (KnownNat n => r) -> r

-- | Finite number type. The type <tt><a>Finite</a> a n</tt> is inhabited
--   by exactly <tt>n</tt> values from type <tt>a</tt>, in the range
--   <tt>[0, n)</tt> including <tt>0</tt> but excluding <tt>n</tt>.
--   <tt>a</tt> must be an instance of <a>SaneIntegral</a> to use this
--   type. Invariants:
--   
--   <pre>
--   getFinite x &lt; intVal x
--   </pre>
--   
--   <pre>
--   getFinite x &gt;= 0
--   </pre>
data Finite a (n :: Nat)

-- | Convert an <tt>a</tt> into a <tt><a>Finite</a> a</tt>, returning
--   <a>Nothing</a> if the input is out of bounds.
packFinite :: forall (n :: Nat) a. (SaneIntegral a, KnownIntegral a n) => a -> Maybe (Finite a n)

-- | Same as <a>packFinite</a> but with a proxy argument to avoid type
--   signatures.
packFiniteProxy :: forall (n :: Nat) a proxy. (SaneIntegral a, KnownIntegral a n) => proxy n -> a -> Maybe (Finite a n)

-- | Convert an <tt>a</tt> into a <tt><a>Finite</a> a</tt>, throwing an
--   error if the input is out of bounds.
finite :: forall (n :: Nat) a. (SaneIntegral a, KnownIntegral a n) => a -> Finite a n

-- | Same as <a>finite</a> but with a proxy argument to avoid type
--   signatures.
finiteProxy :: forall (n :: Nat) a proxy. (SaneIntegral a, KnownIntegral a n) => proxy n -> a -> Finite a n

-- | Convert a <tt><a>Finite</a> a</tt> into the corresponding <tt>a</tt>.
getFinite :: forall (n :: Nat) a. Finite a n -> a

-- | Generate an ascending list of length <tt>n</tt> of all elements of
--   <tt><a>Finite</a> a n</tt>.
finites :: forall (n :: Nat) a. (SaneIntegral a, KnownIntegral a n) => [Finite a n]

-- | Same as <a>finites</a> but with a proxy argument to avoid type
--   signatures.
finitesProxy :: forall (n :: Nat) a proxy. (SaneIntegral a, KnownIntegral a n) => proxy n -> [Finite a n]

-- | Produce the <a>Finite</a> that is congruent to the given integer
--   modulo <tt>n</tt>.
modulo :: forall (n :: Nat) a. (SaneIntegral a, KnownIntegral a n) => a -> Finite a n

-- | Same as <a>modulo</a> but with a proxy argument to avoid type
--   signatures.
moduloProxy :: forall (n :: Nat) a proxy. (SaneIntegral a, KnownIntegral a n) => proxy n -> a -> Finite a n

-- | Test two different types of finite numbers for equality.
equals :: forall (n :: Nat) (m :: Nat) a. Eq a => Finite a n -> Finite a m -> Bool
infix 4 `equals`

-- | Compare two different types of finite numbers.
cmp :: forall (n :: Nat) (m :: Nat) a. Ord a => Finite a n -> Finite a m -> Ordering

-- | Convert a type-level literal into a <a>Finite</a>.
natToFinite :: forall (n :: Nat) (m :: Nat) a proxy. (SaneIntegral a, KnownIntegral a n, Limited a m, (n + 1) <= m) => proxy n -> Finite a m

-- | Add one inhabitant in the end.
weaken :: forall (n :: Natural) a. Limited a (n + 1) => Finite a n -> Finite a (n + 1)

-- | Remove one inhabitant from the end. Returns <a>Nothing</a> if the
--   input was the removed inhabitant.
strengthen :: forall (n :: Nat) a. (SaneIntegral a, KnownIntegral a n) => Finite a (n + 1) -> Maybe (Finite a n)

-- | Add one inhabitant in the beginning, shifting everything up by one.
shift :: forall (n :: Natural) a. (SaneIntegral a, Limited a (n + 1)) => Finite a n -> Finite a (n + 1)

-- | Remove one inhabitant from the beginning, shifting everything down by
--   one. Returns <a>Nothing</a> if the input was the removed inhabitant.
unshift :: forall (n :: Natural) a. SaneIntegral a => Finite a (n + 1) -> Maybe (Finite a n)

-- | Add multiple inhabitants in the end.
weakenN :: forall (n :: Nat) (m :: Nat) a. (n <= m, Limited a m) => Finite a n -> Finite a m

-- | Remove multiple inhabitants from the end. Returns <a>Nothing</a> if
--   the input was one of the removed inhabitants.
strengthenN :: forall (n :: Nat) (m :: Nat) a. (SaneIntegral a, KnownIntegral a m, Limited a m) => Finite a n -> Maybe (Finite a m)

-- | Add multiple inhabitants in the beginning, shifting everything up by
--   the amount of inhabitants added.
shiftN :: forall (n :: Nat) (m :: Nat) a. (SaneIntegral a, KnownIntegral a n, KnownIntegral a m, n <= m) => Finite a n -> Finite a m

-- | Remove multiple inhabitants from the beginning, shifting everything
--   down by the amount of inhabitants removed. Returns <a>Nothing</a> if
--   the input was one of the removed inhabitants.
unshiftN :: forall (n :: Nat) (m :: Nat) a. (SaneIntegral a, KnownIntegral a n, KnownIntegral a m, Limited a m) => Finite a n -> Maybe (Finite a m)
weakenProxy :: forall (n :: Natural) (k :: Natural) a proxy. Limited a (n + k) => proxy k -> Finite a n -> Finite a (n + k)
strengthenProxy :: forall (n :: Nat) (k :: Natural) a proxy. (SaneIntegral a, KnownIntegral a n) => proxy k -> Finite a (n + k) -> Maybe (Finite a n)
shiftProxy :: forall (n :: Natural) (k :: Nat) a proxy. (SaneIntegral a, KnownIntegral a k, Limited a (n + k)) => proxy k -> Finite a n -> Finite a (n + k)
unshiftProxy :: forall (n :: Natural) (k :: Nat) a proxy. (SaneIntegral a, KnownIntegral a k) => proxy k -> Finite a (n + k) -> Maybe (Finite a n)

-- | Add two <a>Finite</a>s.
add :: forall (n :: Natural) (m :: Natural) a. (SaneIntegral a, Limited a (n + m)) => Finite a n -> Finite a m -> Finite a (n + m)

-- | Subtract two <a>Finite</a>s. Returns <a>Left</a> for negative results,
--   and <a>Right</a> for positive results. Note that this function never
--   returns <tt><a>Left</a> 0</tt>.
sub :: forall (n :: Nat) (m :: Nat) a. SaneIntegral a => Finite a n -> Finite a m -> Either (Finite a m) (Finite a n)

-- | Multiply two <a>Finite</a>s.
multiply :: forall (n :: Natural) (m :: Natural) a. (SaneIntegral a, Limited a (n * m)) => Finite a n -> Finite a m -> Finite a (n * m)

-- | <a>Left</a>-biased (left values come first) disjoint union of finite
--   sets.
combineSum :: forall (n :: Nat) (m :: Natural) a. (SaneIntegral a, KnownIntegral a n, Limited a (n + m)) => Either (Finite a n) (Finite a m) -> Finite a (n + m)

-- | Witness that <a>combineSum</a> preserves units: <tt>0</tt> is the unit
--   of <a>+</a>, and <a>Void</a> is the unit of <a>Either</a>.
combineZero :: Void -> Finite a 0

-- | <a>fst</a>-biased (fst is the inner, and snd is the outer iteratee)
--   product of finite sets.
combineProduct :: forall (n :: Nat) (m :: Natural) a. (SaneIntegral a, KnownIntegral a n, Limited a (n * m)) => (Finite a n, Finite a m) -> Finite a (n * m)

-- | Witness that <a>combineProduct</a> preserves units: <tt>1</tt> is the
--   unit of <a>*</a>, and <tt>()</tt> is the unit of <tt>(,)</tt>.
combineOne :: (SaneIntegral a, Limited a 1) => () -> Finite a 1

-- | Product of <tt>n</tt> copies of a finite set of size <tt>m</tt>,
--   biased towards the lower values of the argument (colex order).
combineExponential :: forall (n :: Nat) (m :: Nat) a. (SaneIntegral a, KnownIntegral a m, KnownIntegral a n, Limited a (m ^ n)) => (Finite a n -> Finite a m) -> Finite a (m ^ n)

-- | Take a <a>Left</a>-biased disjoint union apart.
separateSum :: forall (n :: Nat) (m :: Natural) a. (SaneIntegral a, KnownIntegral a n) => Finite a (n + m) -> Either (Finite a n) (Finite a m)

-- | Witness that <a>separateSum</a> preserves units: <tt>0</tt> is the
--   unit of <a>+</a>, and <a>Void</a> is the unit of <a>Either</a>.
--   
--   Also witness that a <tt><a>Finite</a> a 0</tt> is uninhabited.
separateZero :: SaneIntegral a => Finite a 0 -> Void

-- | Take a <a>fst</a>-biased product apart.
separateProduct :: forall (n :: Nat) (m :: Natural) a. (SaneIntegral a, KnownIntegral a n) => Finite a (n * m) -> (Finite a n, Finite a m)
separateOne :: Finite a 1 -> ()

-- | Take a product of <tt>n</tt> copies of a finite set of size <tt>m</tt>
--   apart, biased towards the lower values of the argument (colex order).
separateExponential :: forall (n :: Natural) (m :: Nat) a. (SaneIntegral a, KnownIntegral a m) => Finite a (m ^ n) -> Finite a n -> Finite a m

-- | Convert a <a>Finite</a> between different <a>SaneIntegral</a> numeric
--   types.
castFinite :: forall b a (n :: Nat). (SaneIntegral a, SaneIntegral b, Limited b n) => Finite a n -> Finite b n

-- | Verifies that a given <a>Finite</a> is valid. Should always return
--   <a>True</a> unless you bring the <tt>Data.Finite.Internal.Finite</tt>
--   constructor into the scope, or use <a>unsafeCoerce</a> or other nasty
--   hacks.
isValidFinite :: forall (n :: Nat) a. (Ord a, Num a, KnownIntegral a n) => Finite a n -> Bool


module Data.Finite

-- | Finite number type. The type <tt><a>Finite</a> n</tt> is inhabited by
--   exactly <tt>n</tt> values in the range <tt>[0, n)</tt> including
--   <tt>0</tt> but excluding <tt>n</tt>. Invariants:
--   
--   <pre>
--   getFinite x &lt; natVal x
--   </pre>
--   
--   <pre>
--   getFinite x &gt;= 0
--   </pre>
type Finite = Finite Integer

-- | Convert an <a>Integer</a> into a <a>Finite</a>, returning
--   <a>Nothing</a> if the input is out of bounds.
packFinite :: forall (n :: Nat). KnownNat n => Integer -> Maybe (Finite n)

-- | Same as <a>packFinite</a> but with a proxy argument to avoid type
--   signatures.
packFiniteProxy :: forall (n :: Nat) proxy. KnownNat n => proxy n -> Integer -> Maybe (Finite n)

-- | Convert an <a>Integer</a> into a <a>Finite</a>, throwing an error if
--   the input is out of bounds.
finite :: forall (n :: Nat). KnownNat n => Integer -> Finite n

-- | Same as <a>finite</a> but with a proxy argument to avoid type
--   signatures.
finiteProxy :: forall (n :: Nat) proxy. KnownNat n => proxy n -> Integer -> Finite n

-- | Convert a <a>Finite</a> into the corresponding <a>Integer</a>.
getFinite :: forall (n :: Nat). Finite n -> Integer

-- | Generate a list of length <tt>n</tt> of all elements of
--   <tt><a>Finite</a> n</tt>.
finites :: forall (n :: Nat). KnownNat n => [Finite n]

-- | Same as <a>finites</a> but with a proxy argument to avoid type
--   signatures.
finitesProxy :: forall (n :: Nat) proxy. KnownNat n => proxy n -> [Finite n]

-- | Produce the <a>Finite</a> that is congruent to the given integer
--   modulo <tt>n</tt>.
modulo :: forall (n :: Nat). KnownNat n => Integer -> Finite n

-- | Same as <a>modulo</a> but with a proxy argument to avoid type
--   signatures.
moduloProxy :: forall (n :: Nat) proxy. KnownNat n => proxy n -> Integer -> Finite n

-- | Test two different types of finite numbers for equality.
equals :: forall (n :: Nat) (m :: Nat). Finite n -> Finite m -> Bool
infix 4 `equals`

-- | Compare two different types of finite numbers.
cmp :: forall (n :: Nat) (m :: Nat). Finite n -> Finite m -> Ordering

-- | Convert a type-level literal into a <a>Finite</a>.
natToFinite :: forall (n :: Nat) (m :: Nat) proxy. (KnownNat n, KnownNat m, (n + 1) <= m) => proxy n -> Finite m

-- | Add one inhabitant in the end.
weaken :: forall (n :: Nat). Finite n -> Finite (n + 1)

-- | Remove one inhabitant from the end. Returns <a>Nothing</a> if the
--   input was the removed inhabitant.
strengthen :: forall (n :: Nat). KnownNat n => Finite (n + 1) -> Maybe (Finite n)

-- | Add one inhabitant in the beginning, shifting everything up by one.
shift :: forall (n :: Nat). Finite n -> Finite (n + 1)

-- | Remove one inhabitant from the beginning, shifting everything down by
--   one. Returns <a>Nothing</a> if the input was the removed inhabitant.
unshift :: forall (n :: Natural). Finite (n + 1) -> Maybe (Finite n)

-- | Add multiple inhabitants in the end.
weakenN :: forall (n :: Nat) (m :: Nat). n <= m => Finite n -> Finite m

-- | Remove multiple inhabitants from the end. Returns <a>Nothing</a> if
--   the input was one of the removed inhabitants.
strengthenN :: forall (n :: Nat) (m :: Nat). KnownNat m => Finite n -> Maybe (Finite m)

-- | Add multiple inhabitants in the beginning, shifting everything up by
--   the amount of inhabitants added.
shiftN :: forall (n :: Nat) (m :: Nat). (KnownNat n, KnownNat m, n <= m) => Finite n -> Finite m

-- | Remove multiple inhabitants from the beginning, shifting everything
--   down by the amount of inhabitants removed. Returns <a>Nothing</a> if
--   the input was one of the removed inhabitants.
unshiftN :: forall (n :: Nat) (m :: Nat). (KnownNat n, KnownNat m) => Finite n -> Maybe (Finite m)
weakenProxy :: forall (n :: Nat) (k :: Natural) proxy. proxy k -> Finite n -> Finite (n + k)
strengthenProxy :: forall (n :: Nat) (k :: Natural) proxy. KnownNat n => proxy k -> Finite (n + k) -> Maybe (Finite n)
shiftProxy :: forall (n :: Nat) (k :: Nat) proxy. KnownNat k => proxy k -> Finite n -> Finite (n + k)
unshiftProxy :: forall (n :: Natural) (k :: Nat) proxy. KnownNat k => proxy k -> Finite (n + k) -> Maybe (Finite n)

-- | Add two <a>Finite</a>s.
add :: forall (n :: Nat) (m :: Nat). Finite n -> Finite m -> Finite (n + m)

-- | Subtract two <a>Finite</a>s. Returns <a>Left</a> for negative results,
--   and <a>Right</a> for positive results. Note that this function never
--   returns <tt><a>Left</a> 0</tt>.
sub :: forall (n :: Nat) (m :: Nat). Finite n -> Finite m -> Either (Finite m) (Finite n)

-- | Multiply two <a>Finite</a>s.
multiply :: forall (n :: Nat) (m :: Nat). Finite n -> Finite m -> Finite (n * m)

-- | <a>Left</a>-biased (left values come first) disjoint union of finite
--   sets.
combineSum :: forall (n :: Nat) (m :: Nat). KnownNat n => Either (Finite n) (Finite m) -> Finite (n + m)

-- | Witness that <a>combineSum</a> preserves units: <tt>0</tt> is the unit
--   of <a>+</a>, and <a>Void</a> is the unit of <a>Either</a>.
combineZero :: Void -> Finite 0

-- | <a>fst</a>-biased (fst is the inner, and snd is the outer iteratee)
--   product of finite sets.
combineProduct :: forall (n :: Nat) (m :: Nat). KnownNat n => (Finite n, Finite m) -> Finite (n * m)

-- | Witness that <a>combineProduct</a> preserves units: <tt>1</tt> is the
--   unit of <a>*</a>, and <tt>()</tt> is the unit of <tt>(,)</tt>.
combineOne :: () -> Finite 1

-- | Product of <tt>n</tt> copies of a finite set of size <tt>m</tt>,
--   biased towards the lower values of the argument (colex order).
combineExponential :: forall (n :: Nat) (m :: Nat). (KnownNat m, KnownNat n) => (Finite n -> Finite m) -> Finite (m ^ n)

-- | Take a <a>Left</a>-biased disjoint union apart.
separateSum :: forall (n :: Nat) (m :: Natural). KnownNat n => Finite (n + m) -> Either (Finite n) (Finite m)

-- | Witness that <a>separateSum</a> preserves units: <tt>0</tt> is the
--   unit of <a>+</a>, and <a>Void</a> is the unit of <a>Either</a>.
--   
--   Also witness that a <tt><a>Finite</a> 0</tt> is uninhabited.
separateZero :: Finite 0 -> Void

-- | Take a <a>fst</a>-biased product apart.
separateProduct :: forall (n :: Nat) (m :: Natural). KnownNat n => Finite (n * m) -> (Finite n, Finite m)
separateOne :: Finite 1 -> ()

-- | Take a product of <tt>n</tt> copies of a finite set of size <tt>m</tt>
--   apart, biased towards the lower values of the argument (colex order).
separateExponential :: forall (n :: Natural) (m :: Nat). KnownNat m => Finite (m ^ n) -> Finite n -> Finite m

-- | Verifies that a given <a>Finite</a> is valid. Should always return
--   <a>True</a> unless you bring the <tt>Data.Finite.Internal.Finite</tt>
--   constructor into the scope, or use <a>unsafeCoerce</a> or other nasty
--   hacks.
isValidFinite :: forall (n :: Nat). KnownNat n => Finite n -> Bool
