-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Write Haskell source files including C code inline. No FFI required.
--   
--   See <a>https://github.com/fpco/inline-c/blob/master/README.md</a>.
@package inline-c
@version 0.9.1.10


-- | A parser for C99 declarations. Currently, the parser has the following
--   limitations:
--   
--   <ul>
--   <li>Array sizes can only be <tt>*</tt>, <tt>n</tt> (where n is a
--   positive integer), <tt>x</tt> (where <tt>x</tt> is a C identifier). In
--   C99 they can be arbitrary expressions. See the
--   <tt><a>ArrayType</a></tt> data type.</li>
--   <li><tt>_Bool</tt>, <tt>_Complex</tt>, and <tt>_Imaginary</tt> are not
--   present.</li>
--   <li>Untyped parameter lists (pre-K&amp;R C) are not allowed.</li>
--   </ul>
--   
--   The parser is incremental and generic (see <a>CParser</a>).
--   <a>Pretty</a> and <a>Arbitrary</a> instances are provided for all the
--   data types.
--   
--   The entry point if you want to parse C declarations is
--   <tt><a>parameter_declaration</a></tt>.
module Language.C.Types.Parse

-- | A collection of named types (typedefs)
type TypeNames = HashSet CIdentifier
data CParserContext i
CParserContext :: String -> TypeNames -> (forall (m :: Type -> Type). CParser i m => m i) -> (i -> String) -> Bool -> CParserContext i
[cpcIdentName] :: CParserContext i -> String

-- | Function used to determine whether an identifier is a type name.
[cpcTypeNames] :: CParserContext i -> TypeNames

-- | Parses an identifier, *without consuming whitespace afterwards*.
[cpcParseIdent] :: CParserContext i -> forall (m :: Type -> Type). CParser i m => m i
[cpcIdentToString] :: CParserContext i -> i -> String
[cpcEnableCpp] :: CParserContext i -> Bool

-- | A type for C identifiers.
data CIdentifier
unCIdentifier :: CIdentifier -> String
cIdentifierFromString :: Bool -> String -> Either String CIdentifier
cCParserContext :: Bool -> TypeNames -> CParserContext CIdentifier

-- | All the parsing is done using the type classes provided by the
--   <tt>parsers</tt> package. You can use the parsing routines with any of
--   the parsers that implement the classes, such as <tt>parsec</tt> or
--   <tt>trifecta</tt>.
--   
--   We parametrize the parsing by the type of the variable identifiers,
--   <tt>i</tt>. We do so because we use this parser to implement
--   anti-quoters referring to Haskell variables, and thus we need to parse
--   Haskell identifiers in certain positions.
type CParser i (m :: Type -> Type) = (Monad m, Functor m, Applicative m, MonadPlus m, Parsing m, CharParsing m, TokenParsing m, LookAheadParsing m, MonadReader CParserContext i m, MonadFail m, Hashable i)

-- | Runs a <tt><a>CParser</a></tt> using <tt>parsec</tt>.
runCParser :: Stream s Identity Char => CParserContext i -> String -> s -> ReaderT (CParserContext i) (Parsec s ()) a -> Either ParseError a

-- | Useful for quick testing. Uses <tt>"quickCParser"</tt> as source name,
--   and throws an <a>error</a> if parsing fails.
quickCParser :: CParserContext i -> String -> ReaderT (CParserContext i) (Parsec String ()) a -> a

-- | Like <a>quickCParser</a>, but uses <tt><a>cCParserContext</a>
--   (<a>const</a> <a>False</a>)</tt> as <a>CParserContext</a>.
quickCParser_ :: Bool -> String -> ReaderT (CParserContext CIdentifier) (Parsec String ()) a -> a
identifier_no_lex :: CParser i m => m i
data DeclarationSpecifier
StorageClassSpecifier :: StorageClassSpecifier -> DeclarationSpecifier
TypeSpecifier :: TypeSpecifier -> DeclarationSpecifier
TypeQualifier :: TypeQualifier -> DeclarationSpecifier
FunctionSpecifier :: FunctionSpecifier -> DeclarationSpecifier
declaration_specifiers :: CParser i m => m [DeclarationSpecifier]
data StorageClassSpecifier
TYPEDEF :: StorageClassSpecifier
EXTERN :: StorageClassSpecifier
STATIC :: StorageClassSpecifier
AUTO :: StorageClassSpecifier
REGISTER :: StorageClassSpecifier
storage_class_specifier :: CParser i m => m StorageClassSpecifier
data TypeSpecifier
VOID :: TypeSpecifier
BOOL :: TypeSpecifier
CHAR :: TypeSpecifier
SHORT :: TypeSpecifier
INT :: TypeSpecifier
LONG :: TypeSpecifier
FLOAT :: TypeSpecifier
DOUBLE :: TypeSpecifier
SIGNED :: TypeSpecifier
UNSIGNED :: TypeSpecifier
Struct :: CIdentifier -> TypeSpecifier
Enum :: CIdentifier -> TypeSpecifier
TypeName :: CIdentifier -> TypeSpecifier
Template :: CIdentifier -> [[TypeSpecifier]] -> TypeSpecifier
TemplateConst :: String -> TypeSpecifier
TemplatePointer :: TypeSpecifier -> TypeSpecifier
type_specifier :: CParser i m => m TypeSpecifier
data TypeQualifier
CONST :: TypeQualifier
RESTRICT :: TypeQualifier
VOLATILE :: TypeQualifier
type_qualifier :: CParser i m => m TypeQualifier
data FunctionSpecifier
INLINE :: FunctionSpecifier
function_specifier :: CParser i m => m FunctionSpecifier
data Declarator i
Declarator :: [Pointer] -> DirectDeclarator i -> Declarator i
[declaratorPointers] :: Declarator i -> [Pointer]
[declaratorDirect] :: Declarator i -> DirectDeclarator i
declarator :: CParser i m => m (Declarator i)
data DirectDeclarator i
DeclaratorRoot :: i -> DirectDeclarator i
ArrayOrProto :: DirectDeclarator i -> ArrayOrProto i -> DirectDeclarator i
DeclaratorParens :: Declarator i -> DirectDeclarator i
direct_declarator :: CParser i m => m (DirectDeclarator i)
data ArrayOrProto i
Array :: ArrayType i -> ArrayOrProto i
Proto :: [ParameterDeclaration i] -> ArrayOrProto i
array_or_proto :: CParser i m => m (ArrayOrProto i)
data ArrayType i
VariablySized :: ArrayType i
Unsized :: ArrayType i
SizedByInteger :: Integer -> ArrayType i
SizedByIdentifier :: i -> ArrayType i
array_type :: CParser i m => m (ArrayType i)
data Pointer
Pointer :: [TypeQualifier] -> Pointer
pointer :: CParser i m => m Pointer
data ParameterDeclaration i
ParameterDeclaration :: [DeclarationSpecifier] -> DeclaratorOrAbstractDeclarator i -> ParameterDeclaration i
[parameterDeclarationSpecifiers] :: ParameterDeclaration i -> [DeclarationSpecifier]
[parameterDeclarationDeclarator] :: ParameterDeclaration i -> DeclaratorOrAbstractDeclarator i
data DeclaratorOrAbstractDeclarator i
IsDeclarator :: Declarator i -> DeclaratorOrAbstractDeclarator i
IsAbstractDeclarator :: AbstractDeclarator i -> DeclaratorOrAbstractDeclarator i
parameter_declaration :: CParser i m => m (ParameterDeclaration i)
parameter_list :: CParser i m => m [ParameterDeclaration i]
data AbstractDeclarator i
AbstractDeclarator :: [Pointer] -> Maybe (DirectAbstractDeclarator i) -> AbstractDeclarator i
[abstractDeclaratorPointers] :: AbstractDeclarator i -> [Pointer]
[abstractDeclaratorDirect] :: AbstractDeclarator i -> Maybe (DirectAbstractDeclarator i)
abstract_declarator :: CParser i m => m (AbstractDeclarator i)
data DirectAbstractDeclarator i
ArrayOrProtoHere :: ArrayOrProto i -> DirectAbstractDeclarator i
ArrayOrProtoThere :: DirectAbstractDeclarator i -> ArrayOrProto i -> DirectAbstractDeclarator i
AbstractDeclaratorParens :: AbstractDeclarator i -> DirectAbstractDeclarator i
direct_abstract_declarator :: CParser i m => m (DirectAbstractDeclarator i)
cIdentStart :: [Char]
cIdentLetter :: [Char]
cReservedWords :: HashSet String
isTypeName :: Bool -> TypeNames -> String -> Bool
instance GHC.Classes.Eq i => GHC.Classes.Eq (Language.C.Types.Parse.AbstractDeclarator i)
instance GHC.Classes.Eq i => GHC.Classes.Eq (Language.C.Types.Parse.ArrayOrProto i)
instance GHC.Classes.Eq i => GHC.Classes.Eq (Language.C.Types.Parse.ArrayType i)
instance GHC.Classes.Eq Language.C.Types.Parse.CIdentifier
instance GHC.Classes.Eq Language.C.Types.Parse.DeclarationSpecifier
instance GHC.Classes.Eq i => GHC.Classes.Eq (Language.C.Types.Parse.Declarator i)
instance GHC.Classes.Eq i => GHC.Classes.Eq (Language.C.Types.Parse.DeclaratorOrAbstractDeclarator i)
instance GHC.Classes.Eq i => GHC.Classes.Eq (Language.C.Types.Parse.DirectAbstractDeclarator i)
instance GHC.Classes.Eq i => GHC.Classes.Eq (Language.C.Types.Parse.DirectDeclarator i)
instance GHC.Classes.Eq Language.C.Types.Parse.FunctionSpecifier
instance GHC.Classes.Eq i => GHC.Classes.Eq (Language.C.Types.Parse.ParameterDeclaration i)
instance GHC.Classes.Eq Language.C.Types.Parse.Pointer
instance GHC.Classes.Eq Language.C.Types.Parse.StorageClassSpecifier
instance GHC.Classes.Eq Language.C.Types.Parse.TypeQualifier
instance GHC.Classes.Eq Language.C.Types.Parse.TypeSpecifier
instance GHC.Internal.Data.Foldable.Foldable Language.C.Types.Parse.AbstractDeclarator
instance GHC.Internal.Data.Foldable.Foldable Language.C.Types.Parse.ArrayOrProto
instance GHC.Internal.Data.Foldable.Foldable Language.C.Types.Parse.ArrayType
instance GHC.Internal.Data.Foldable.Foldable Language.C.Types.Parse.Declarator
instance GHC.Internal.Data.Foldable.Foldable Language.C.Types.Parse.DeclaratorOrAbstractDeclarator
instance GHC.Internal.Data.Foldable.Foldable Language.C.Types.Parse.DirectAbstractDeclarator
instance GHC.Internal.Data.Foldable.Foldable Language.C.Types.Parse.DirectDeclarator
instance GHC.Internal.Data.Foldable.Foldable Language.C.Types.Parse.ParameterDeclaration
instance GHC.Internal.Base.Functor Language.C.Types.Parse.AbstractDeclarator
instance GHC.Internal.Base.Functor Language.C.Types.Parse.ArrayOrProto
instance GHC.Internal.Base.Functor Language.C.Types.Parse.ArrayType
instance GHC.Internal.Base.Functor Language.C.Types.Parse.Declarator
instance GHC.Internal.Base.Functor Language.C.Types.Parse.DeclaratorOrAbstractDeclarator
instance GHC.Internal.Base.Functor Language.C.Types.Parse.DirectAbstractDeclarator
instance GHC.Internal.Base.Functor Language.C.Types.Parse.DirectDeclarator
instance GHC.Internal.Base.Functor Language.C.Types.Parse.ParameterDeclaration
instance Data.Hashable.Class.Hashable Language.C.Types.Parse.CIdentifier
instance GHC.Internal.Data.String.IsString Language.C.Types.Parse.CIdentifier
instance GHC.Classes.Ord Language.C.Types.Parse.CIdentifier
instance Prettyprinter.Internal.Pretty i => Prettyprinter.Internal.Pretty (Language.C.Types.Parse.AbstractDeclarator i)
instance Prettyprinter.Internal.Pretty i => Prettyprinter.Internal.Pretty (Language.C.Types.Parse.ArrayOrProto i)
instance Prettyprinter.Internal.Pretty i => Prettyprinter.Internal.Pretty (Language.C.Types.Parse.ArrayType i)
instance Prettyprinter.Internal.Pretty Language.C.Types.Parse.CIdentifier
instance Prettyprinter.Internal.Pretty Language.C.Types.Parse.DeclarationSpecifier
instance Prettyprinter.Internal.Pretty i => Prettyprinter.Internal.Pretty (Language.C.Types.Parse.Declarator i)
instance Prettyprinter.Internal.Pretty i => Prettyprinter.Internal.Pretty (Language.C.Types.Parse.DirectAbstractDeclarator i)
instance Prettyprinter.Internal.Pretty i => Prettyprinter.Internal.Pretty (Language.C.Types.Parse.DirectDeclarator i)
instance Prettyprinter.Internal.Pretty Language.C.Types.Parse.FunctionSpecifier
instance Prettyprinter.Internal.Pretty i => Prettyprinter.Internal.Pretty (Language.C.Types.Parse.ParameterDeclaration i)
instance Prettyprinter.Internal.Pretty Language.C.Types.Parse.Pointer
instance Prettyprinter.Internal.Pretty Language.C.Types.Parse.StorageClassSpecifier
instance Prettyprinter.Internal.Pretty Language.C.Types.Parse.TypeQualifier
instance Prettyprinter.Internal.Pretty Language.C.Types.Parse.TypeSpecifier
instance GHC.Internal.Show.Show i => GHC.Internal.Show.Show (Language.C.Types.Parse.AbstractDeclarator i)
instance GHC.Internal.Show.Show i => GHC.Internal.Show.Show (Language.C.Types.Parse.ArrayOrProto i)
instance GHC.Internal.Show.Show i => GHC.Internal.Show.Show (Language.C.Types.Parse.ArrayType i)
instance GHC.Internal.Show.Show Language.C.Types.Parse.CIdentifier
instance GHC.Internal.Show.Show Language.C.Types.Parse.DeclarationSpecifier
instance GHC.Internal.Show.Show i => GHC.Internal.Show.Show (Language.C.Types.Parse.Declarator i)
instance GHC.Internal.Show.Show i => GHC.Internal.Show.Show (Language.C.Types.Parse.DeclaratorOrAbstractDeclarator i)
instance GHC.Internal.Show.Show i => GHC.Internal.Show.Show (Language.C.Types.Parse.DirectAbstractDeclarator i)
instance GHC.Internal.Show.Show i => GHC.Internal.Show.Show (Language.C.Types.Parse.DirectDeclarator i)
instance GHC.Internal.Show.Show Language.C.Types.Parse.FunctionSpecifier
instance GHC.Internal.Show.Show i => GHC.Internal.Show.Show (Language.C.Types.Parse.ParameterDeclaration i)
instance GHC.Internal.Show.Show Language.C.Types.Parse.Pointer
instance GHC.Internal.Show.Show Language.C.Types.Parse.StorageClassSpecifier
instance GHC.Internal.Show.Show Language.C.Types.Parse.TypeQualifier
instance GHC.Internal.Show.Show Language.C.Types.Parse.TypeSpecifier
instance GHC.Internal.Data.Traversable.Traversable Language.C.Types.Parse.AbstractDeclarator
instance GHC.Internal.Data.Traversable.Traversable Language.C.Types.Parse.ArrayOrProto
instance GHC.Internal.Data.Traversable.Traversable Language.C.Types.Parse.ArrayType
instance GHC.Internal.Data.Traversable.Traversable Language.C.Types.Parse.Declarator
instance GHC.Internal.Data.Traversable.Traversable Language.C.Types.Parse.DeclaratorOrAbstractDeclarator
instance GHC.Internal.Data.Traversable.Traversable Language.C.Types.Parse.DirectAbstractDeclarator
instance GHC.Internal.Data.Traversable.Traversable Language.C.Types.Parse.DirectDeclarator
instance GHC.Internal.Data.Traversable.Traversable Language.C.Types.Parse.ParameterDeclaration


-- | Views of C datatypes. While <a>Language.C.Types.Parse</a> defines
--   datatypes for representing the concrete syntax tree of C types, this
--   module provides friendlier views of C types, by turning them into a
--   data type matching more closely how we read and think about types,
--   both in Haskell and in C. To appreciate the difference, look at the
--   difference between <a>ParameterDeclaration</a> and
--   <a>ParameterDeclaration</a>.
--   
--   As a bonus, routines are provided for describing types in natural
--   language (English) -- see <a>describeParameterDeclaration</a> and
--   <a>describeType</a>.
module Language.C.Types

-- | A type for C identifiers.
data CIdentifier
unCIdentifier :: CIdentifier -> String
cIdentifierFromString :: Bool -> String -> Either String CIdentifier
data StorageClassSpecifier
TYPEDEF :: StorageClassSpecifier
EXTERN :: StorageClassSpecifier
STATIC :: StorageClassSpecifier
AUTO :: StorageClassSpecifier
REGISTER :: StorageClassSpecifier
data TypeQualifier
CONST :: TypeQualifier
RESTRICT :: TypeQualifier
VOLATILE :: TypeQualifier
data FunctionSpecifier
INLINE :: FunctionSpecifier
data ArrayType i
VariablySized :: ArrayType i
Unsized :: ArrayType i
SizedByInteger :: Integer -> ArrayType i
SizedByIdentifier :: i -> ArrayType i
data Specifiers
Specifiers :: [StorageClassSpecifier] -> [TypeQualifier] -> [FunctionSpecifier] -> Specifiers
[storageClassSpecifiers] :: Specifiers -> [StorageClassSpecifier]
[typeQualifiers] :: Specifiers -> [TypeQualifier]
[functionSpecifiers] :: Specifiers -> [FunctionSpecifier]
data Type i
TypeSpecifier :: Specifiers -> TypeSpecifier -> Type i
Ptr :: [TypeQualifier] -> Type i -> Type i
Array :: ArrayType i -> Type i -> Type i
Proto :: Type i -> [ParameterDeclaration i] -> Type i
data TypeSpecifier
Void :: TypeSpecifier
Bool :: TypeSpecifier
Char :: Maybe Sign -> TypeSpecifier
Short :: Sign -> TypeSpecifier
Int :: Sign -> TypeSpecifier
Long :: Sign -> TypeSpecifier
LLong :: Sign -> TypeSpecifier
Float :: TypeSpecifier
Double :: TypeSpecifier
LDouble :: TypeSpecifier
TypeName :: CIdentifier -> TypeSpecifier
Struct :: CIdentifier -> TypeSpecifier
Enum :: CIdentifier -> TypeSpecifier
Template :: CIdentifier -> [TypeSpecifier] -> TypeSpecifier
TemplateConst :: String -> TypeSpecifier
TemplatePointer :: TypeSpecifier -> TypeSpecifier
data Sign
Signed :: Sign
Unsigned :: Sign
data ParameterDeclaration i
ParameterDeclaration :: Maybe i -> Type i -> ParameterDeclaration i
[parameterDeclarationId] :: ParameterDeclaration i -> Maybe i
[parameterDeclarationType] :: ParameterDeclaration i -> Type i

-- | A collection of named types (typedefs)
type TypeNames = HashSet CIdentifier

-- | All the parsing is done using the type classes provided by the
--   <tt>parsers</tt> package. You can use the parsing routines with any of
--   the parsers that implement the classes, such as <tt>parsec</tt> or
--   <tt>trifecta</tt>.
--   
--   We parametrize the parsing by the type of the variable identifiers,
--   <tt>i</tt>. We do so because we use this parser to implement
--   anti-quoters referring to Haskell variables, and thus we need to parse
--   Haskell identifiers in certain positions.
type CParser i (m :: Type -> Type) = (Monad m, Functor m, Applicative m, MonadPlus m, Parsing m, CharParsing m, TokenParsing m, LookAheadParsing m, MonadReader CParserContext i m, MonadFail m, Hashable i)
data CParserContext i
cCParserContext :: Bool -> TypeNames -> CParserContext CIdentifier

-- | Runs a <tt><a>CParser</a></tt> using <tt>parsec</tt>.
runCParser :: Stream s Identity Char => CParserContext i -> String -> s -> ReaderT (CParserContext i) (Parsec s ()) a -> Either ParseError a

-- | Useful for quick testing. Uses <tt>"quickCParser"</tt> as source name,
--   and throws an <a>error</a> if parsing fails.
quickCParser :: CParserContext i -> String -> ReaderT (CParserContext i) (Parsec String ()) a -> a

-- | Like <a>quickCParser</a>, but uses <tt><a>cCParserContext</a>
--   (<a>const</a> <a>False</a>)</tt> as <a>CParserContext</a>.
quickCParser_ :: Bool -> String -> ReaderT (CParserContext CIdentifier) (Parsec String ()) a -> a
parseParameterDeclaration :: (CParser i m, Pretty i) => m (ParameterDeclaration i)
parseParameterList :: (CParser i m, Pretty i) => m [ParameterDeclaration i]
parseIdentifier :: CParser i m => m i
parseEnableCpp :: CParser i m => m Bool
parseType :: (CParser i m, Pretty i) => m (Type i)
data UntangleErr
MultipleDataTypes :: [DeclarationSpecifier] -> UntangleErr
NoDataTypes :: [DeclarationSpecifier] -> UntangleErr
IllegalSpecifiers :: String -> [TypeSpecifier] -> UntangleErr
untangleParameterDeclaration :: ParameterDeclaration i -> Either UntangleErr (ParameterDeclaration i)
tangleParameterDeclaration :: ParameterDeclaration i -> ParameterDeclaration i
describeParameterDeclaration :: Pretty i => ParameterDeclaration i -> Doc ann
describeType :: Pretty i => Type i -> Doc ann
instance GHC.Classes.Eq i => GHC.Classes.Eq (Language.C.Types.ParameterDeclaration i)
instance GHC.Classes.Eq Language.C.Types.Sign
instance GHC.Classes.Eq Language.C.Types.Specifiers
instance GHC.Classes.Eq i => GHC.Classes.Eq (Language.C.Types.Type i)
instance GHC.Classes.Eq Language.C.Types.TypeSpecifier
instance GHC.Classes.Eq Language.C.Types.UntangleErr
instance GHC.Internal.Data.Foldable.Foldable Language.C.Types.ParameterDeclaration
instance GHC.Internal.Data.Foldable.Foldable Language.C.Types.Type
instance GHC.Internal.Base.Functor Language.C.Types.ParameterDeclaration
instance GHC.Internal.Base.Functor Language.C.Types.Type
instance GHC.Internal.Base.Monoid Language.C.Types.Specifiers
instance GHC.Classes.Ord Language.C.Types.Sign
instance GHC.Classes.Ord Language.C.Types.TypeSpecifier
instance Prettyprinter.Internal.Pretty i => Prettyprinter.Internal.Pretty (Language.C.Types.ParameterDeclaration i)
instance Prettyprinter.Internal.Pretty i => Prettyprinter.Internal.Pretty (Language.C.Types.Type i)
instance Prettyprinter.Internal.Pretty Language.C.Types.TypeSpecifier
instance Prettyprinter.Internal.Pretty Language.C.Types.UntangleErr
instance GHC.Internal.Base.Semigroup Language.C.Types.Specifiers
instance GHC.Internal.Show.Show i => GHC.Internal.Show.Show (Language.C.Types.ParameterDeclaration i)
instance GHC.Internal.Show.Show Language.C.Types.Sign
instance GHC.Internal.Show.Show Language.C.Types.Specifiers
instance GHC.Internal.Show.Show i => GHC.Internal.Show.Show (Language.C.Types.Type i)
instance GHC.Internal.Show.Show Language.C.Types.TypeSpecifier
instance GHC.Internal.Show.Show Language.C.Types.UntangleErr
instance GHC.Internal.Data.Traversable.Traversable Language.C.Types.ParameterDeclaration
instance GHC.Internal.Data.Traversable.Traversable Language.C.Types.Type

module Language.C.Inline.HaskellIdentifier

-- | A possibly qualified Haskell identifier.
data HaskellIdentifier
unHaskellIdentifier :: HaskellIdentifier -> String
haskellIdentifierFromString :: Bool -> String -> Either String HaskellIdentifier
haskellCParserContext :: Bool -> TypeNames -> CParserContext HaskellIdentifier

-- | See
--   <a>https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-160002.2</a>.
parseHaskellIdentifier :: CParser i m => m HaskellIdentifier

-- | Mangles an <a>HaskellIdentifier</a> to produce a valid
--   <a>CIdentifier</a> which still sort of resembles the
--   <a>HaskellIdentifier</a>.
mangleHaskellIdentifier :: Bool -> HaskellIdentifier -> CIdentifier
haskellReservedWords :: HashSet String
instance GHC.Classes.Eq Language.C.Inline.HaskellIdentifier.HaskellIdentifier
instance Data.Hashable.Class.Hashable Language.C.Inline.HaskellIdentifier.HaskellIdentifier
instance GHC.Internal.Data.String.IsString Language.C.Inline.HaskellIdentifier.HaskellIdentifier
instance GHC.Classes.Ord Language.C.Inline.HaskellIdentifier.HaskellIdentifier
instance Prettyprinter.Internal.Pretty Language.C.Inline.HaskellIdentifier.HaskellIdentifier
instance GHC.Internal.Show.Show Language.C.Inline.HaskellIdentifier.HaskellIdentifier


-- | A <a>Context</a> is used to define the capabilities of the Template
--   Haskell code that handles the inline C code. See the documentation of
--   the data type for more details.
--   
--   In practice, a <a>Context</a> will have to be defined for each library
--   that defines new C types, to allow the TemplateHaskell code to
--   interpret said types correctly.
module Language.C.Inline.Context

-- | A mapping from <a>TypeSpecifier</a>s to Haskell types. Needed both to
--   parse C types, and to convert them to Haskell types.
type TypesTable = Map TypeSpecifier TypeQ

-- | A data type to indicate whether the user requested pure or IO function
--   from Haskell
data Purity
Pure :: Purity
IO :: Purity

-- | Given a <a>Context</a>, it uses its <a>ctxTypesTable</a> to convert
--   arbitrary C types.
convertType :: Purity -> TypesTable -> Type CIdentifier -> Q (Maybe Type)

-- | An alias for <a>Ptr</a>.
type CArray = Ptr
typeNamesFromTypesTable :: TypesTable -> TypeNames
data AntiQuoter a
AntiQuoter :: (forall (m :: Type -> Type). CParser HaskellIdentifier m => m (CIdentifier, Type CIdentifier, a)) -> (Purity -> TypesTable -> Type CIdentifier -> a -> Q (Type, Exp)) -> AntiQuoter a

-- | Parses the body of the antiquotation, returning a hint for the name to
--   assign to the variable that will replace the anti-quotation, the type
--   of said variable, and some arbitrary data which will then be fed to
--   <a>aqMarshaller</a>.
--   
--   The <a>Type</a> has <tt>Void</tt> as an identifier type to make sure
--   that no names appear in it.
[aqParser] :: AntiQuoter a -> forall (m :: Type -> Type). CParser HaskellIdentifier m => m (CIdentifier, Type CIdentifier, a)

-- | Takes the requested purity, the current <a>TypesTable</a>, and the
--   type and the body returned by <a>aqParser</a>.
--   
--   Returns the Haskell type for the parameter, and the Haskell expression
--   that will be passed in as the parameter.
--   
--   If the the type returned is <tt>ty</tt>, the <a>Exp</a> <b>must</b>
--   have type <tt>forall a. (ty -&gt; IO a) -&gt; IO a</tt>. This allows
--   to do resource handling when preparing C values.
--   
--   Care must be taken regarding <a>Purity</a>. Specifically, the
--   generated IO computation must be idempotent to guarantee its safety
--   when used in pure code. We cannot prevent the IO computation from
--   being inlined, hence potentially duplicated. If non-idempotent
--   marshallers are required (e.g. if an update to some global state is
--   needed), it is best to throw an error when <a>Purity</a> is
--   <a>Pure</a> (for example "you cannot use context X with
--   <tt>pure</tt>"), which will show up at compile time.
[aqMarshaller] :: AntiQuoter a -> Purity -> TypesTable -> Type CIdentifier -> a -> Q (Type, Exp)

-- | An identifier for a <a>AntiQuoter</a>.
type AntiQuoterId = String

-- | Existential wrapper around <a>AntiQuoter</a>.
data SomeAntiQuoter
SomeAntiQuoter :: AntiQuoter a -> SomeAntiQuoter
type AntiQuoters = Map AntiQuoterId SomeAntiQuoter

-- | A <a>Context</a> stores various information needed to produce the
--   files with the C code derived from the inline C snippets.
--   
--   <a>Context</a>s can be composed with their <a>Monoid</a> instance,
--   where <a>mappend</a> is right-biased -- in <tt><a>mappend</a> x y</tt>
--   <tt>y</tt> will take precedence over <tt>x</tt>.
data Context
Context :: TypesTable -> AntiQuoters -> Maybe (String -> String) -> Maybe ForeignSrcLang -> Bool -> Maybe (String -> Q FilePath) -> Context

-- | Needed to convert C types to Haskell types.
[ctxTypesTable] :: Context -> TypesTable

-- | Needed to parse and process antiquotations.
[ctxAntiQuoters] :: Context -> AntiQuoters

-- | This function is used to post-process the functions generated from the
--   C snippets. Currently just used to specify C linkage when generating
--   C++ code.
[ctxOutput] :: Context -> Maybe (String -> String)

-- | TH.LangC by default
[ctxForeignSrcLang] :: Context -> Maybe ForeignSrcLang

-- | Compile source code to raw object.
[ctxEnableCpp] :: Context -> Bool
[ctxRawObjectCompile] :: Context -> Maybe (String -> Q FilePath)

-- | Context useful to work with vanilla C. Used by default.
--   
--   <a>ctxTypesTable</a>: converts C basic types to their counterparts in
--   <a>Foreign.C.Types</a>.
--   
--   No <a>ctxAntiQuoters</a>.
baseCtx :: Context

-- | This <a>Context</a> adds support for <tt>ForeignPtr</tt> arguments. It
--   adds a unique marshaller called <tt>fptr-ptr</tt>. For example,
--   <tt>$fptr-ptr:(int *x)</tt> extracts the bare C pointer out of foreign
--   pointer <tt>x</tt>.
fptrCtx :: Context

-- | This <a>Context</a> includes a <a>AntiQuoter</a> that removes the need
--   for explicitely creating <a>FunPtr</a>s, named <tt>"fun"</tt> along
--   with one which allocates new memory which must be manually freed named
--   <tt>"fun-alloc"</tt>.
--   
--   For example, we can capture function <tt>f</tt> of type <tt>CInt -&gt;
--   CInt -&gt; IO CInt</tt> in C code using <tt>$fun:(int (*f)(int,
--   int))</tt>.
--   
--   When used in a <tt>pure</tt> embedding, the Haskell function will have
--   to be pure too. Continuing the example above we'll have <tt>CInt -&gt;
--   CInt -&gt; IO CInt</tt>.
--   
--   Does not include the <a>baseCtx</a>, since most of the time it's going
--   to be included as part of larger contexts.
--   
--   IMPORTANT: When using the <tt>fun</tt> anti quoter, one must be aware
--   that the function pointer which is automatically generated is freed
--   when the code contained in the block containing the anti quoter exits.
--   Thus, if you need the function pointer to be longer-lived, you must
--   allocate it and free it manually using <a>freeHaskellFunPtr</a>. We
--   provide utilities to easily allocate them (see <a>mkFunPtr</a>).
--   
--   IMPORTANT: When using the <tt>fun-alloc</tt> anti quoter, one must
--   free the allocated function pointer. The GHC runtime provides a
--   function to do this, <tt>hs_free_fun_ptr</tt> available in the
--   <a>h</a> header.
funCtx :: Context

-- | This <a>Context</a> includes two <a>AntiQuoter</a>s that allow to
--   easily use Haskell vectors in C.
--   
--   Specifically, the <tt>vec-len</tt> and <tt>vec-ptr</tt> will get the
--   length and the pointer underlying mutable (<a>IOVector</a>) and
--   immutable (<a>Vector</a>) storable vectors.
--   
--   Note that if you use <a>vecCtx</a> to manipulate immutable vectors you
--   must make sure that the vector is not modified in the C code.
--   
--   To use <tt>vec-len</tt>, simply write <tt>$vec-len:x</tt>, where
--   <tt>x</tt> is something of type <tt><a>IOVector</a> a</tt> or
--   <tt><a>Vector</a> a</tt>, for some <tt>a</tt>. To use <tt>vec-ptr</tt>
--   you need to specify the type of the pointer, e.g. <tt>$vec-len:(int
--   *x)</tt> will work if <tt>x</tt> has type <tt><a>IOVector</a>
--   <a>CInt</a></tt>.
vecCtx :: Context

-- | Type class used to implement the anti-quoters in <a>vecCtx</a>.
class VecCtx a where {
    type VecCtxScalar a;
}
vecCtxLength :: VecCtx a => a -> Int
vecCtxUnsafeWith :: VecCtx a => a -> (Ptr (VecCtxScalar a) -> IO b) -> IO b

-- | <a>bsCtx</a> serves exactly the same purpose as <a>vecCtx</a>, but
--   only for <a>ByteString</a>. <tt>vec-ptr</tt> becomes <tt>bs-ptr</tt>,
--   and <tt>vec-len</tt> becomes <tt>bs-len</tt>. You don't need to
--   specify the type of the pointer in <tt>bs-ptr</tt>, it will always be
--   <tt>char*</tt>.
--   
--   Moreover, <tt>bs-cstr</tt> works as <tt>bs-ptr</tt> but it provides a
--   null-terminated copy of the given <a>ByteString</a>.
bsCtx :: Context
instance GHC.Classes.Eq Language.C.Inline.Context.Purity
instance GHC.Internal.Base.Monoid Language.C.Inline.Context.Context
instance GHC.Internal.Base.Semigroup Language.C.Inline.Context.Context
instance GHC.Internal.Show.Show Language.C.Inline.Context.Purity
instance GHC.Internal.Foreign.Storable.Storable a => Language.C.Inline.Context.VecCtx (Data.Vector.Storable.Mutable.IOVector a)
instance GHC.Internal.Foreign.Storable.Storable a => Language.C.Inline.Context.VecCtx (Data.Vector.Storable.Vector a)

module Language.C.Inline.Internal

-- | Sets the <a>Context</a> for the current module. This function, if
--   called, must be called before any of the other TH functions in this
--   module. Fails if that's not the case.
setContext :: Context -> Q ()

-- | Gets the current <a>Context</a>. Also makes sure that the current
--   module is initialised.
getContext :: Q Context
newtype Substitutions
Substitutions :: Map String (String -> String) -> Substitutions
[unSubstitutions] :: Substitutions -> Map String (String -> String)

-- | Define macros that can be used in the nested Template Haskell
--   expression. Macros can be used as <tt>@MACRO_NAME(input)</tt> in
--   inline-c quotes, and will transform their input with the given
--   function. They can be useful for passing in types when defining
--   Haskell instances for C++ template types.
substitute :: [(String, String -> String)] -> Q a -> Q a

-- | Given a C type name, return the Haskell type in Template Haskell. The
--   first parameter controls whether function pointers should be mapped as
--   pure or IO functions.
getHaskellType :: Bool -> String -> TypeQ

-- | Simply appends some string to the module's C file. Use with care.
emitVerbatim :: String -> DecsQ

-- | Simply appends some string of block to the module's C file. Use with
--   care.
emitBlock :: QuasiQuoter

-- | Data type representing a list of C definitions with a typed and named
--   entry function.
--   
--   We use it as a basis to inline and call C code.
data Code
Code :: Safety -> Maybe Loc -> TypeQ -> String -> String -> Bool -> Code

-- | Safety of the foreign call.
[codeCallSafety] :: Code -> Safety

-- | The haskell source location used for the #line directive
[codeLoc] :: Code -> Maybe Loc

-- | Type of the foreign call.
[codeType] :: Code -> TypeQ

-- | Name of the function to call in the code below.
[codeFunName] :: Code -> String

-- | The C code.
[codeDefs] :: Code -> String

-- | If <a>True</a>, the type will be wrapped in <a>FunPtr</a>, and the
--   call will be static (e.g. prefixed by &amp;).
[codeFunPtr] :: Code -> Bool

-- | Inlines a piece of code inline. The resulting <a>Exp</a> will have the
--   type specified in the <a>codeType</a>.
--   
--   In practice, this function outputs the C code to the module's C file,
--   and then inserts a foreign call of type <a>codeType</a> calling the
--   provided <a>codeFunName</a>.
--   
--   Example:
--   
--   <pre>
--   c_add :: Int -&gt; Int -&gt; Int
--   c_add = $(do
--     here &lt;- TH.location
--     inlineCode $ Code
--       TH.Unsafe                   -- Call safety
--       (Just here)
--       [t| Int -&gt; Int -&gt; Int |]    -- Call type
--       "francescos_add"            -- Call name
--       -- C Code
--       "int francescos_add(int x, int y) { int z = x + y; return z; }")
--   </pre>
inlineCode :: Code -> ExpQ

-- | Same as <tt>inlineCItems</tt>, but with a single expression.
--   
--   <pre>
--   c_cos :: Double -&gt; Double
--   c_cos = $(do
--     here &lt;- TH.location
--     inlineExp
--       TH.Unsafe
--       here
--       [t| Double -&gt; Double |]
--       (quickCParser_ "double" parseType)
--       [("x", quickCParser_ "double" parseType)]
--       "cos(x)")
--   </pre>
inlineExp :: Safety -> Loc -> TypeQ -> Type CIdentifier -> [(CIdentifier, Type CIdentifier)] -> String -> ExpQ

-- | Same as <a>inlineCode</a>, but accepts a string containing a list of C
--   statements instead instead than a full-blown <a>Code</a>. A function
--   containing the provided statement will be automatically generated.
--   
--   <pre>
--   c_cos :: Double -&gt; Double
--   c_cos = $(do
--    here &lt;- TH.location
--    inlineItems
--     TH.Unsafe
--     False
--     Nothing
--     here
--     [t| Double -&gt; Double |]
--     (quickCParser_ "double" parseType)
--     [("x", quickCParser_ "double" parseType)]
--     "return cos(x);")
--   </pre>
inlineItems :: Safety -> Bool -> Maybe String -> Loc -> TypeQ -> Type CIdentifier -> [(CIdentifier, Type CIdentifier)] -> String -> ExpQ
data SomeEq
toSomeEq :: (Eq a, Typeable a) => a -> SomeEq
fromSomeEq :: (Eq a, Typeable a) => SomeEq -> Maybe a
data ParameterType
Plain :: HaskellIdentifier -> ParameterType
AntiQuote :: AntiQuoterId -> SomeEq -> ParameterType
data ParseTypedC
ParseTypedC :: Type CIdentifier -> [(CIdentifier, Type CIdentifier, ParameterType)] -> String -> ParseTypedC
[ptcReturnType] :: ParseTypedC -> Type CIdentifier
[ptcParameters] :: ParseTypedC -> [(CIdentifier, Type CIdentifier, ParameterType)]
[ptcBody] :: ParseTypedC -> String
parseTypedC :: CParser HaskellIdentifier m => Bool -> AntiQuoters -> m ParseTypedC
runParserInQ :: Hashable ident => String -> CParserContext ident -> (forall (m :: Type -> Type). CParser ident m => m a) -> Q a

-- | Returns the type and the body separately.
splitTypedC :: String -> (String, String, Int)

-- | Tell the C compiler where the next line came from.
--   
--   Example:
--   
--   @@<tt> there &lt;- location f (unlines [ lineDirective $(here) ,
--   "generated_code_user_did_not_write()" , lineDirective there ] ++
--   userCode ]) </tt>@@
--   
--   Use <tt>lineDirective $(C.here)</tt> when generating code, so that any
--   errors or warnings report the location of the generating haskell
--   module, rather than tangentially related user code that doesn't
--   contain the actual problem.
lineDirective :: Loc -> String

-- | Get the location of the code you're looking at, for use with
--   <a>lineDirective</a>; place before generated code that user did not
--   write.
here :: ExpQ
shiftLines :: Int -> Loc -> Loc
genericQuote :: Purity -> (Loc -> TypeQ -> Type CIdentifier -> [(CIdentifier, Type CIdentifier)] -> String -> ExpQ) -> QuasiQuoter
funPtrQuote :: Safety -> QuasiQuoter
instance GHC.Classes.Eq Language.C.Inline.Internal.FunPtrDecl
instance GHC.Classes.Eq Language.C.Inline.Internal.ParameterType
instance GHC.Classes.Eq Language.C.Inline.Internal.SomeEq
instance GHC.Internal.Show.Show Language.C.Inline.Internal.FunPtrDecl
instance GHC.Internal.Show.Show Language.C.Inline.Internal.ParameterType
instance GHC.Internal.Show.Show Language.C.Inline.Internal.SomeEq


-- | <tt>unsafe</tt> variants of the <a>Language.C.Inline</a>
--   quasi-quoters, to call the C code unsafely in the sense of
--   <a>https://www.haskell.org/onlinereport/haskell2010/haskellch8.html#x15-1590008.4.3</a>.
--   In GHC, unsafe foreign calls are faster than safe foreign calls, but
--   the user must guarantee the control flow will never enter Haskell code
--   (via a callback or otherwise) before the call is done.
--   
--   This module is intended to be imported qualified:
--   
--   <pre>
--   import qualified <a>Language.C.Inline.Unsafe</a> as CU
--   </pre>
module Language.C.Inline.Unsafe

-- | C expressions.
exp :: QuasiQuoter

-- | Variant of <a>exp</a>, for use with expressions known to have no side
--   effects.
--   
--   <b>BEWARE</b>: Use this function with caution, only when you know what
--   you are doing. If an expression does in fact have side-effects, then
--   indiscriminate use of <a>pure</a> may endanger referential
--   transparency, and in principle even type safety. Also note that the
--   function may run more than once and that it may run in parallel with
--   itself, given that <a>unsafeDupablePerformIO</a> is used to call the
--   provided C code <a>to ensure good performance using the threaded
--   runtime</a>. Please refer to the documentation for
--   <a>unsafeDupablePerformIO</a> for more details.
pure :: QuasiQuoter

-- | C code blocks (i.e. statements).
block :: QuasiQuoter


-- | <tt>interruptible</tt> variants of the <a>Language.C.Inline</a>
--   quasi-quoters, to call interruptible C code. See
--   <a>https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ffi-chap.html#interruptible-foreign-calls</a>
--   for more information.
--   
--   This module is intended to be imported qualified:
--   
--   <pre>
--   import qualified <a>Language.C.Inline.Interruptible</a> as CI
--   </pre>
module Language.C.Inline.Interruptible

-- | C expressions.
exp :: QuasiQuoter

-- | Variant of <a>exp</a>, for use with expressions known to have no side
--   effects.
--   
--   <b>BEWARE</b>: Use this function with caution, only when you know what
--   you are doing. If an expression does in fact have side-effects, then
--   indiscriminate use of <a>pure</a> may endanger referential
--   transparency, and in principle even type safety. Also note that the
--   function may run more than once and that it may run in parallel with
--   itself, given that <a>unsafeDupablePerformIO</a> is used to call the
--   provided C code <a>to ensure good performance using the threaded
--   runtime</a>. Please refer to the documentation for
--   <a>unsafeDupablePerformIO</a> for more details.
pure :: QuasiQuoter

-- | C code blocks (i.e. statements).
block :: QuasiQuoter


-- | Enable painless embedding of C code in Haskell code. If you're
--   interested in how to use the library, skip to the "Inline C" section.
--   To build, read the first two sections.
--   
--   This module is intended to be imported qualified:
--   
--   <pre>
--   import qualified <a>Language.C.Inline</a> as C
--   </pre>
module Language.C.Inline

-- | A <a>Context</a> stores various information needed to produce the
--   files with the C code derived from the inline C snippets.
--   
--   <a>Context</a>s can be composed with their <a>Monoid</a> instance,
--   where <a>mappend</a> is right-biased -- in <tt><a>mappend</a> x y</tt>
--   <tt>y</tt> will take precedence over <tt>x</tt>.
data Context

-- | Context useful to work with vanilla C. Used by default.
--   
--   <a>ctxTypesTable</a>: converts C basic types to their counterparts in
--   <a>Foreign.C.Types</a>.
--   
--   No <a>ctxAntiQuoters</a>.
baseCtx :: Context

-- | This <a>Context</a> adds support for <tt>ForeignPtr</tt> arguments. It
--   adds a unique marshaller called <tt>fptr-ptr</tt>. For example,
--   <tt>$fptr-ptr:(int *x)</tt> extracts the bare C pointer out of foreign
--   pointer <tt>x</tt>.
fptrCtx :: Context

-- | This <a>Context</a> includes a <a>AntiQuoter</a> that removes the need
--   for explicitely creating <a>FunPtr</a>s, named <tt>"fun"</tt> along
--   with one which allocates new memory which must be manually freed named
--   <tt>"fun-alloc"</tt>.
--   
--   For example, we can capture function <tt>f</tt> of type <tt>CInt -&gt;
--   CInt -&gt; IO CInt</tt> in C code using <tt>$fun:(int (*f)(int,
--   int))</tt>.
--   
--   When used in a <tt>pure</tt> embedding, the Haskell function will have
--   to be pure too. Continuing the example above we'll have <tt>CInt -&gt;
--   CInt -&gt; IO CInt</tt>.
--   
--   Does not include the <a>baseCtx</a>, since most of the time it's going
--   to be included as part of larger contexts.
--   
--   IMPORTANT: When using the <tt>fun</tt> anti quoter, one must be aware
--   that the function pointer which is automatically generated is freed
--   when the code contained in the block containing the anti quoter exits.
--   Thus, if you need the function pointer to be longer-lived, you must
--   allocate it and free it manually using <a>freeHaskellFunPtr</a>. We
--   provide utilities to easily allocate them (see <a>mkFunPtr</a>).
--   
--   IMPORTANT: When using the <tt>fun-alloc</tt> anti quoter, one must
--   free the allocated function pointer. The GHC runtime provides a
--   function to do this, <tt>hs_free_fun_ptr</tt> available in the
--   <a>h</a> header.
funCtx :: Context

-- | This <a>Context</a> includes two <a>AntiQuoter</a>s that allow to
--   easily use Haskell vectors in C.
--   
--   Specifically, the <tt>vec-len</tt> and <tt>vec-ptr</tt> will get the
--   length and the pointer underlying mutable (<a>IOVector</a>) and
--   immutable (<a>Vector</a>) storable vectors.
--   
--   Note that if you use <a>vecCtx</a> to manipulate immutable vectors you
--   must make sure that the vector is not modified in the C code.
--   
--   To use <tt>vec-len</tt>, simply write <tt>$vec-len:x</tt>, where
--   <tt>x</tt> is something of type <tt><a>IOVector</a> a</tt> or
--   <tt><a>Vector</a> a</tt>, for some <tt>a</tt>. To use <tt>vec-ptr</tt>
--   you need to specify the type of the pointer, e.g. <tt>$vec-len:(int
--   *x)</tt> will work if <tt>x</tt> has type <tt><a>IOVector</a>
--   <a>CInt</a></tt>.
vecCtx :: Context

-- | <a>bsCtx</a> serves exactly the same purpose as <a>vecCtx</a>, but
--   only for <a>ByteString</a>. <tt>vec-ptr</tt> becomes <tt>bs-ptr</tt>,
--   and <tt>vec-len</tt> becomes <tt>bs-len</tt>. You don't need to
--   specify the type of the pointer in <tt>bs-ptr</tt>, it will always be
--   <tt>char*</tt>.
--   
--   Moreover, <tt>bs-cstr</tt> works as <tt>bs-ptr</tt> but it provides a
--   null-terminated copy of the given <a>ByteString</a>.
bsCtx :: Context

-- | Sets the <a>Context</a> for the current module. This function, if
--   called, must be called before any of the other TH functions in this
--   module. Fails if that's not the case.
context :: Context -> DecsQ

-- | Define macros that can be used in the nested Template Haskell
--   expression. Macros can be used as <tt>@MACRO_NAME(input)</tt> in
--   inline-c quotes, and will transform their input with the given
--   function. They can be useful for passing in types when defining
--   Haskell instances for C++ template types.
substitute :: [(String, String -> String)] -> Q a -> Q a

-- | Given a C type name, return the Haskell type in Template Haskell. The
--   first parameter controls whether function pointers should be mapped as
--   pure or IO functions.
getHaskellType :: Bool -> String -> TypeQ

-- | C expressions.
exp :: QuasiQuoter

-- | Variant of <a>exp</a>, for use with expressions known to have no side
--   effects.
--   
--   <b>BEWARE</b>: Use this function with caution, only when you know what
--   you are doing. If an expression does in fact have side-effects, then
--   indiscriminate use of <a>pure</a> may endanger referential
--   transparency, and in principle even type safety. Also note that the
--   function might be called multiple times, given that
--   <a>unsafeDupablePerformIO</a> is used to call the provided C code.
--   Please refer to the documentation for <a>unsafePerformIO</a> for more
--   details. <a>unsafeDupablePerformIO is used to ensure good performance
--   using the threaded runtime</a>.
pure :: QuasiQuoter

-- | C code blocks (i.e. statements).
block :: QuasiQuoter

-- | Emits a CPP include directive for C code associated with the current
--   module. To avoid having to escape quotes, the function itself adds
--   them when appropriate, so that
--   
--   <pre>
--   include "foo.h" ==&gt; #include "foo.h"
--   </pre>
--   
--   but
--   
--   <pre>
--   include "&lt;foo&gt;" ==&gt; #include &lt;foo&gt;
--   </pre>
include :: String -> DecsQ

-- | Emits an arbitrary C string to the C code associated with the current
--   module. Use with care.
verbatim :: String -> DecsQ

-- | Simply appends some string of block to the module's C file. Use with
--   care.
emitBlock :: QuasiQuoter

-- | Like <a>alloca</a>, but also peeks the contents of the <a>Ptr</a> and
--   returns them once the provided action has finished.
withPtr :: Storable a => (Ptr a -> IO b) -> IO (a, b)
withPtr_ :: Storable a => (Ptr a -> IO ()) -> IO a

-- | Type class with methods useful to allocate and peek multiple pointers
--   at once:
--   
--   <pre>
--   withPtrs_ :: (Storable a, Storable b) =&gt; ((Ptr a, Ptr b) -&gt; IO ()) -&gt; IO (a, b)
--   withPtrs_ :: (Storable a, Storable b, Storable c) =&gt; ((Ptr a, Ptr b, Ptr c) -&gt; IO ()) -&gt; IO (a, b, c)
--   ...
--   </pre>
class WithPtrs a where {
    type WithPtrsPtrs a;
}
withPtrs :: WithPtrs a => (WithPtrsPtrs a -> IO b) -> IO (a, b)
withPtrs_ :: WithPtrs a => (WithPtrsPtrs a -> IO ()) -> IO a

-- | Easily get a <tt>FunPtr</tt>:
--   
--   <pre>
--   let fp :: FunPtr (Ptr CInt -&gt; IO ()) = [C.funPtr| void poke42(int *ptr) { *ptr = 42; } |]
--   </pre>
--   
--   Especially useful to generate finalizers that require C code.
--   
--   Most importantly, this allows you to write <a>newForeignPtr</a>
--   invocations conveniently:
--   
--   <pre>
--   do
--     let c_finalizer_funPtr =
--           [C.funPtr| void myfree(char * ptr) { free(ptr); } |]
--     fp &lt;- newForeignPtr c_finalizer_funPtr objPtr
--   </pre>
--   
--   Using where possible <a>newForeignPtr</a> is superior to resorting to
--   its delayed-by-a-thread alternative <a>newForeignPtr</a> from
--   <a>Foreign.Concurrent</a> which takes an <tt>IO ()</tt> Haskell
--   finaliser action: With the non-concurrent <tt>newForeignPtr</tt> you
--   can guarantee that the finaliser will actually be run
--   
--   <ul>
--   <li>when a GC is executed under memory pressure, because it can point
--   directly to a C function that doesn't have to run any Haskell code
--   (which is problematic when you're out of memory)</li>
--   <li>when the program terminates (<a>newForeignPtr</a>'s finaliser will
--   likely NOT be called if your main thread exits, making your program
--   e.g. not Valgrind-clean if your finaliser is <tt>free</tt> or C++'s
--   <tt>delete</tt>).</li>
--   </ul>
--   
--   <a>funPtr</a> makes the normal <tt>newForeignPtr</tt> as convenient as
--   its concurrent counterpart.
funPtr :: QuasiQuoter

-- | <tt>$(<a>mkFunPtr</a> [t| <tt>CDouble</tt> -&gt; <a>IO</a>
--   <tt>CDouble</tt> |] </tt> generates a foreign import wrapper of type
--   
--   <pre>
--   (<tt>CDouble</tt> -&gt; <a>IO</a> <tt>CDouble</tt>) -&gt; <a>IO</a> (<a>FunPtr</a> (<tt>CDouble</tt> -&gt; <a>IO</a> <tt>CDouble</tt>))
--   </pre>
--   
--   And invokes it.
mkFunPtr :: TypeQ -> ExpQ

-- | <tt>$(<a>mkFunPtrFromName</a> 'foo)</tt>, if <tt>foo ::
--   <tt>CDouble</tt> -&gt; <a>IO</a> <tt>CDouble</tt></tt>, splices in an
--   expression of type <tt><a>IO</a> (<a>FunPtr</a> (<tt>CDouble</tt>
--   -&gt; <a>IO</a> <tt>CDouble</tt>))</tt>.
mkFunPtrFromName :: Name -> ExpQ

-- | <tt>$(<a>peekFunPtr</a> [t| <tt>CDouble</tt> -&gt; <a>IO</a>
--   <tt>CDouble</tt> |])</tt> generates a foreign import dynamic of type
--   
--   <pre>
--   <a>FunPtr</a> (<tt>CDouble</tt> -&gt; <a>IO</a> <tt>CDouble</tt>) -&gt; (<tt>CDouble</tt> -&gt; <a>IO</a> <tt>CDouble</tt>)
--   </pre>
--   
--   And invokes it.
peekFunPtr :: TypeQ -> ExpQ
instance (GHC.Internal.Foreign.Storable.Storable a, GHC.Internal.Foreign.Storable.Storable b) => Language.C.Inline.WithPtrs (a, b)
instance (GHC.Internal.Foreign.Storable.Storable a, GHC.Internal.Foreign.Storable.Storable b, GHC.Internal.Foreign.Storable.Storable c) => Language.C.Inline.WithPtrs (a, b, c)
instance (GHC.Internal.Foreign.Storable.Storable a, GHC.Internal.Foreign.Storable.Storable b, GHC.Internal.Foreign.Storable.Storable c, GHC.Internal.Foreign.Storable.Storable d) => Language.C.Inline.WithPtrs (a, b, c, d)
instance (GHC.Internal.Foreign.Storable.Storable a, GHC.Internal.Foreign.Storable.Storable b, GHC.Internal.Foreign.Storable.Storable c, GHC.Internal.Foreign.Storable.Storable d, GHC.Internal.Foreign.Storable.Storable e) => Language.C.Inline.WithPtrs (a, b, c, d, e)
instance (GHC.Internal.Foreign.Storable.Storable a, GHC.Internal.Foreign.Storable.Storable b, GHC.Internal.Foreign.Storable.Storable c, GHC.Internal.Foreign.Storable.Storable d, GHC.Internal.Foreign.Storable.Storable e, GHC.Internal.Foreign.Storable.Storable f) => Language.C.Inline.WithPtrs (a, b, c, d, e, f)
instance (GHC.Internal.Foreign.Storable.Storable a, GHC.Internal.Foreign.Storable.Storable b, GHC.Internal.Foreign.Storable.Storable c, GHC.Internal.Foreign.Storable.Storable d, GHC.Internal.Foreign.Storable.Storable e, GHC.Internal.Foreign.Storable.Storable f, GHC.Internal.Foreign.Storable.Storable g) => Language.C.Inline.WithPtrs (a, b, c, d, e, f, g)
